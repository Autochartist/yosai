{
    "docs": [
        {
            "location": "/",
            "text": "Something here",
            "title": "Home"
        },
        {
            "location": "/#something-here",
            "text": "",
            "title": "Something here"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nWithin this section of documentation, you will learn the fundamental concepts presented in Yosai.  More detailed documentation, including tutorials, is available in subsequent sections.\n\n\nWhat is Yosai?\n\n\nYosai helps you to control who can use your application and how it is used,\nmanaging state between requests.  In other words, Yosai offers authentication,\n authorization, and session management, respectively.\n\n\nArchitectural Overview: yosai.core\n\n\nYosai is a framework, allowing you to add or replace components that are designed according to documented interface specifications.  More specifically, the framework is defined using a collection of abstract base classes.\n\n\n\n\nAlthough it is customizable, Yosai features a set of default implementations to address its most anticipated uses. It is \"built to contract\", featuring concrete implementations of abstract base classes that collectively define Yosai's architecture. Developers who find Yosai's default concrete implementations unsuitable for their needs may implement their own components according to ABC specifications and swap components.\n\n\nFundamentals\n\n\nInitializing Yosai\n\n\nWith Yosai initialized, you can authenticate, authorize, and manage sessions.\n\n\nTo initialize Yosai, you must tell Yosai where to obtain its settings from.  \n\n\nThese settings include information such as:\n\n\n\n\nCryptographic hashing settings for password-based authentication\n\n\nWhether caching is enabled, and if so what CacheHandler to use\n\n\nThe AccountStore instance(s) from which to obtain authentication and\n  authorization information\n\n\nA class defining special marshalling logic uses for server-side sessions,\n  if one is required for your sessions and you are caching\n\n\n\n\nYosai is configured through a YAML-formatted settings file.  An example of\nthis configuration file can be found within the \nyosai.core.conf directory\n\nof the Yosai project, named \nyosai_settings.yaml\n.  When you initialize a Yosai\ninstance, you specify as an argument \neither\n a file_path to a configured settings\nfile or an environment variable (env_var) that references the location of this file in\nthe system that will use Yosai:\n\n\n  \n#option 1\n\n  \nyosai\n \n=\n \nYosai(env_var\n=\n'ANY_ENV_VAR_NAME_YOU_WANT'\n)\n\n\n  \n#option 2\n\n  \nyosai\n \n=\n \nYosai(file_path\n=\n'/../../../whatever_filename_you_want.yaml'\n)\n\n\n\n\n\n\n\n\n\n\nTo properly serialize your session attributes, you will need to define\n  a custom session attributes schema class containing marshalling logic,\n  if your session attributes are beyond simple primitive data types available\n  from python standard library.  \n\n\n\n\n\n\nIntroducing: Subject\n\n\nThe three core services provided by Yosai are:\n\n\n\n\nAuthentication\n\n\nAuthorization\n\n\nSession Management\n\n\n\n\nThese services share a common API that you will use to interact with them:  the Subject API.\n\n\nEvery security related operation is performed in the context of a \nSubject\n.\nThe term \"Subject\" is generally synonymous with \"User\" except that aside from\nhuman beings also includes non-human, system entities.  In other words, a \nSubject\n is a \nperson\n or a \nthing\n.\n\n\nAuthentication\n\n\nIn this example, we \"log in\" a Subject, performing password-based authentication\nthat raises an AuthenticationException if authentication were to fail.\n\n\nNote that the following example assumes that a \nyosai\n instance has already\nbeen instantiated and configured with a SecurityManager.  See the \nyosai init\n\ndocumentation, further below, for how to do that.\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nAuthenticationToken,\n \nYosai\n\n\n    \nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n\n        \nauthc_token\n \n=\n \nUsernamePasswordToken(username\n=\n'thedude'\n,\n\n                                            \ncredentials\n=\n'letsgobowling'\n)\n\n        \nsubject\n.\nlogin(authc_token)\n\n\n\n\n\n\n\n\nUsernamePasswordToken is a consolidation of a user account's identifying\nattributes (username) and credentials (password) submitted by a user\nduring an authentication attempt\n\n\n\n\nAuthorization\n\n\nAuthorization is conducted in your application either by decorating methods with an authorization check, such as in the example below, or by explicitly calling one of Subject's access control methods.\n\n\nThe following example confirms whether the user logged in above has sufficient\nprivileges to approve a bowling tournament application.  We illustrate what is known as the \ndeclarative style\n authorization.  Information about authorization styles can be found in the authorization documentation.\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nYosai\n\n\n    \n@Yosai.check_permission\n([\n'tournament:approve'\n])\n\n    \ndef\n \napprove_tournament_application\n(self,\n \ntournament_application):\n\n        \ntournament_application\n.\nstatus\n \n=\n \n'APPROVED'\n\n        \nself\n.\nnotify_approval(tournament_application)\n\n\n\n\n\n\nSession Management\n\n\nYosai offers session management for anonymous guests or authenticated users.\nIn the Authentication example above, the Subject is automatically allocated a\nnew session in Yosai following successful authentication.  We manage\nthe attributes of a session through a CRUD-like series of methods:\n\n\nNote that the following example assumes that a \nyosai\n instance has already\nbeen instantiated and configured with a SecurityManager.  See the \nyosai init\n\ndocumentation, further below, for how to do that.\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nYosai\n\n\n    \nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n \n        \nsession\n \n=\n \nsubject\n.\nget_session()\n\n        \nsession\n.\nset_attribute(\n'full_name'\n,\n \n'Jeffrey Lebowski'\n)",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "Within this section of documentation, you will learn the fundamental concepts presented in Yosai.  More detailed documentation, including tutorials, is available in subsequent sections.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#what-is-yosai",
            "text": "Yosai helps you to control who can use your application and how it is used,\nmanaging state between requests.  In other words, Yosai offers authentication,\n authorization, and session management, respectively.",
            "title": "What is Yosai?"
        },
        {
            "location": "/intro/#architectural-overview-yosaicore",
            "text": "Yosai is a framework, allowing you to add or replace components that are designed according to documented interface specifications.  More specifically, the framework is defined using a collection of abstract base classes.   Although it is customizable, Yosai features a set of default implementations to address its most anticipated uses. It is \"built to contract\", featuring concrete implementations of abstract base classes that collectively define Yosai's architecture. Developers who find Yosai's default concrete implementations unsuitable for their needs may implement their own components according to ABC specifications and swap components.",
            "title": "Architectural Overview: yosai.core"
        },
        {
            "location": "/intro/#fundamentals",
            "text": "",
            "title": "Fundamentals"
        },
        {
            "location": "/intro/#initializing-yosai",
            "text": "With Yosai initialized, you can authenticate, authorize, and manage sessions.  To initialize Yosai, you must tell Yosai where to obtain its settings from.    These settings include information such as:   Cryptographic hashing settings for password-based authentication  Whether caching is enabled, and if so what CacheHandler to use  The AccountStore instance(s) from which to obtain authentication and\n  authorization information  A class defining special marshalling logic uses for server-side sessions,\n  if one is required for your sessions and you are caching   Yosai is configured through a YAML-formatted settings file.  An example of\nthis configuration file can be found within the  yosai.core.conf directory \nof the Yosai project, named  yosai_settings.yaml .  When you initialize a Yosai\ninstance, you specify as an argument  either  a file_path to a configured settings\nfile or an environment variable (env_var) that references the location of this file in\nthe system that will use Yosai:     #option 1 \n   yosai   =   Yosai(env_var = 'ANY_ENV_VAR_NAME_YOU_WANT' ) \n\n   #option 2 \n   yosai   =   Yosai(file_path = '/../../../whatever_filename_you_want.yaml' )     To properly serialize your session attributes, you will need to define\n  a custom session attributes schema class containing marshalling logic,\n  if your session attributes are beyond simple primitive data types available\n  from python standard library.",
            "title": "Initializing Yosai"
        },
        {
            "location": "/intro/#introducing-subject",
            "text": "The three core services provided by Yosai are:   Authentication  Authorization  Session Management   These services share a common API that you will use to interact with them:  the Subject API.  Every security related operation is performed in the context of a  Subject .\nThe term \"Subject\" is generally synonymous with \"User\" except that aside from\nhuman beings also includes non-human, system entities.  In other words, a  Subject  is a  person  or a  thing .",
            "title": "Introducing: Subject"
        },
        {
            "location": "/intro/#authentication",
            "text": "In this example, we \"log in\" a Subject, performing password-based authentication\nthat raises an AuthenticationException if authentication were to fail.  Note that the following example assumes that a  yosai  instance has already\nbeen instantiated and configured with a SecurityManager.  See the  yosai init \ndocumentation, further below, for how to do that.       from   yosai.core   import   AuthenticationToken,   Yosai \n\n     yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' ) \n\n     with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n\n         authc_token   =   UsernamePasswordToken(username = 'thedude' , \n                                             credentials = 'letsgobowling' ) \n         subject . login(authc_token)    UsernamePasswordToken is a consolidation of a user account's identifying\nattributes (username) and credentials (password) submitted by a user\nduring an authentication attempt",
            "title": "Authentication"
        },
        {
            "location": "/intro/#authorization",
            "text": "Authorization is conducted in your application either by decorating methods with an authorization check, such as in the example below, or by explicitly calling one of Subject's access control methods.  The following example confirms whether the user logged in above has sufficient\nprivileges to approve a bowling tournament application.  We illustrate what is known as the  declarative style  authorization.  Information about authorization styles can be found in the authorization documentation.       from   yosai.core   import   Yosai \n\n     @Yosai.check_permission ([ 'tournament:approve' ]) \n     def   approve_tournament_application (self,   tournament_application): \n         tournament_application . status   =   'APPROVED' \n         self . notify_approval(tournament_application)",
            "title": "Authorization"
        },
        {
            "location": "/intro/#session-management",
            "text": "Yosai offers session management for anonymous guests or authenticated users.\nIn the Authentication example above, the Subject is automatically allocated a\nnew session in Yosai following successful authentication.  We manage\nthe attributes of a session through a CRUD-like series of methods:  Note that the following example assumes that a  yosai  instance has already\nbeen instantiated and configured with a SecurityManager.  See the  yosai init \ndocumentation, further below, for how to do that.       from   yosai.core   import   Yosai \n\n     yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' ) \n\n     with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject()  \n         session   =   subject . get_session() \n         session . set_attribute( 'full_name' ,   'Jeffrey Lebowski' )",
            "title": "Session Management"
        },
        {
            "location": "/installation_setup/",
            "text": "Installation and Setup\n\n\nInstallation\n\n\nFirst, install Yosai from PyPI using pip:\n    \npip install yosai\n\n\nInstalling from PyPI, using pip, will install the project package that includes\n\nyosai.core\n and \nyosai.web\n, a default configuration, and project dependencies.\n\n\nSetup\n\n\nYosai is configured through a YAML-formatted settings file.  An example of\nthis configuration file can be found within the yosai.core.conf  directory\nof the Yosai project, named \nyosai_settings.yaml\n.  When you initialize a Yosai\ninstance, you specify as an argument \neither\n a file_path to a configured settings\nfile or an environment variable that references the location of this file in\nthe system that will use Yosai:\n\n\n  \n#option 1\n\n  \nyosai\n \n=\n \nYosai(env_var\n=\n'ANY_ENV_VAR_NAME_YOU_WANT'\n)\n\n\n  \n#option 2\n\n  \nyosai\n \n=\n \nYosai(file_path\n=\n'/../../../whatever_filename_you_want.yaml'\n)\n\n\n\n\n\n\nConfiguration\n\n\nFollowing is a copy of the default YAML config file.  As you will see, settings\nare organized according to the services that use them:\n\n\nAUTHC_CONFIG\n:\n\n    \ndefault_algorithm\n:\n \nbcrypt_sha256\n\n    \nhash_algorithms\n:\n\n        \nbcrypt_sha256\n:\n \n{}\n\n        \nsha256_crypt\n:\n\n            \ndefault_rounds\n:\n \n110000\n\n            \nmax_rounds\n:\n \n1000000\n\n            \nmin_rounds\n:\n \n1000\n\n            \nsalt_size\n:\n \n16\n\n\n\nREMEMBER_ME_CONFIG\n:\n\n    \ndefault_cipher_key\n:\n \nyou\n \nneed\n \nto\n \nupdate\n \nthis\n \nusing\n \nthe\n \nfernet\n \nkeygen\n\n\n\nSECURITY_MANAGER_CONFIG\n:\n\n    \nsecurity_manager\n:\n \nyosai\n.\ncore\n.\nNativeSecurityManager\n\n    \nattributes\n:\n\n        \nserializer\n:\n \ncbor\n\n        \nrealms\n:\n\n            \nyosai\n.\ncore\n.\nAccountStoreRealm\n:\n \nyosai_alchemystore\n.\nAlchemyAccountStore\n\n        \ncache_handler\n:\n \nyosai_dpcache\n.\ncache\n.\nDPCacheHandler\n\n        \nsession_attributes_schema\n:\n \nnull\n\n\n\nSESSION_CONFIG\n:\n\n    \nsession_timeout\n:\n\n        \nabsolute_timeout\n:\n \n1800\n\n        \nidle_timeout\n:\n \n300\n\n    \nsession_validation\n:\n\n        \nscheduler_enabled\n:\n \nfalse\n\n        \ntime_interval\n:\n \n3600\n\n\n\nWEB_REGISTRY\n:\n\n    \nsigned_cookie_secret\n:\n  \nchangeme\n\n\n\nCACHE_HANDLER\n:\n\n    \ninit_config\n:\n\n        \nbackend\n:\n \n'yosai_dpcache.redis'\n\n        \nregion_name\n:\n \n'yosai_dpcache'\n\n    \nserver_config\n:\n\n      \nredis\n:\n\n        \nurl\n:\n \n'127.0.0.1'\n\n        \nhost\n:\n \n'localhost'\n\n        \nport\n:\n \n6379\n\n        \n#\n \npassword\n:\n\n        \n#\n \ndb\n:\n\n        \n#\n \ndistributed_lock\n:\n\n        \n#\n \nsocket_timeout\n:\n\n        \n#\n \nlock_timeout\n:\n\n        \n#\n \nlock_sleep\n:\n\n        \n#\n \nredis_expiration_time\n:\n\n        \n#\n \nconnection_pool\n:\n\n    \nttl_config\n:\n\n        \nabsolute_ttl\n:\n \n3600\n\n        \ncredentials_ttl\n:\n \n300\n\n        \nauthz_info_ttl\n:\n \n1800\n\n        \nsession_absolute_ttl\n:\n \n1800\n\n\n\nALCHEMY_STORE\n:\n\n    \nengine_config\n:\n\n        \ndialect\n:\n\n        \npath\n:\n\n        \nuserid\n:\n\n        \npassword\n:\n\n        \nhostname\n:\n\n        \nport\n:\n\n        \ndb\n:\n\n\n\n\n\n\nConfiguration:  AUTHC_CONFIG\n\n\nThese are cryptographic hashing settings used to configure the \nCryptContext\n object obtained from the \nPasslib\n library.\n\n\nConfiguration:  MGT_CONFIG\n\n\nDEFAULT_CIPHER_KEY\n is a setting that contains a cipher key used by the Fernet key generator.  As you can see, a default value isn't provided and you must generate your own.  This key is used for (de)encryption during \"RememberMe\" processing. \nyosai.core.mgt.AbstractRememberMeManager\n\n\nConfiguration: SESSION_CONFIG\n\n\nA session has two timeout thresholds: idle and absolute time-to-live.  If you\nare using manual session validation, you can manage settings for it within the respective section in the config.  Time is represented in seconds.",
            "title": "Installation and Setup"
        },
        {
            "location": "/installation_setup/#installation-and-setup",
            "text": "",
            "title": "Installation and Setup"
        },
        {
            "location": "/installation_setup/#installation",
            "text": "First, install Yosai from PyPI using pip:\n     pip install yosai  Installing from PyPI, using pip, will install the project package that includes yosai.core  and  yosai.web , a default configuration, and project dependencies.",
            "title": "Installation"
        },
        {
            "location": "/installation_setup/#setup",
            "text": "Yosai is configured through a YAML-formatted settings file.  An example of\nthis configuration file can be found within the yosai.core.conf  directory\nof the Yosai project, named  yosai_settings.yaml .  When you initialize a Yosai\ninstance, you specify as an argument  either  a file_path to a configured settings\nfile or an environment variable that references the location of this file in\nthe system that will use Yosai:     #option 1 \n   yosai   =   Yosai(env_var = 'ANY_ENV_VAR_NAME_YOU_WANT' ) \n\n   #option 2 \n   yosai   =   Yosai(file_path = '/../../../whatever_filename_you_want.yaml' )",
            "title": "Setup"
        },
        {
            "location": "/installation_setup/#configuration",
            "text": "Following is a copy of the default YAML config file.  As you will see, settings\nare organized according to the services that use them:  AUTHC_CONFIG : \n     default_algorithm :   bcrypt_sha256 \n     hash_algorithms : \n         bcrypt_sha256 :   {} \n         sha256_crypt : \n             default_rounds :   110000 \n             max_rounds :   1000000 \n             min_rounds :   1000 \n             salt_size :   16  REMEMBER_ME_CONFIG : \n     default_cipher_key :   you   need   to   update   this   using   the   fernet   keygen  SECURITY_MANAGER_CONFIG : \n     security_manager :   yosai . core . NativeSecurityManager \n     attributes : \n         serializer :   cbor \n         realms : \n             yosai . core . AccountStoreRealm :   yosai_alchemystore . AlchemyAccountStore \n         cache_handler :   yosai_dpcache . cache . DPCacheHandler \n         session_attributes_schema :   null  SESSION_CONFIG : \n     session_timeout : \n         absolute_timeout :   1800 \n         idle_timeout :   300 \n     session_validation : \n         scheduler_enabled :   false \n         time_interval :   3600  WEB_REGISTRY : \n     signed_cookie_secret :    changeme  CACHE_HANDLER : \n     init_config : \n         backend :   'yosai_dpcache.redis' \n         region_name :   'yosai_dpcache' \n     server_config : \n       redis : \n         url :   '127.0.0.1' \n         host :   'localhost' \n         port :   6379 \n         #   password : \n         #   db : \n         #   distributed_lock : \n         #   socket_timeout : \n         #   lock_timeout : \n         #   lock_sleep : \n         #   redis_expiration_time : \n         #   connection_pool : \n     ttl_config : \n         absolute_ttl :   3600 \n         credentials_ttl :   300 \n         authz_info_ttl :   1800 \n         session_absolute_ttl :   1800  ALCHEMY_STORE : \n     engine_config : \n         dialect : \n         path : \n         userid : \n         password : \n         hostname : \n         port : \n         db :",
            "title": "Configuration"
        },
        {
            "location": "/installation_setup/#configuration-authc_config",
            "text": "These are cryptographic hashing settings used to configure the  CryptContext  object obtained from the  Passlib  library.",
            "title": "Configuration:  AUTHC_CONFIG"
        },
        {
            "location": "/installation_setup/#configuration-mgt_config",
            "text": "DEFAULT_CIPHER_KEY  is a setting that contains a cipher key used by the Fernet key generator.  As you can see, a default value isn't provided and you must generate your own.  This key is used for (de)encryption during \"RememberMe\" processing.  yosai.core.mgt.AbstractRememberMeManager",
            "title": "Configuration:  MGT_CONFIG"
        },
        {
            "location": "/installation_setup/#configuration-session_config",
            "text": "A session has two timeout thresholds: idle and absolute time-to-live.  If you\nare using manual session validation, you can manage settings for it within the respective section in the config.  Time is represented in seconds.",
            "title": "Configuration: SESSION_CONFIG"
        },
        {
            "location": "/quickstart/",
            "text": "Yosai:  Quick-Start\n\n\nYosai is a powerful framework that can take you far.  This Quick-Start\nguide is intended to help you get started by going through basic usage while\nnot burdening you with detail.  This is an opinionated quick-start in that it\nrequires that you use Redis for caching and a relational database for your\ndata store.\n\n\nOverview\n\n\nFollowing are the steps that you will go through to use Yosai:\n\n\n\n\nInstall\n\n\nConfigure\n\n\nInstantiate\n\n\nUse\n\n\n\n\nInstall\n\n\nFirst, install Yosai from PyPI using pip:\n\n\npip install yosai\n\n\n\n\n\nInstalling from PyPI, using pip, will install the project package that includes\n\nyosai.core\n and \nyosai.web\n, a default configuration, and project dependencies.\n\n\nConfigure\n\n\nYosai is configured through a YAML-formatted settings file.  An example of\nthis configuration file can be found within the \nyosai.core.conf directory\n\nof the Yosai project, named \nyosai_settings.yaml\n.  When you initialize a Yosai\ninstance, you specify as an argument \neither\n a file_path to a configured settings\nfile or an environment variable (env_var) that references the location of this file in\nthe system that will use Yosai:\n\n\n  \n#option 1\n\n  \nyosai\n \n=\n \nYosai(env_var\n=\n'ANY_ENV_VAR_NAME_YOU_WANT'\n)\n\n\n  \n#option 2\n\n  \nyosai\n \n=\n \nYosai(file_path\n=\n'/../../../whatever_filename_you_want.yaml'\n)\n\n\n\n\n\n\nCaching\n\n\nYosai has full support for caching.  Caching is enabled by default and ought to be used.\n\n\nThere's a Yosai extension library, \nyosai_dpcache\n, that is a\nfork of Mike Bayer's popular \"dogpile\" projects -- core and cache -- but\ncustomized for Yosai's serialization preferences.  Currently, \nyosai_dpcache\n\nsupports Redis.  Pull requests to support other cache stores are welcome.\n\n\nInstall yosai_dpcache from PyPI using pip:\n\n\npip install yosai_dpcache\n\n\n\n\n\nyosai_dpcache\n can be configured either through the main Yosai settings file or by\nmanually passing in settings arguments to a DPCacheHandler class.  For QuickStart\ndemonstration purposes, we'll use the settings file, including the following\nfor a local redis server:\n\n\nCACHE_HANDLER:\n    init_config:\n        backend: \n'yosai_dpcache.redis'\n\n        region_name: \n'yosai_dpcache'\n\n    server_config:\n      redis:\n        url: \n'127.0.0.1'\n\n        host: \n'localhost'\n\n        port: 6379\n\n\n\n\n\nPersistence\n\n\nYou have to register a persistent data store, such as a database, that Yosai\nwill request user credentials and authorization information from.  A fully\noperational relational data store has been created for you to help you get\nstarted:  \nyosai_alchemystore\n.  \nyosai_alchemystore\n uses the SQLAlchemy ORM\nto interface with an underlying relational database.  \n\n\nInstall yosai_alchemystore from PyPI using pip:\n\n\npip install yosai_alchemystore\n\n\n\n\n\nJust as with \nyosai_dpcache\n, \nyosai_alchemystore\n is configured either using\na settings file or by instantiating an instance with a settings\nargument. For QuickStart purposes, we'll use the settings file.\n\n\nThe settings file requires that ALCHEMY_STORE settings be set, if you\nwould like to use the \nyosai_alchemystore\n.  Here is what those settings look\nlike for a sqlite database located with \ntheuser\n's home directory.\n\n\nALCHEMY_STORE:\n    engine_config:\n        dialect: sqlite\n        path: ////home/theuser/yosai_accounts.db\n\n\n\n\n\nThere is a python script within the yosai_alchemystore repo, \ncreate_populate_db.py\n, that populates test data within a sqlite database.  \n\n\nInstantiate a Yosai instance\n\n\nAltogether, here is how you QuickStart instantiate an instance of Yosai:\n\n\n1) Install yosai, yosai_alchemystore, and yosai_dpcache from pypi:  \n\n\npip install yosai yosai_alchemystore yosai_dpcache\n\n\n\n\n\n2) Declare an environment variable, in this case \nYOSAI_SETTINGS\n, and assign\nit to the location of the yaml settings file in your filesystem, such as:\n\n\nexport\n \nYOSAI_SETTINGS\n=\n/home/theuser/yosai_settings.yaml\n\n\n\n\n\n3) Edit the yosai_settings.yaml file, updating settings for \nALCHEMY_STORE\n and \nCACHE_HANDLER\n\n\n4) Instantiate a yosai instance:\n\n\nfrom\n \nyosai.core\n \nimport\n \nYosai\n\n\n\nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n\n\n\n\nQuick-Starting Yosai Web\n\n\nThe \nyosai\n project features a \nyosai.core\n package and \nyosai.web\n\nintegration library.\n\n\nIf you're using Yosai for web application development, use the \nyosai.web\n\nlibrary to instantiate Yosai.  \nyosai.web\n is a derivative of \nyosai.core\n,\nextended to support interactions with web request/response objects.\n\n\nIn the Instantiation step above, we create a core Yosai instance.  We could have\ninstantiated a web-enabled WebYosai instance by making a small change to the\nyosai_settings.yaml file, changing the security_manager configuration from\n\n\nSECURITY_MANAGER_CONFIG:\n    security_manager: yosai.core.NativeSecurityManager\n\n\n\n\n\nto\n\n\nSECURITY_MANAGER_CONFIG:\n    security_manager: yosai.core.WebSecurityManager\n\n\n\n\n\nand then instantiating as follows:\n\n\nfrom\n \nyosai.web\n \nimport\n \nWebYosai\n\n\n\nyosai\n \n=\n \nWebYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n\n\n\n\nUse\n\n\nThe following example was created to illustrate the myriad ways that you\ncan declare an authorization policy in an application, ranging from general\nrole-level specification to very specific \"scoped\" permissions.  The\nauthorization policy is as follows:\n\n\n\n\nEither a user with role membership \"patient\" or \"nurse\" may request a\n  refill of a medical prescription\n\n\nA user who is granted permission to write prescriptions may obtain the\n  list of pending prescription refill requests\n\n\nA user who is granted permission to write prescriptions for a specific\n  patient may issue a prescription for that patient\n\n\n\n\nfrom\n \nyosai.core\n \nimport\n \nYosai\n\n\n\n@Yosai.requires_role\n(roleid_s\n=\n[\n'patient'\n,\n \n'nurse'\n],\n \nlogical_operator\n=\nany)\n\n\ndef\n \nrequest_prescription_refill\n(patient,\n \nprescription):\n\n    \n...\n\n\n\n\n@Yosai.requires_permission\n([\n'prescription:write'\n])\n\n\ndef\n \nget_prescription_refill_requests\n(patient):\n\n    \n...\n\n\n\n\n@Yosai.requires_dynamic_permission\n([\n'prescription:write:{patient.patient_id}'\n])\n\n\ndef\n \nissue_prescription\n(patient,\n \nprescription):\n\n    \n...\n\n\n\n\n\n\nNote how the authorization policy is declared using authorization-specific\ndecorators.  These decorators are associated with the yosai instance\npassed into the context where decorated functions/methods are called:\n\n\nwith\n \nYosai\n.\ncontext(yosai):\n\n    \nfor\n \nprescription\n \nin\n \nget_prescription_refill_requests(patient):\n\n        \nissue_prescription(patient,\n \nprescription)\n\n\n\n\n\n\nIf you were using Yosai with a web application, a context-management approach\nis used again but different types of objects are passed into context, specifically a\n\nWebYosai\n instance and a \nWebRegistry\n instance:\n\n\nwith\n \nWebYosai\n.\ncontext(yosai,\n \nweb_registry):\n\n   \n# handle web request here",
            "title": "Quick-Start"
        },
        {
            "location": "/quickstart/#yosai-quick-start",
            "text": "Yosai is a powerful framework that can take you far.  This Quick-Start\nguide is intended to help you get started by going through basic usage while\nnot burdening you with detail.  This is an opinionated quick-start in that it\nrequires that you use Redis for caching and a relational database for your\ndata store.",
            "title": "Yosai:  Quick-Start"
        },
        {
            "location": "/quickstart/#overview",
            "text": "Following are the steps that you will go through to use Yosai:   Install  Configure  Instantiate  Use",
            "title": "Overview"
        },
        {
            "location": "/quickstart/#install",
            "text": "First, install Yosai from PyPI using pip:  pip install yosai  Installing from PyPI, using pip, will install the project package that includes yosai.core  and  yosai.web , a default configuration, and project dependencies.",
            "title": "Install"
        },
        {
            "location": "/quickstart/#configure",
            "text": "Yosai is configured through a YAML-formatted settings file.  An example of\nthis configuration file can be found within the  yosai.core.conf directory \nof the Yosai project, named  yosai_settings.yaml .  When you initialize a Yosai\ninstance, you specify as an argument  either  a file_path to a configured settings\nfile or an environment variable (env_var) that references the location of this file in\nthe system that will use Yosai:     #option 1 \n   yosai   =   Yosai(env_var = 'ANY_ENV_VAR_NAME_YOU_WANT' ) \n\n   #option 2 \n   yosai   =   Yosai(file_path = '/../../../whatever_filename_you_want.yaml' )",
            "title": "Configure"
        },
        {
            "location": "/quickstart/#caching",
            "text": "Yosai has full support for caching.  Caching is enabled by default and ought to be used.  There's a Yosai extension library,  yosai_dpcache , that is a\nfork of Mike Bayer's popular \"dogpile\" projects -- core and cache -- but\ncustomized for Yosai's serialization preferences.  Currently,  yosai_dpcache \nsupports Redis.  Pull requests to support other cache stores are welcome.  Install yosai_dpcache from PyPI using pip:  pip install yosai_dpcache  yosai_dpcache  can be configured either through the main Yosai settings file or by\nmanually passing in settings arguments to a DPCacheHandler class.  For QuickStart\ndemonstration purposes, we'll use the settings file, including the following\nfor a local redis server:  CACHE_HANDLER:\n    init_config:\n        backend:  'yosai_dpcache.redis' \n        region_name:  'yosai_dpcache' \n    server_config:\n      redis:\n        url:  '127.0.0.1' \n        host:  'localhost' \n        port: 6379",
            "title": "Caching"
        },
        {
            "location": "/quickstart/#persistence",
            "text": "You have to register a persistent data store, such as a database, that Yosai\nwill request user credentials and authorization information from.  A fully\noperational relational data store has been created for you to help you get\nstarted:   yosai_alchemystore .   yosai_alchemystore  uses the SQLAlchemy ORM\nto interface with an underlying relational database.    Install yosai_alchemystore from PyPI using pip:  pip install yosai_alchemystore  Just as with  yosai_dpcache ,  yosai_alchemystore  is configured either using\na settings file or by instantiating an instance with a settings\nargument. For QuickStart purposes, we'll use the settings file.  The settings file requires that ALCHEMY_STORE settings be set, if you\nwould like to use the  yosai_alchemystore .  Here is what those settings look\nlike for a sqlite database located with  theuser 's home directory.  ALCHEMY_STORE:\n    engine_config:\n        dialect: sqlite\n        path: ////home/theuser/yosai_accounts.db  There is a python script within the yosai_alchemystore repo,  create_populate_db.py , that populates test data within a sqlite database.",
            "title": "Persistence"
        },
        {
            "location": "/quickstart/#instantiate-a-yosai-instance",
            "text": "Altogether, here is how you QuickStart instantiate an instance of Yosai:  1) Install yosai, yosai_alchemystore, and yosai_dpcache from pypi:    pip install yosai yosai_alchemystore yosai_dpcache  2) Declare an environment variable, in this case  YOSAI_SETTINGS , and assign\nit to the location of the yaml settings file in your filesystem, such as:  export   YOSAI_SETTINGS = /home/theuser/yosai_settings.yaml  3) Edit the yosai_settings.yaml file, updating settings for  ALCHEMY_STORE  and  CACHE_HANDLER  4) Instantiate a yosai instance:  from   yosai.core   import   Yosai  yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' )",
            "title": "Instantiate a Yosai instance"
        },
        {
            "location": "/quickstart/#quick-starting-yosai-web",
            "text": "The  yosai  project features a  yosai.core  package and  yosai.web \nintegration library.  If you're using Yosai for web application development, use the  yosai.web \nlibrary to instantiate Yosai.   yosai.web  is a derivative of  yosai.core ,\nextended to support interactions with web request/response objects.  In the Instantiation step above, we create a core Yosai instance.  We could have\ninstantiated a web-enabled WebYosai instance by making a small change to the\nyosai_settings.yaml file, changing the security_manager configuration from  SECURITY_MANAGER_CONFIG:\n    security_manager: yosai.core.NativeSecurityManager  to  SECURITY_MANAGER_CONFIG:\n    security_manager: yosai.core.WebSecurityManager  and then instantiating as follows:  from   yosai.web   import   WebYosai  yosai   =   WebYosai(env_var = 'YOSAI_SETTINGS' )",
            "title": "Quick-Starting Yosai Web"
        },
        {
            "location": "/quickstart/#use",
            "text": "The following example was created to illustrate the myriad ways that you\ncan declare an authorization policy in an application, ranging from general\nrole-level specification to very specific \"scoped\" permissions.  The\nauthorization policy is as follows:   Either a user with role membership \"patient\" or \"nurse\" may request a\n  refill of a medical prescription  A user who is granted permission to write prescriptions may obtain the\n  list of pending prescription refill requests  A user who is granted permission to write prescriptions for a specific\n  patient may issue a prescription for that patient   from   yosai.core   import   Yosai  @Yosai.requires_role (roleid_s = [ 'patient' ,   'nurse' ],   logical_operator = any)  def   request_prescription_refill (patient,   prescription): \n     ...  @Yosai.requires_permission ([ 'prescription:write' ])  def   get_prescription_refill_requests (patient): \n     ...  @Yosai.requires_dynamic_permission ([ 'prescription:write:{patient.patient_id}' ])  def   issue_prescription (patient,   prescription): \n     ...   Note how the authorization policy is declared using authorization-specific\ndecorators.  These decorators are associated with the yosai instance\npassed into the context where decorated functions/methods are called:  with   Yosai . context(yosai): \n     for   prescription   in   get_prescription_refill_requests(patient): \n         issue_prescription(patient,   prescription)   If you were using Yosai with a web application, a context-management approach\nis used again but different types of objects are passed into context, specifically a WebYosai  instance and a  WebRegistry  instance:  with   WebYosai . context(yosai,   web_registry): \n    # handle web request here",
            "title": "Use"
        },
        {
            "location": "/authentication/",
            "text": "Authentication\n\n\n\n\nAn application bases much of its security on knowing who a user of the system is. Authentication is the process of verifying identity, proving that a subject is who \nit\n claims to be.\n\n\nNative vs Web Yosai APIs\n\n\nIn the examples below, you will see use of the Yosai API, such as \n@Yosai.requires_user\n.\nYou use the \nYosai\n API to secure non-web applications.  When you are working\nwith web applications, use the \nWebYosai\n API instead.\n\n\nPowerful Authentication using a Simple API\n\n\nMost of your interactions with Yosai are based on the currently executing user,\ncalled a \nSubject\n.  You can easily obtain a handle on your subject instance\nwithin the \"Yosai context\" of your call stack by invoking the \nYosai.get_current_subject()\n\nstaticmethod.  \nYosai.get_current_subject()\n references a thread-local stack\nthat is pushed/popped as context is entered and exited:\n\n\nfrom\n \nyosai\n \nimport\n \nYosai,\n \nUsernamePasswordToken\n\n\n\nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n\nwith\n \nYosai\n.\ncontext(yosai):\n\n  \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n\n\n\n\n\nLogging-In and Logging-Out\n\n\nLogging-In\n\n\nWhen you \nlog-in\n, you are attempting to make a secured system recognize your\npresence.  The system recognizes who you are by verifying your identity.  Once your\nidentity is verified, the system considers you present (logged in) by creating a new,\nverified session for you.  \n\n\nThere are two key processes involved with logging-in:\n- Session Management\n- Authentication\n\n\nSession Management\n\n\nLogging-in consists of authentication followed by instantiation of a new session,\nremoving a guest session that was created for you earlier.\n\n\nAs you first interact with a system secured with Yosai, Yosai recognizes you as\na \nguest\n.  A guest is granted an anonymous session (a new one is created) during\nthe guest's first interaction with the system.  Once authenticated, you are\ngranted elevated access to the system: your status in the system changes\nfrom when you were anonymous.  The elevation of status involves deleting the anonymous\nsession and creating a new, \nverified\n session for you. Once authenticated, you\nare considered present through the existence of this \nverified\n session.\n\n\nAuthentication, with Example\n\n\nAuthentication\n is the process of verifying identity.  \n\n\nIn the following example, we log-in a Subject by performing password-based\nauthentication.  This process would raise an AuthenticationException\nif it were to fail.  Yosai features a rich exception hierarchy that offers detailed\nexplanations as to why a login failed. This exception hierarchy helps developers\ndiagnose bugs or customer service issues related to authentication.\n\n\nWhen a developer wishes to authenticate a user using a password-based approach,\nthe first step requires instantiation of an \nAuthenticationToken\n object.  The\n\nUsernamePasswordToken\n is one such kind of token and is used for password-based\nauthentication. A \nUsernamePasswordToken\n is passed identifying attributes\n(username) and credentials (password).\n\n\nfrom\n \nyosai.core\n \nimport\n \nYosai,\n \nUsernamePasswordToken\n\n\n\nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n\nwith\n \nYosai\n.\ncontext(yosai):\n\n    \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n\n    \nauthc_token\n \n=\n \nUsernamePasswordToken(username\n=\n'thedude'\n,\n\n                                        \ncredentials\n=\n'letsgobowling'\n)\n\n\n    \ntry\n:\n\n        \nsubject\n.\nlogin(authc_token)\n\n    \nexcept\n \nUnknownAccountException:\n\n        \n# insert here\n\n    \nexcept\n \nIncorrectCredentialsException:\n\n        \n# insert here\n\n    \nexcept\n \nLockedAccountException:\n\n        \n# insert here\n\n    \nexcept\n \nExcessiveAttemptsException:\n\n        \n# insert here\n\n    \nexcept\n \nAuthenticationException:\n\n        \n# insert here\n\n\n\n\n\n\nAs you can see, authentication entails a single method call: \nsubject.login(authc_token)\n. The Subject API requires a single method call to authenticate, regardless of the underlying authentication strategy chosen.\n\n\nCryptographic Hashing of Passwords\n\n\nFor password-based authentication, Yosai uses the Passlib library for cryptographic\nhashing and password verification.\n\n\nThe default hashing scheme chosen for Yosai is \nbcrypt_sha256\n. As per Passlib\ndocumentation [1], the \nbcrypt_sha256\n algorithm works as follows:\n\n\n\n\nFirst, the password is encoded to UTF-8 if not already encoded.\n\n\nThen, the UTF-8 encoded password is run through SHA2-256, generating a 32-byte digest\n\n\n\n\nThe 32-byte digest is encoded using base64, resulting in a 44-byte result\n  (including the trailing padding '='):\n      For the example \"password\", the output from this stage would be:\n        \"XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=\".\n\n\n\n\n\n\nFinally, the base64 string is passed on to the underlying bcrypt algorithm\n  as the new password to be hashed.\n\n\n\n\n\n\nFor more information about Passlib's bcrypt_sha256, you may \naccess its documentation here\n\n\nLogging Out\n\n\nWhen you \nlog-out\n, the system no longer recognizes your presence nor will it\nhonor any prior recognition of your identity (you would have to re-authenticate\nyourself if you re-engaged the system). When you log-out a user, you are\nreleasing the identifying state of the user by the application.  A Subject is\nlogged out when the Subject is done interacting with the application by calling:\n\n\nsubject.logout()\n, relinquishing all identifying information and\ninvalidating the user's session.  If you are logging out in a web app,\nthe RememberMe cookie will also be deleted.\n\n\nAutomatic Log Out\n\n\nAutomatic log out happens at session expiration.  Yosai expires sessions in two\nways: idle timeout and absolute time to live timeout.  Please consult the\nSession Management documentation to learn more about timeouts.\n\n\nManual Log Out\n\n\nWhen you manually log-out, you are explicitly telling the system that your work\nis done and you do no wish to continue your current session with the system.\n\nManual log-out is initiated by a user engaging a log-out operation through a user\ninterface, such as click a \"log-out\" or \"sign out\" button, which would ultimately\ncall the \nlogout\n method in the Subject API:\n\n\nfrom\n \nyosai.core\n \nimport\n \nUsernamePasswordToken,\n \nYosai\n\n\n\nwith\n \nYosai\n.\ncontext(yosai):\n\n    \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n    \nsubject\n.\nlogout()\n\n\n\n\n\n\nFactors of Authentication\n\n\nAuthentication methodologies involve three factors:\n\n\n\n\nsomething the user \nknows\n\n\nsomething the user \nhas\n\n\nsomething the user \nis\n\n\n\n\nAuthentication methods that depend on more than one factor, known as multi-factor\nauthentication (MFA) methods, are considered stronger fraud deterrents than single-factor\n methods as they are more difficult to compromise.  A bank ATM transaction involves\nMFA because it requires something the user \nhas\n -- a bank card -- \nand\n it\nrequires something the user \nknows\n -- a PIN code.\n\n\nThe use of a username/password to login is considered single-factor\nauthentication because it only involves something the user \nknows\n.\n\n\nYosai is designed to accommodate multi-factor authentication methods.  Be that\nas it may, no concrete MFA implementation is provided within the core library\nbecause the MFA chosen is discretionary and largely subject to change among\nprojects.  Instead, the Yosai community is encouraged to share extensions to\nenable MFA.\n\n\nHowever, although no multi-factor solution is provided, a single-factor,\npassword-based authentication is provided in yosai.core because it remains the\nmost widely used form of authentication.  You could see an example of it in the\nlogging-in documentation above.\n\n\nNative Support for 'Remember Me' Services\n\n\nAs shown in the example above, Yosai supports \"Remember Me\" in addition to\nthe normal login process.  Yosai makes a very precise distinction between a\nremembered Subject and an actual authenticated Subject:\n\n\nRemembered\n\n\nA remembered Subject is not anonymous and has a known identity (i.e. subject.identifiers is non-empty). However, this identity is remembered from a previous authentication during a previous session. A subject is considered remembered if subject.is_remembered returns True.\n\n\nAuthenticated\n\n\nAn authenticated Subject is one that has been successfully\nauthenticated (i.e. the login method was called without any exception raised)\nduring the Subject's current session. A subject is considered authenticated\nif subject.authenticated returns True.\n\n\nMutually Exclusive\n\n\nRemembered and authenticated states are mutually exclusive --  a True value\nfor one indicates a False value for the other and vice versa.\n\n\nWhy the Distinction?\n\n\nThe word 'authentication' has a very strong connotation of proof. That is,\nthere is an expected guarantee that the Subject has proven that it is who it\nclaims to be.\n\n\nWhen a user is merely remembered by a previous interaction with the application,\nthe state of proof no longer exists.  The remembered identity gives the system\nan idea who that user \nprobably\n is, yet the system has no guarantees that the remembered Subject represents an expected user. Once the subject is authenticated, the user is no longer considered only remembered because its identity would have been verified during the current session.\n\n\nSo although many parts of the application can still perform user-specific logic\nbased on the remembered identifiers, such as customized views, it should\ntypically never perform highly-sensitive operations until the user has\nlegitimately verified its identity by executing a successful authentication\nattempt.\n\n\nFor example, a check whether a Subject can access financial information should\nalmost always depend on subject.authenticated rather than subject.is_remembered to guarantee an expected and verified identity.\n\n\nRemember-Me Example\n\n\nThe following is a fairly common scenario that helps illustrate why the the\ndistinction between remembered and authenticated is important.\n\n\nLet's say you're using Amazon.com. You've logged-in successfully and have added\na few books to your shopping cart. But you have to run off to a meeting, but\nforget to log out. By the time the meeting is over, it's time to go home and\nyou leave the office.\n\n\nThe next day when you come in to work, you realize you didn't complete your\npurchase, so you go back to amazon.com. This time, Amazon 'remembers' who you\nare, greets you by name, and still gives you some personalized book\nrecommendations. To Amazon, subject.is_remembered would return True.\n\n\nBut, what happens if you try to access your account to update your credit card\ninformation to make your book purchase? While Amazon 'remembers' you\n(is_remembered is True), it cannot guarantee that you are in fact you (for\nexample, maybe a co-worker is using your computer).\n\n\nSo before you can perform a sensitive action like updating credit card\ninformation, Amazon will force you to login so that they can guarantee your\nidentity. After you login, your identity has been verified and to Amazon,\nsubject.authenticated would now be True.\n\n\nThis scenario happens so frequently for many types of applications, so the\nfunctionality is built in to Yosai so that you may leverage it for your own\napplication. Now, whether you use subject.is_remembered or subject.authenticated to customize your views and workflows is up to you, but Yosai will maintain this\nfundamental state in case you need it.\n\n\nAuthentication Events\n\n\nAn Event is emitted to the singleton EventBus when the results of\nauthentication are obtained, indicating whether authentication succeeded or\nfailed (without compromising credentials).  If you would like to learn more\nabout Event processing, please refer to the documentation about Event\nProcessing.\n\n\nEvents are communicated using a publish-subscribe paradigm.  In the case of\nAuthentication, the \nDefaultAuthenticator\n publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).\n\n\nThe following table lists the Authentication-related events and subscriber(s):\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nAUTHENTICATION.SUCCEEDED\n\n\nMRA, EL\n\n\n\n\n\n\nAUTHENTICATION.FAILED\n\n\nEL\n\n\n\n\n\n\n\n\n\n\nMRA = \nyosai.core.authz.authz.ModularRealmAuthorizer\n\n\nEL = \nyosai.core.event.event.EventLogger\n\n\n\n\nReferences\n\n\nOWASP Authentication Cheat Sheet",
            "title": "Authentication"
        },
        {
            "location": "/authentication/#authentication",
            "text": "An application bases much of its security on knowing who a user of the system is. Authentication is the process of verifying identity, proving that a subject is who  it  claims to be.",
            "title": "Authentication"
        },
        {
            "location": "/authentication/#native-vs-web-yosai-apis",
            "text": "In the examples below, you will see use of the Yosai API, such as  @Yosai.requires_user .\nYou use the  Yosai  API to secure non-web applications.  When you are working\nwith web applications, use the  WebYosai  API instead.",
            "title": "Native vs Web Yosai APIs"
        },
        {
            "location": "/authentication/#powerful-authentication-using-a-simple-api",
            "text": "Most of your interactions with Yosai are based on the currently executing user,\ncalled a  Subject .  You can easily obtain a handle on your subject instance\nwithin the \"Yosai context\" of your call stack by invoking the  Yosai.get_current_subject() \nstaticmethod.   Yosai.get_current_subject()  references a thread-local stack\nthat is pushed/popped as context is entered and exited:  from   yosai   import   Yosai,   UsernamePasswordToken  yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' )  with   Yosai . context(yosai): \n   subject   =   Yosai . get_current_subject()",
            "title": "Powerful Authentication using a Simple API"
        },
        {
            "location": "/authentication/#logging-in-and-logging-out",
            "text": "",
            "title": "Logging-In and Logging-Out"
        },
        {
            "location": "/authentication/#logging-in",
            "text": "When you  log-in , you are attempting to make a secured system recognize your\npresence.  The system recognizes who you are by verifying your identity.  Once your\nidentity is verified, the system considers you present (logged in) by creating a new,\nverified session for you.    There are two key processes involved with logging-in:\n- Session Management\n- Authentication",
            "title": "Logging-In"
        },
        {
            "location": "/authentication/#session-management",
            "text": "Logging-in consists of authentication followed by instantiation of a new session,\nremoving a guest session that was created for you earlier.  As you first interact with a system secured with Yosai, Yosai recognizes you as\na  guest .  A guest is granted an anonymous session (a new one is created) during\nthe guest's first interaction with the system.  Once authenticated, you are\ngranted elevated access to the system: your status in the system changes\nfrom when you were anonymous.  The elevation of status involves deleting the anonymous\nsession and creating a new,  verified  session for you. Once authenticated, you\nare considered present through the existence of this  verified  session.",
            "title": "Session Management"
        },
        {
            "location": "/authentication/#authentication-with-example",
            "text": "Authentication  is the process of verifying identity.    In the following example, we log-in a Subject by performing password-based\nauthentication.  This process would raise an AuthenticationException\nif it were to fail.  Yosai features a rich exception hierarchy that offers detailed\nexplanations as to why a login failed. This exception hierarchy helps developers\ndiagnose bugs or customer service issues related to authentication.  When a developer wishes to authenticate a user using a password-based approach,\nthe first step requires instantiation of an  AuthenticationToken  object.  The UsernamePasswordToken  is one such kind of token and is used for password-based\nauthentication. A  UsernamePasswordToken  is passed identifying attributes\n(username) and credentials (password).  from   yosai.core   import   Yosai,   UsernamePasswordToken  yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' )  with   Yosai . context(yosai): \n     subject   =   Yosai . get_current_subject() \n\n     authc_token   =   UsernamePasswordToken(username = 'thedude' , \n                                         credentials = 'letsgobowling' ) \n\n     try : \n         subject . login(authc_token) \n     except   UnknownAccountException: \n         # insert here \n     except   IncorrectCredentialsException: \n         # insert here \n     except   LockedAccountException: \n         # insert here \n     except   ExcessiveAttemptsException: \n         # insert here \n     except   AuthenticationException: \n         # insert here   As you can see, authentication entails a single method call:  subject.login(authc_token) . The Subject API requires a single method call to authenticate, regardless of the underlying authentication strategy chosen.",
            "title": "Authentication, with Example"
        },
        {
            "location": "/authentication/#cryptographic-hashing-of-passwords",
            "text": "For password-based authentication, Yosai uses the Passlib library for cryptographic\nhashing and password verification.  The default hashing scheme chosen for Yosai is  bcrypt_sha256 . As per Passlib\ndocumentation [1], the  bcrypt_sha256  algorithm works as follows:   First, the password is encoded to UTF-8 if not already encoded.  Then, the UTF-8 encoded password is run through SHA2-256, generating a 32-byte digest   The 32-byte digest is encoded using base64, resulting in a 44-byte result\n  (including the trailing padding '='):\n      For the example \"password\", the output from this stage would be:\n        \"XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=\".    Finally, the base64 string is passed on to the underlying bcrypt algorithm\n  as the new password to be hashed.    For more information about Passlib's bcrypt_sha256, you may  access its documentation here",
            "title": "Cryptographic Hashing of Passwords"
        },
        {
            "location": "/authentication/#logging-out",
            "text": "When you  log-out , the system no longer recognizes your presence nor will it\nhonor any prior recognition of your identity (you would have to re-authenticate\nyourself if you re-engaged the system). When you log-out a user, you are\nreleasing the identifying state of the user by the application.  A Subject is\nlogged out when the Subject is done interacting with the application by calling:  subject.logout() , relinquishing all identifying information and\ninvalidating the user's session.  If you are logging out in a web app,\nthe RememberMe cookie will also be deleted.",
            "title": "Logging Out"
        },
        {
            "location": "/authentication/#automatic-log-out",
            "text": "Automatic log out happens at session expiration.  Yosai expires sessions in two\nways: idle timeout and absolute time to live timeout.  Please consult the\nSession Management documentation to learn more about timeouts.",
            "title": "Automatic Log Out"
        },
        {
            "location": "/authentication/#manual-log-out",
            "text": "When you manually log-out, you are explicitly telling the system that your work\nis done and you do no wish to continue your current session with the system. \nManual log-out is initiated by a user engaging a log-out operation through a user\ninterface, such as click a \"log-out\" or \"sign out\" button, which would ultimately\ncall the  logout  method in the Subject API:  from   yosai.core   import   UsernamePasswordToken,   Yosai  with   Yosai . context(yosai): \n     subject   =   Yosai . get_current_subject() \n     subject . logout()",
            "title": "Manual Log Out"
        },
        {
            "location": "/authentication/#factors-of-authentication",
            "text": "Authentication methodologies involve three factors:   something the user  knows  something the user  has  something the user  is   Authentication methods that depend on more than one factor, known as multi-factor\nauthentication (MFA) methods, are considered stronger fraud deterrents than single-factor\n methods as they are more difficult to compromise.  A bank ATM transaction involves\nMFA because it requires something the user  has  -- a bank card --  and  it\nrequires something the user  knows  -- a PIN code.  The use of a username/password to login is considered single-factor\nauthentication because it only involves something the user  knows .  Yosai is designed to accommodate multi-factor authentication methods.  Be that\nas it may, no concrete MFA implementation is provided within the core library\nbecause the MFA chosen is discretionary and largely subject to change among\nprojects.  Instead, the Yosai community is encouraged to share extensions to\nenable MFA.  However, although no multi-factor solution is provided, a single-factor,\npassword-based authentication is provided in yosai.core because it remains the\nmost widely used form of authentication.  You could see an example of it in the\nlogging-in documentation above.",
            "title": "Factors of Authentication"
        },
        {
            "location": "/authentication/#native-support-for-remember-me-services",
            "text": "As shown in the example above, Yosai supports \"Remember Me\" in addition to\nthe normal login process.  Yosai makes a very precise distinction between a\nremembered Subject and an actual authenticated Subject:",
            "title": "Native Support for 'Remember Me' Services"
        },
        {
            "location": "/authentication/#remembered",
            "text": "A remembered Subject is not anonymous and has a known identity (i.e. subject.identifiers is non-empty). However, this identity is remembered from a previous authentication during a previous session. A subject is considered remembered if subject.is_remembered returns True.",
            "title": "Remembered"
        },
        {
            "location": "/authentication/#authenticated",
            "text": "An authenticated Subject is one that has been successfully\nauthenticated (i.e. the login method was called without any exception raised)\nduring the Subject's current session. A subject is considered authenticated\nif subject.authenticated returns True.",
            "title": "Authenticated"
        },
        {
            "location": "/authentication/#mutually-exclusive",
            "text": "Remembered and authenticated states are mutually exclusive --  a True value\nfor one indicates a False value for the other and vice versa.",
            "title": "Mutually Exclusive"
        },
        {
            "location": "/authentication/#why-the-distinction",
            "text": "The word 'authentication' has a very strong connotation of proof. That is,\nthere is an expected guarantee that the Subject has proven that it is who it\nclaims to be.  When a user is merely remembered by a previous interaction with the application,\nthe state of proof no longer exists.  The remembered identity gives the system\nan idea who that user  probably  is, yet the system has no guarantees that the remembered Subject represents an expected user. Once the subject is authenticated, the user is no longer considered only remembered because its identity would have been verified during the current session.  So although many parts of the application can still perform user-specific logic\nbased on the remembered identifiers, such as customized views, it should\ntypically never perform highly-sensitive operations until the user has\nlegitimately verified its identity by executing a successful authentication\nattempt.  For example, a check whether a Subject can access financial information should\nalmost always depend on subject.authenticated rather than subject.is_remembered to guarantee an expected and verified identity.",
            "title": "Why the Distinction?"
        },
        {
            "location": "/authentication/#remember-me-example",
            "text": "The following is a fairly common scenario that helps illustrate why the the\ndistinction between remembered and authenticated is important.  Let's say you're using Amazon.com. You've logged-in successfully and have added\na few books to your shopping cart. But you have to run off to a meeting, but\nforget to log out. By the time the meeting is over, it's time to go home and\nyou leave the office.  The next day when you come in to work, you realize you didn't complete your\npurchase, so you go back to amazon.com. This time, Amazon 'remembers' who you\nare, greets you by name, and still gives you some personalized book\nrecommendations. To Amazon, subject.is_remembered would return True.  But, what happens if you try to access your account to update your credit card\ninformation to make your book purchase? While Amazon 'remembers' you\n(is_remembered is True), it cannot guarantee that you are in fact you (for\nexample, maybe a co-worker is using your computer).  So before you can perform a sensitive action like updating credit card\ninformation, Amazon will force you to login so that they can guarantee your\nidentity. After you login, your identity has been verified and to Amazon,\nsubject.authenticated would now be True.  This scenario happens so frequently for many types of applications, so the\nfunctionality is built in to Yosai so that you may leverage it for your own\napplication. Now, whether you use subject.is_remembered or subject.authenticated to customize your views and workflows is up to you, but Yosai will maintain this\nfundamental state in case you need it.",
            "title": "Remember-Me Example"
        },
        {
            "location": "/authentication/#authentication-events",
            "text": "An Event is emitted to the singleton EventBus when the results of\nauthentication are obtained, indicating whether authentication succeeded or\nfailed (without compromising credentials).  If you would like to learn more\nabout Event processing, please refer to the documentation about Event\nProcessing.  Events are communicated using a publish-subscribe paradigm.  In the case of\nAuthentication, the  DefaultAuthenticator  publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).  The following table lists the Authentication-related events and subscriber(s):     Event Topic  Subscriber(s)      AUTHENTICATION.SUCCEEDED  MRA, EL    AUTHENTICATION.FAILED  EL      MRA =  yosai.core.authz.authz.ModularRealmAuthorizer  EL =  yosai.core.event.event.EventLogger",
            "title": "Authentication Events"
        },
        {
            "location": "/authentication/#references",
            "text": "OWASP Authentication Cheat Sheet",
            "title": "References"
        },
        {
            "location": "/authorization/",
            "text": "Authorization\n\n\n\n\nAuthorization, also known as Access Control, is concerned with the rules and\nmechanisms governing how someone or something accesses resources (in this context, within a software application). Informally speaking, authorization is concerned with \u201cwho can do what\u201d.\n\n\nRole-Based Access Control\n\n\nThere are many access control models \nin use today\n.  By default, Yosai enforces access control by evaluating roles and permissions assigned to a user.\nThese roles and permissions are derived from a Role-Based Access Control (RBAC) model. Note that although a default support for RBAC is provided, your Realm implementation ultimately decides how your permissions and roles are grouped together and whether to return a \u201cyes\u201d or a \u201cno\u201d answer to Yosai.  This feature\nallows you to architect your application in the manner you chose.\n\n\nFor more information about RBAC\n\n\nyosai.core\n obtains roles and permissions from a repository, such as a\nrelational database.  Designing and implementing the RBAC data model and its\nauthorization policy it represents are concerns beyond the scope\nof yosai.core. As mentioned earlier, Yosai can support any data model for\naccess control and doesn\u2019t force one on you.  However, a basic, flat RBAC\nmodel was implemented for Yosai, \nas an extension\n, so to facilitate other extension projects.\n\n\nKey Concepts\n\n\nThe key concepts to understand about authorization in Yosai involve these relationships:\n\n\n\n\nPermissions are \nassociated with\n roles. Users are \nassigned to\n roles.\n\n\nA \nPermission\n specifies an action performed in the system on a resource.\n\n\nA \nRole\n is a group of permissions. Organizations are known to group permissions\nby task or various job functions. Roles can be granted new permissions as new\napplications and systems are incorporated, and permissions can be revoked from\nroles as needed.\n\n\nA \nUser\n refers to a person who interfaces with the software application.\nA user is provided a user account that allows an application to uniquely\nidentify it.  User accounts are often identified by a Username/UserID\nattribute or email address.  Users are assigned roles based on the user's\nresponsibilities and qualifications. Users can be easily reassigned from one role\nto another.\n\n\nYosai obtains a user's authorization information (assigned permissions\nand role memberships) and then determines whether the user meets\nthe access required to perform an operation in an application.\n\n\nAccess Control Levels and Styles\n\n\nTwo \"levels\" of access control are available:  \nrole-level\n and \npermission-level\n.\n\n\nYosai supports \"explicit\" role-level access control.  With explicit role-level\naccess control, a developer specifies the role names that are required to gain\naccess to an operation.\n\n\nPermission-level access control is considered superior to role level.\nWith it, a developer can model authorization requirements ranging from the most\nsummary to the most detailed.\n\n\nBoth levels of access control can be performed using two styles:\n\n\n\n\n\n\nThe \ndeclarative style\n of authorization involves use of a decorator that performs one of the two levels of access control.  The wrapped method is never called if authorization fails.\n\n\n\n\n\n\nThe \nimperative style\n of authorization involves in-line access control within the operation that requires authorization.\n\n\n\n\n\n\nLevels and Styles Illustrated\n\n\nFollowing is an example of what role-level authorization looks like when using\neither style of access control.  In this example, we only allow a user to\ndelete a comment from a message board (subreddit) if the user is a moderator or\nadmin.  In other words, the user is a member of \neither\n the moderator or admin\nroles.  In reality, we would layer additional access control to the\nremove_comment method so that the creator of the post may also delete the\ncomment, but this detail is left out for simplicity's sake and only to\nhighlight role-level access control.\n\n\nNative vs Web Yosai APIs\n\n\nIn the examples below, you will see use of the Yosai API, such as \n@Yosai.requires_role\n.\nYou use the \nYosai\n API to secure non-web applications.  When you are working\nwith web applications, use the \nWebYosai\n API instead.\n\n\nDeclarative Style\n\n\n@Yosai.requires_role\n(roleid_s\n=\n[\n'moderator'\n,\n \n'admin'\n],\n \nlogical_operator\n=\nany)\n\n\ndef\n \nremove_comment\n(self,\n \nsubmission):\n\n   \nself\n.\ndatabase_handler\n.\ndelete(submission)\n\n\n\n\n\n\nImperative Style\n\n\nNote that the following example assumes that a \nyosai\n instance has already\nbeen instantiated and configured with a SecurityManager.  See the \nyosai init\n\ndocumentation for how to do that.\n\n\ndef\n \nremove_comment\n(self,\n \nyosai,\n \nsubmission):\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n\n        \ntry\n:\n\n            \nsubject\n.\ncheck_role([\n'moderator'\n,\n \n'creator'\n],\n \nlogical_operator\n=\nany)\n\n        \nexcept\n \nUnauthorizedException:\n\n            \nprint\n(\n'Cannot remove comment:  Access Denied.'')\n\n\n        \nself\n.\ndatabase_handler\n.\ndelete(submission)\n\n\n\n\n\n\n\n\nRole-level access control is inferior to permission-level access control, but since it has its niche use, is available in Yosai.  It is highly recommended that you choose permission-level access control policies for your application.\n\n\n\n\nPermissions\n\n\nA permission states what behavior can be performed in an application but not who\ncan perform them. Permissions are modeled in Yosai using a flexible design that\nallows a developer to choose an appropriate level of detail that suits the\nauthorization policy governing a software application.\n\n\nA Permission can be represented in Yosai as a \nformatted string\n or as a\n\nPermission\n object.  First, let's consider the formatted string.\n\n\n1. String-formatted Permission\n\n\nThe following string presents a permission formatted using a syntax recognized\nby Yosai.  Please do not pay attention to the actual labels used but rather the format: \n'section1:section2item1,section2item2:section3'\n\n\nThis Permission string is composed of delimited sections, one that you should notice that includes delimited sub-sections.  As you can see, the default \nsection delimiter\n is the \ncolon\n, and the sub-section delimiter is a \ncomma\n.\n\n\nA developer can control what the sections (or 'parts') of a permission represent. However, a default implementation of a Permission is provided in Yosai and it is formatted as follows: \n'domain:action:instance'\n\n\n2. Permission object instance\n\n\nA \nDefaultPermission\n is expressed in Yosai as a \ncombination\n of resource type (domain), the action(s) that is acted upon that resource type, and instance(s) of that resource type. This three-section format suits many permission modeling requirements. However, should a developer have more complicated requirements, Permissions can be modeled in even more complicated manner.  For example, suppose you wish to set boundaries on a permission by contextualizing when a permission is granted. A permission can be bound to a particular context, also known as 'scoping', granting permission to perform an operation only under certain circumstances: \n'context:domain:action:target'\n\n\nPermission Modeling\n\n\nFollowing are a few examples of what a Permission string looks like.  We'll base these examples on Reddit \nmoderator permissioning\n, with liberties taken to their modeling so as to make it relevant for these examples.  If you are unfamiliar with the role of moderator, please \nvisit this site\n.\n\n\nModerators have management oversight of 'subreddit' message forums.\nTheir responsibilities provide them with controls to manage submissions and\ncomments (collectively, \"items\").  We'll use a few of these controls for\nour examples:\n\n\nPermission:  \"remove items\"\n\n\nThis seems straightforward, right?  A moderator can remove submissions and\ncomments.  Let's consider how item-removal permissioning may be modeled.\n\n\nOne way to model this is by using two permissions, each defining an operation\non a type of resource:\n\n\n1\n)\n \n'submission:remove'\n\n2\n)\n \n'comment:remove'\n\n\n\n\n\n\nA moderator will either be assigned to a single role that includes both of these permissions or assigned to two roles where each role includes one of the above permissions.\n\n\nNote that if a moderator were to be assigned the above permissions that\nthe user would have moderator status across \nall\n of reddit.  Such power is too great and is hopefully beyond the grasp of any one individual in the production environment.  With this given, it is more likely that permission is \nscoped\n such that item removal is limited to a particular subreddit:\n\n\n1\n)\n \n'subreddit_id123:submission:remove'\n\n2\n)\n \n'subreddit_id123:comment:remove'\n\n\n\n\n\n\nWith these permissions, a user is \nauthorized\n to remove items within\nthe subreddit that the user is assigned a moderator role.\n\n\nPermission:  \"categorize items as NSFW\"\n\n\nThis permission marks items as not suitable for work environments. Let's add this new activity to the prior permission:\n\n\n1\n)\n \n'subreddit_id123:submission:remove, categorize_nsfw'\n\n2\n)\n \n'subreddit_id123:comment:remove, categorize_nsfw'\n\n\n\n\n\n\nThus far, we've defined two permissions that allow the removal of and\nlabeling of nsfw of submission and comment resource types.\n\n\nSuppose that you're a developer working for Reddit.  You receive a request to create a process for moderators to remove a message post, consisting of the submission AND the comments supporting it.  One of your team members uses the permission modeling above to provide you with a specification of the authorization that is required to remove a post:\n\n\nTo remove a post, a user must have BOTH permissions:\n\n\n1\n)\n \n'subreddit_id123:submission:remove, categorize_nsfw'\n\n2\n)\n \n'subreddit_id123:comment:remove, categorize_nsfw'\n\n\n\n\n\n\nYou Implement Your Authorization Policy, Yosai enforces it\n\n\nAccess control begins with an authorization policy.  A user is granted permissions through an authorization policy.  The policy states how a user is granted permission to perform an action on a type of resource, perhaps a specific resource instance, and potentially bounded by a particular context. A data model supporting the authorization policy is queried to obtain authorization information -- permissions and/or roles. The authorization policy, its data model, and the administrative system that manages the policy is decided by an organization and is outside the scope of Yosai's value proposition: Yosai enforces an authorization policy but does not provide one. Yosai obtains a user's permissions (or roles) from an outside source and then interprets them to determine whether a user is authorized.\n\n\nAuthorization Events\n\n\nAn Event is emitted to the singleton EventBus when the results of authorization are obtained.  The results are comprehensive:  every permission or role that is checked is included along with a Boolean indicating whether authorization was granted for it.  A summary \"granted\" or \"denied\" event is also communicated when a Boolean check-authorization is submitted to Yosai. If you would like to learn more about Event processing, please refer to the documentation about EventProcessing \nhere\n.\n\n\nEvents are communicated using a publish-subscribe paradigm.  In the case of\nAuthorization, the \nModularRealmAuthorizer\n publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).\n\n\nThe following table lists the Authorization-related events and subscriber(s):\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nAUTHORIZATION.GRANTED\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.DENIED\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.RESULTS\n\n\nEL\n\n\n\n\n\n\n\n\nEL = \nyosai.core.event.event.EventLogger\n\n\nAuthorization API Reference\n\n\nYosai provides role-level and permission-level access control.\n\n\nBoth levels of access control can be performed using two styles:\n\n\n\n\n\n\nThe \nDeclarative Style\n of authorization involves use of a decorator that performs one of the two levels of access control (role or permission).  The wrapped method is never called if authorization fails.\n\n\n\n\n\n\nThe \nImperative Style\n of authorization involves in-line access control within the operation that requires authorization.\n\n\n\n\n\n\nDeclarative-Style Authorization\n\n\nDeclarative-style authorization allows you to itemize access requirements for a function call.  There are two declarative-style \"authorizers\", one for permission-level and another for role-level access control.  An \nAuthorizationException\n is raised when a user fails to meet specified access requirements. Following is the API you may use for declarative-style\n\n\n    \n# Permission-level\n\n    \ndef\n \nrequires_permission\n(permission_s,\n \nlogical_operator\n=\nall):\n\n        \n\"\"\"\n\n\n        Requires that the calling Subject be authorized to the extent that is\n\n\n        required to satisfy the permission_s specified and the logical operation\n\n\n        upon them.\n\n\n\n        :param permission_s:   the permission(s) required\n\n\n        :type permission_s:  a List of Strings or List of Permission instances\n\n\n\n        :param logical_operator:  indicates whether all or at least one permission\n\n\n                                  is true (any, all)\n\n\n        :type: any OR all (from python standard library)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          permission\n\n\n        \"\"\"\n\n        \npass\n\n\n\n    \ndef\n \nrequires_dynamic_permission\n(permission_s,\n \nlogical_operator\n=\nall):\n\n        \n\"\"\"\n\n\n        This method requires that the calling Subject be authorized to the extent\n\n\n        that is required to satisfy the dynamic permission_s specified and the logical\n\n\n        operation upon them.  Unlike ``requires_permission``, which uses statically\n\n\n        defined permissions, this function derives a permission from arguments\n\n\n        specified at declaration.\n\n\n\n        Dynamic permissioning requires that the dynamic arguments be keyword\n\n\n        arguments of the decorated method.\n\n\n\n        :param permission_s:   the permission(s) required\n\n\n        :type permission_s:  a List of Strings or List of Permission instances\n\n\n\n        :param logical_operator:  indicates whether all or at least one permission\n\n\n                                  is true (and, any)\n\n\n        :type: and OR all (from python standard library)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          permission\n\n\n        \"\"\"\n\n        \npass\n\n\n    \n# Role-level\n\n    \ndef\n \nrequires_role\n(roleid_s,\n \nlogical_operator\n=\nall):\n\n        \n\"\"\"\n\n\n        Requires that the calling Subject be authorized to the extent that is\n\n\n        required to satisfy the roleid_s specified and the logical operation\n\n\n        upon them.\n\n\n\n        :param roleid_s:   a collection of the role(s) required, specified by\n\n\n                           identifiers (such as a role name)\n\n\n        :type roleid_s:  a List of Strings\n\n\n\n        :param logical_operator:  indicates whether all or at least one permission\n\n\n                                  is true (any, all)\n\n\n        :type: any OR all (from python standard library)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          role membership\n\n\n        \"\"\"\n\n        \npass\n\n\n\n\n\n\nlogical_operator\n, the second parameter of both declarative-style authorizers, can be either \nany\n or \nall\n functions from the python standard library.  Use \nany\n when you want to evaluate each item \nindependently\n of the others and \nall\n when you want to evaluate items \ncollectively\n.\n\n\nExample 1:  All Permissions are Required\n\n\nThe following permissions are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@Yosai.requires_permission\n([\n'domain1:action1'\n,\n \n'domain2:action2'\n],\n \nall)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nExample 2:  Any Permission Specified is Acceptable\n\n\nThe following permissions are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@Yosai.requires_permission\n([\n'domain1:action1'\n,\n \n'domain2:action2'\n],\n \nany)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nExample 3:  All Roles are Required\n\n\nThe following roles are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@Yosai.requires_role\n([\n'role1'\n,\n \n'role2'\n],\n \nall)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nExample 4:  Any Role Specified is Acceptable\n\n\nThe following roles are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:\n\n\n@Yosai.requires_role\n([\n'role1'\n,\n \n'role2'\n],\n \nany)\n\n\ndef\n \nthis_function\n(\n...\n):\n\n    \n...\n\n\n\n\n\n\nExample 5:  Any Permission, Specified Dynamically, is Acceptable\n\n\nThe following permissions are required, each independently satisfying the access control requirement, to call this_function.  Notice how arguments are obtaining dynamically.  If you decide to use dynamic-argument permissions, you reference the arguments using string-formatting syntax.\nDynamic arguments must be passed as keyword arguments to the decorated function.  In\nthis example, this_function must be called like this_function(kwarg1=..., kwarg2=...)\n\n\nWhen this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@Yosai.requires_dynamic_permission\n([\n'{kwarg1.domain}:action1'\n,\n\n                                  \n'{kwarg2.domain}:action2'\n],\n \nany)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nImperative-Style Authorization\n\n\nImperative-Style authorization is used when you want to control access from within your source code, step by step, with more control over the process of checking access and responding to authorization results.  It is the more \"granular\" of the two styles.\n\n\nFollowing is the API you may use for imperative-style authorization:\n\n\n# Permission-level methods:\n\n\n# -------------------------------------------------\n\n    \ndef\n \nis_permitted\n(permission_s):\n\n        \n\"\"\"\n\n\n        Determines whether any Permission(s) associated with the subject\n\n\n        implies the requested Permission(s) provided.\n\n\n\n        :param permission_s: a collection of 1..N permissions, all of the same type\n\n\n        :type permission_s: List of Permission object(s) or String(s)\n\n\n\n        :returns: a List of tuple(s), containing the authz_abcs.Permission and a\n\n\n                  Boolean indicating whether the permission is granted\n\n\n        \"\"\"\n\n        \npass\n\n\n    \ndef\n \nis_permitted_collective\n(permission_s,\n \nlogical_operator):\n\n        \n\"\"\"\n\n\n        This method determines whether the requested Permission(s) are\n\n\n        collectively granted authorization.  The Permission(s) associated with\n\n\n        the subject are evaluated to determine whether authorization is implied\n\n\n        for each Permission requested.  Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        If operator=ANY: returns True if any requested permission is implied permission\n\n\n        If operator=ALL: returns True if all requested permissions are implied permission\n\n\n        Else returns False\n\n\n\n        :param permission_s:  a List of authz_abcs.Permission objects\n\n\n\n        :param logical_operator:  indicates whether *all* or at least one\n\n\n                                  permission check is true, *any*\n\n\n        :type: any OR all (functions from python stdlib)\n\n\n\n        :returns: a Boolean\n\n\n        \"\"\"\n\n        \npass\n\n\n    \ndef\n \ncheck_permission\n(permission_s,\n \nlogical_operator):\n\n        \n\"\"\"\n\n\n        This method determines whether the requested Permission(s) are\n\n\n        collectively granted authorization.  The Permission(s) associated with\n\n\n        the subject are evaluated to determine whether authorization is implied\n\n\n        for each Permission requested.  Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        This method is similar to `is_permitted_collective` except that it\n\n\n        raises an AuthorizationException if collectively False else does not\n\n\n        return any value.\n\n\n\n        :param permission_s: a collection of 1..N permissions\n\n\n        :type permission_s: List of authz_abcs.Permission objects or Strings\n\n\n\n        :param logical_operator:  indicates whether all or at least one\n\n\n                                  permission check is true (any)\n\n\n        :type: any OR all (from python stdlib)\n\n\n\n        :raises UnauthorizedException: if any permission is unauthorized\n\n\n        \"\"\"\n\n\n\n\n# Role-level methods:\n\n\n# -------------------------------------------------\n\n    \ndef\n \nhas_role\n(roleid_s):\n\n        \n\"\"\"\n\n\n        Determines whether a Subject is a member of the Role(s) requested\n\n\n\n        :param roleid_s: 1..N role identifiers (strings)\n\n\n        :type roleid_s:  Set of Strings\n\n\n\n        :returns: a frozenset of tuple(s), each containing the Role identifier\n\n\n                  requested and a Boolean indicating whether the subject is\n\n\n                  a member of that Role\n\n\n                  - the tuple format is: (roleid, Boolean)\n\n\n        \"\"\"\n\n        \npass\n\n\n    \ndef\n \nhas_role_collective\n(roleid_s,\n \nlogical_operator):\n\n        \n\"\"\"\n\n\n        This method determines whether the Subject's role membership\n\n\n        collectively grants authorization for the roles requested.  The\n\n\n        Role(s) associated with the subject are evaluated to determine\n\n\n        whether the roles requested are sufficiently addressed by those that\n\n\n        the Subject is a member of. Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        If operator=ANY, returns True if any requested role membership is\n\n\n                         satisfied\n\n\n        If operator=ALL: returns True if all of the requested permissions are\n\n\n                         implied permission\n\n\n        Else returns False\n\n\n\n        :param roleid_s: 1..N role identifiers (strings)\n\n\n        :type roleid_s:  Set of Strings\n\n\n\n        :param logical_operator:  any or all\n\n\n        :type logical_operator:  function  (stdlib)\n\n\n\n        :rtype:  bool\n\n\n        \"\"\"\n\n        \npass\n\n\n    \ndef\n \ncheck_role\n(role_ids,\n \nlogical_operator):\n\n        \n\"\"\"\n\n\n        This method determines whether the Subject's role membership\n\n\n        collectively grants authorization for the roles requested.  The\n\n\n        Role(s) associated with the subject are evaluated to determine\n\n\n        whether the roles requested are sufficiently addressed by those that\n\n\n        the Subject is a member of. Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        This method is similar to has_role_collective except that it raises\n\n\n        an AuthorizationException if collectively False else does not return any\n\n\n\n        :param roleid_s: 1..N role identifiers (strings)\n\n\n        :type roleid_s:  Set of Strings\n\n\n\n        :param logical_operator:  any or all\n\n\n        :type logical_operator:  function  (stdlib)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          role membership\n\n\n        \"\"\"\n\n        \npass\n\n\n\n\n\n\nThe first argument of every method is a List containing \neither\n authorization object instances (\nPermission\n or \nRole\n) \nor\n String(s). Yosai does \nnot\n support a commingling of the two supported types.\n\n\nYou will notice that some of the methods in the imperative-style authorization API include a second parameter, \nlogical_operator\n.  This parameter can be one of two values: either \nany\n or \nall\n functions from the python standard library.  Use \nany\n when you want to evaluate each item \nindependently\n of the others and \nall\n when you want to evaluate items \ncollectively\n.\n\n\nNote that the following set of examples assumes that a \nyosai\n instance has already\nbeen instantiated and configured with a SecurityManager.  See the \nyosai init\n\ndocumentation for how to do that:\n\n\nExample 1:  is_permitted\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n        \nresults\n \n=\n \nsubject\n.\nis_permitted([\n'domain1:action1'\n,\n \n'domain2:action2'\n])\n\n\n        \nif\n \nany(is_permitted\n \nfor\n \npermission,\n \nis_permitted\n \nin\n \nresults):\n\n            \nprint\n(\n'any permission is granted'\n)\n\n\n        \nif\n \nall(is_permitted\n \nfor\n \npermission,\n \nis_permitted\n \nin\n \nresults):\n\n            \nprint\n(\n'all permission is granted, too!'\n)\n\n\n\n\n\n\n\n\nresults\n is a list of tuples, each containing a Permission object and a Boolean value indicating whether access is granted (True) or denied (False)\n\n\n\n\nExample 2:  is_permitted_collective\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n        \nany_result_check\n \n=\n \nsubject\n.\nis_permitted_collective([\n'domain1:action1'\n,\n\n                                                                 \n'domain2:action2'\n],\n \nany)\n\n        \nif\n \nany_result_check:\n\n            \nprint\n(\n'any permission is granted'\n)\n\n\n        \nall_result_check\n \n=\n \nsubject\n.\nis_permitted_collective([\n'domain1:action1'\n,\n\n                                                                 \n'domain2:action2'\n],\n \nall)\n\n\n        \nif\n \nall_result_check:\n\n            \nprint\n(\n'all permission is granted, too!'\n)\n\n\n\n\n\n\n\n\nany_result_check\n and \nall_result_check\n are Boolean values\n\n\n\n\nExample 3:  check_permission\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n        \ntry\n:\n\n            \nsubject\n.\ncheck_permission([\n'domain1:action1'\n,\n\n                                           \n'domain2:action2'\n],\n\n                                          \nany)\n\n        \nexcept\n \nAuthorizationException:\n\n            \nprint\n(\n'any permission denied'\n)\n\n        \nelse\n:\n\n            \nprint\n(\n'any permission granted'\n)\n\n\n        \ntry\n:\n\n            \nsubject\n.\ncheck_permission([\n'domain1:action1'\n,\n\n                                           \n'domain2:action2'\n],\n\n                                          \nall)\n\n        \nexcept\n \nAuthorizationException:\n\n            \nprint\n(\n'all permission denied'\n)\n\n        \nelse\n:\n\n            \nprint\n(\n'all permission granted'\n)\n\n\n\n\n\n\n\n\ncheck_permission\n succeeds quietly else raises an AuthorizationException\n\n\n\n\nExample 1:  has_role\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n        \nresults\n \n=\n \nsubject\n.\nhas_role([\n'role1'\n,\n \n'role2'\n])\n\n\n        \nif\n \nany(has_role\n \nfor\n \nrole,\n \nhas_role\n \nin\n \nresults):\n\n            \nprint\n(\n'any role is confirmed'\n)\n\n\n        \nif\n \nall(has_role\n \nfor\n \nrole,\n \nhas_role\n \nin\n \nresults):\n\n            \nprint\n(\n'all role is confirmed, too!'\n)\n\n\n\n\n\n\n\n\nresults\n is a list of tuples, each containing a Role and a Boolean value indicating whether role membership is confirmed (True if so)\n\n\n\n\nExample 2:  has_role_collective\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n        \nany_result_check\n \n=\n \nsubject\n.\nhas_role_collective([\n'role1'\n,\n \n'role2'\n],\n \nany)\n\n\n        \nif\n \nany_result_check:\n\n            \nprint\n(\n'any role is confirmed'\n)\n\n\n        \nall_result_check\n \n=\n \nsubject\n.\nhas_role_collective([\n'role1'\n,\n \n'role2'\n],\n \nall)\n\n\n        \nif\n \nall_result_check:\n\n            \nprint\n(\n'all role is confirmed, too!'\n)\n\n\n\n\n\n\n\n\nany_result_check\n and \nall_result_check\n are Boolean values\n\n\n\n\nExample 3:  check_role\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n        \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n        \ntry\n:\n\n            \nsubject\n.\ncheck_role([\n'role1'\n,\n \n'role2'\n],\n \nany)\n\n\n        \nexcept\n \nAuthorizationException:\n\n            \nprint\n(\n'any role denied'\n)\n\n        \nelse\n:\n\n            \nprint\n(\n'any role confirmed'\n)\n\n\n        \ntry\n:\n\n            \nsubject\n.\ncheck_role([\n'role1'\n,\n \n'role2'\n],\n \nall)\n\n\n        \nexcept\n \nAuthorizationException:\n\n            \nprint\n(\n'all role denied'\n)\n\n        \nelse\n:\n\n            \nprint\n(\n'all role confirmed'\n)\n\n\n\n\n\n\n\n\ncheck_role\n succeeds quietly else raises an AuthorizationException\n\n\n\n\nReferences\n\n\nOWASP Access Control Cheat Sheet",
            "title": "Authorization"
        },
        {
            "location": "/authorization/#authorization",
            "text": "Authorization, also known as Access Control, is concerned with the rules and\nmechanisms governing how someone or something accesses resources (in this context, within a software application). Informally speaking, authorization is concerned with \u201cwho can do what\u201d.",
            "title": "Authorization"
        },
        {
            "location": "/authorization/#role-based-access-control",
            "text": "There are many access control models  in use today .  By default, Yosai enforces access control by evaluating roles and permissions assigned to a user.\nThese roles and permissions are derived from a Role-Based Access Control (RBAC) model. Note that although a default support for RBAC is provided, your Realm implementation ultimately decides how your permissions and roles are grouped together and whether to return a \u201cyes\u201d or a \u201cno\u201d answer to Yosai.  This feature\nallows you to architect your application in the manner you chose.  For more information about RBAC  yosai.core  obtains roles and permissions from a repository, such as a\nrelational database.  Designing and implementing the RBAC data model and its\nauthorization policy it represents are concerns beyond the scope\nof yosai.core. As mentioned earlier, Yosai can support any data model for\naccess control and doesn\u2019t force one on you.  However, a basic, flat RBAC\nmodel was implemented for Yosai,  as an extension , so to facilitate other extension projects.",
            "title": "Role-Based Access Control"
        },
        {
            "location": "/authorization/#key-concepts",
            "text": "The key concepts to understand about authorization in Yosai involve these relationships:   Permissions are  associated with  roles. Users are  assigned to  roles.  A  Permission  specifies an action performed in the system on a resource.  A  Role  is a group of permissions. Organizations are known to group permissions\nby task or various job functions. Roles can be granted new permissions as new\napplications and systems are incorporated, and permissions can be revoked from\nroles as needed.  A  User  refers to a person who interfaces with the software application.\nA user is provided a user account that allows an application to uniquely\nidentify it.  User accounts are often identified by a Username/UserID\nattribute or email address.  Users are assigned roles based on the user's\nresponsibilities and qualifications. Users can be easily reassigned from one role\nto another.  Yosai obtains a user's authorization information (assigned permissions\nand role memberships) and then determines whether the user meets\nthe access required to perform an operation in an application.",
            "title": "Key Concepts"
        },
        {
            "location": "/authorization/#access-control-levels-and-styles",
            "text": "Two \"levels\" of access control are available:   role-level  and  permission-level .  Yosai supports \"explicit\" role-level access control.  With explicit role-level\naccess control, a developer specifies the role names that are required to gain\naccess to an operation.  Permission-level access control is considered superior to role level.\nWith it, a developer can model authorization requirements ranging from the most\nsummary to the most detailed.  Both levels of access control can be performed using two styles:    The  declarative style  of authorization involves use of a decorator that performs one of the two levels of access control.  The wrapped method is never called if authorization fails.    The  imperative style  of authorization involves in-line access control within the operation that requires authorization.",
            "title": "Access Control Levels and Styles"
        },
        {
            "location": "/authorization/#levels-and-styles-illustrated",
            "text": "Following is an example of what role-level authorization looks like when using\neither style of access control.  In this example, we only allow a user to\ndelete a comment from a message board (subreddit) if the user is a moderator or\nadmin.  In other words, the user is a member of  either  the moderator or admin\nroles.  In reality, we would layer additional access control to the\nremove_comment method so that the creator of the post may also delete the\ncomment, but this detail is left out for simplicity's sake and only to\nhighlight role-level access control.",
            "title": "Levels and Styles Illustrated"
        },
        {
            "location": "/authorization/#native-vs-web-yosai-apis",
            "text": "In the examples below, you will see use of the Yosai API, such as  @Yosai.requires_role .\nYou use the  Yosai  API to secure non-web applications.  When you are working\nwith web applications, use the  WebYosai  API instead.",
            "title": "Native vs Web Yosai APIs"
        },
        {
            "location": "/authorization/#declarative-style",
            "text": "@Yosai.requires_role (roleid_s = [ 'moderator' ,   'admin' ],   logical_operator = any)  def   remove_comment (self,   submission): \n    self . database_handler . delete(submission)",
            "title": "Declarative Style"
        },
        {
            "location": "/authorization/#imperative-style",
            "text": "Note that the following example assumes that a  yosai  instance has already\nbeen instantiated and configured with a SecurityManager.  See the  yosai init \ndocumentation for how to do that.  def   remove_comment (self,   yosai,   submission): \n     with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n\n         try : \n             subject . check_role([ 'moderator' ,   'creator' ],   logical_operator = any) \n         except   UnauthorizedException: \n             print ( 'Cannot remove comment:  Access Denied.'') \n\n         self . database_handler . delete(submission)    Role-level access control is inferior to permission-level access control, but since it has its niche use, is available in Yosai.  It is highly recommended that you choose permission-level access control policies for your application.",
            "title": "Imperative Style"
        },
        {
            "location": "/authorization/#permissions",
            "text": "A permission states what behavior can be performed in an application but not who\ncan perform them. Permissions are modeled in Yosai using a flexible design that\nallows a developer to choose an appropriate level of detail that suits the\nauthorization policy governing a software application.  A Permission can be represented in Yosai as a  formatted string  or as a Permission  object.  First, let's consider the formatted string.",
            "title": "Permissions"
        },
        {
            "location": "/authorization/#1-string-formatted-permission",
            "text": "The following string presents a permission formatted using a syntax recognized\nby Yosai.  Please do not pay attention to the actual labels used but rather the format:  'section1:section2item1,section2item2:section3'  This Permission string is composed of delimited sections, one that you should notice that includes delimited sub-sections.  As you can see, the default  section delimiter  is the  colon , and the sub-section delimiter is a  comma .  A developer can control what the sections (or 'parts') of a permission represent. However, a default implementation of a Permission is provided in Yosai and it is formatted as follows:  'domain:action:instance'",
            "title": "1. String-formatted Permission"
        },
        {
            "location": "/authorization/#2-permission-object-instance",
            "text": "A  DefaultPermission  is expressed in Yosai as a  combination  of resource type (domain), the action(s) that is acted upon that resource type, and instance(s) of that resource type. This three-section format suits many permission modeling requirements. However, should a developer have more complicated requirements, Permissions can be modeled in even more complicated manner.  For example, suppose you wish to set boundaries on a permission by contextualizing when a permission is granted. A permission can be bound to a particular context, also known as 'scoping', granting permission to perform an operation only under certain circumstances:  'context:domain:action:target'",
            "title": "2. Permission object instance"
        },
        {
            "location": "/authorization/#permission-modeling",
            "text": "Following are a few examples of what a Permission string looks like.  We'll base these examples on Reddit  moderator permissioning , with liberties taken to their modeling so as to make it relevant for these examples.  If you are unfamiliar with the role of moderator, please  visit this site .  Moderators have management oversight of 'subreddit' message forums.\nTheir responsibilities provide them with controls to manage submissions and\ncomments (collectively, \"items\").  We'll use a few of these controls for\nour examples:",
            "title": "Permission Modeling"
        },
        {
            "location": "/authorization/#permission-remove-items",
            "text": "This seems straightforward, right?  A moderator can remove submissions and\ncomments.  Let's consider how item-removal permissioning may be modeled.  One way to model this is by using two permissions, each defining an operation\non a type of resource:  1 )   'submission:remove' \n2 )   'comment:remove'   A moderator will either be assigned to a single role that includes both of these permissions or assigned to two roles where each role includes one of the above permissions.  Note that if a moderator were to be assigned the above permissions that\nthe user would have moderator status across  all  of reddit.  Such power is too great and is hopefully beyond the grasp of any one individual in the production environment.  With this given, it is more likely that permission is  scoped  such that item removal is limited to a particular subreddit:  1 )   'subreddit_id123:submission:remove' \n2 )   'subreddit_id123:comment:remove'   With these permissions, a user is  authorized  to remove items within\nthe subreddit that the user is assigned a moderator role.",
            "title": "Permission:  \"remove items\""
        },
        {
            "location": "/authorization/#permission-categorize-items-as-nsfw",
            "text": "This permission marks items as not suitable for work environments. Let's add this new activity to the prior permission:  1 )   'subreddit_id123:submission:remove, categorize_nsfw' \n2 )   'subreddit_id123:comment:remove, categorize_nsfw'   Thus far, we've defined two permissions that allow the removal of and\nlabeling of nsfw of submission and comment resource types.  Suppose that you're a developer working for Reddit.  You receive a request to create a process for moderators to remove a message post, consisting of the submission AND the comments supporting it.  One of your team members uses the permission modeling above to provide you with a specification of the authorization that is required to remove a post:  To remove a post, a user must have BOTH permissions:  1 )   'subreddit_id123:submission:remove, categorize_nsfw' \n2 )   'subreddit_id123:comment:remove, categorize_nsfw'",
            "title": "Permission:  \"categorize items as NSFW\""
        },
        {
            "location": "/authorization/#you-implement-your-authorization-policy-yosai-enforces-it",
            "text": "Access control begins with an authorization policy.  A user is granted permissions through an authorization policy.  The policy states how a user is granted permission to perform an action on a type of resource, perhaps a specific resource instance, and potentially bounded by a particular context. A data model supporting the authorization policy is queried to obtain authorization information -- permissions and/or roles. The authorization policy, its data model, and the administrative system that manages the policy is decided by an organization and is outside the scope of Yosai's value proposition: Yosai enforces an authorization policy but does not provide one. Yosai obtains a user's permissions (or roles) from an outside source and then interprets them to determine whether a user is authorized.",
            "title": "You Implement Your Authorization Policy, Yosai enforces it"
        },
        {
            "location": "/authorization/#authorization-events",
            "text": "An Event is emitted to the singleton EventBus when the results of authorization are obtained.  The results are comprehensive:  every permission or role that is checked is included along with a Boolean indicating whether authorization was granted for it.  A summary \"granted\" or \"denied\" event is also communicated when a Boolean check-authorization is submitted to Yosai. If you would like to learn more about Event processing, please refer to the documentation about EventProcessing  here .  Events are communicated using a publish-subscribe paradigm.  In the case of\nAuthorization, the  ModularRealmAuthorizer  publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).  The following table lists the Authorization-related events and subscriber(s):     Event Topic  Subscriber(s)      AUTHORIZATION.GRANTED  EL    AUTHORIZATION.DENIED  EL    AUTHORIZATION.RESULTS  EL     EL =  yosai.core.event.event.EventLogger",
            "title": "Authorization Events"
        },
        {
            "location": "/authorization/#authorization-api-reference",
            "text": "Yosai provides role-level and permission-level access control.  Both levels of access control can be performed using two styles:    The  Declarative Style  of authorization involves use of a decorator that performs one of the two levels of access control (role or permission).  The wrapped method is never called if authorization fails.    The  Imperative Style  of authorization involves in-line access control within the operation that requires authorization.",
            "title": "Authorization API Reference"
        },
        {
            "location": "/authorization/#declarative-style-authorization",
            "text": "Declarative-style authorization allows you to itemize access requirements for a function call.  There are two declarative-style \"authorizers\", one for permission-level and another for role-level access control.  An  AuthorizationException  is raised when a user fails to meet specified access requirements. Following is the API you may use for declarative-style       # Permission-level \n     def   requires_permission (permission_s,   logical_operator = all): \n         \"\"\"          Requires that the calling Subject be authorized to the extent that is          required to satisfy the permission_s specified and the logical operation          upon them.          :param permission_s:   the permission(s) required          :type permission_s:  a List of Strings or List of Permission instances          :param logical_operator:  indicates whether all or at least one permission                                    is true (any, all)          :type: any OR all (from python standard library)          :raises  AuthorizationException:  if the user does not have sufficient                                            permission          \"\"\" \n         pass \n\n\n     def   requires_dynamic_permission (permission_s,   logical_operator = all): \n         \"\"\"          This method requires that the calling Subject be authorized to the extent          that is required to satisfy the dynamic permission_s specified and the logical          operation upon them.  Unlike ``requires_permission``, which uses statically          defined permissions, this function derives a permission from arguments          specified at declaration.          Dynamic permissioning requires that the dynamic arguments be keyword          arguments of the decorated method.          :param permission_s:   the permission(s) required          :type permission_s:  a List of Strings or List of Permission instances          :param logical_operator:  indicates whether all or at least one permission                                    is true (and, any)          :type: and OR all (from python standard library)          :raises  AuthorizationException:  if the user does not have sufficient                                            permission          \"\"\" \n         pass \n\n     # Role-level \n     def   requires_role (roleid_s,   logical_operator = all): \n         \"\"\"          Requires that the calling Subject be authorized to the extent that is          required to satisfy the roleid_s specified and the logical operation          upon them.          :param roleid_s:   a collection of the role(s) required, specified by                             identifiers (such as a role name)          :type roleid_s:  a List of Strings          :param logical_operator:  indicates whether all or at least one permission                                    is true (any, all)          :type: any OR all (from python standard library)          :raises  AuthorizationException:  if the user does not have sufficient                                            role membership          \"\"\" \n         pass   logical_operator , the second parameter of both declarative-style authorizers, can be either  any  or  all  functions from the python standard library.  Use  any  when you want to evaluate each item  independently  of the others and  all  when you want to evaluate items  collectively .",
            "title": "Declarative-Style Authorization"
        },
        {
            "location": "/authorization/#example-1-all-permissions-are-required",
            "text": "The following permissions are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:       @Yosai.requires_permission ([ 'domain1:action1' ,   'domain2:action2' ],   all) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 1:  All Permissions are Required"
        },
        {
            "location": "/authorization/#example-2-any-permission-specified-is-acceptable",
            "text": "The following permissions are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:       @Yosai.requires_permission ([ 'domain1:action1' ,   'domain2:action2' ],   any) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 2:  Any Permission Specified is Acceptable"
        },
        {
            "location": "/authorization/#example-3-all-roles-are-required",
            "text": "The following roles are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:       @Yosai.requires_role ([ 'role1' ,   'role2' ],   all) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 3:  All Roles are Required"
        },
        {
            "location": "/authorization/#example-4-any-role-specified-is-acceptable",
            "text": "The following roles are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:  @Yosai.requires_role ([ 'role1' ,   'role2' ],   any)  def   this_function ( ... ): \n     ...",
            "title": "Example 4:  Any Role Specified is Acceptable"
        },
        {
            "location": "/authorization/#example-5-any-permission-specified-dynamically-is-acceptable",
            "text": "The following permissions are required, each independently satisfying the access control requirement, to call this_function.  Notice how arguments are obtaining dynamically.  If you decide to use dynamic-argument permissions, you reference the arguments using string-formatting syntax.\nDynamic arguments must be passed as keyword arguments to the decorated function.  In\nthis example, this_function must be called like this_function(kwarg1=..., kwarg2=...)  When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:       @Yosai.requires_dynamic_permission ([ '{kwarg1.domain}:action1' , \n                                   '{kwarg2.domain}:action2' ],   any) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 5:  Any Permission, Specified Dynamically, is Acceptable"
        },
        {
            "location": "/authorization/#imperative-style-authorization",
            "text": "Imperative-Style authorization is used when you want to control access from within your source code, step by step, with more control over the process of checking access and responding to authorization results.  It is the more \"granular\" of the two styles.  Following is the API you may use for imperative-style authorization:  # Permission-level methods:  # ------------------------------------------------- \n     def   is_permitted (permission_s): \n         \"\"\"          Determines whether any Permission(s) associated with the subject          implies the requested Permission(s) provided.          :param permission_s: a collection of 1..N permissions, all of the same type          :type permission_s: List of Permission object(s) or String(s)          :returns: a List of tuple(s), containing the authz_abcs.Permission and a                    Boolean indicating whether the permission is granted          \"\"\" \n         pass \n\n     def   is_permitted_collective (permission_s,   logical_operator): \n         \"\"\"          This method determines whether the requested Permission(s) are          collectively granted authorization.  The Permission(s) associated with          the subject are evaluated to determine whether authorization is implied          for each Permission requested.  Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          If operator=ANY: returns True if any requested permission is implied permission          If operator=ALL: returns True if all requested permissions are implied permission          Else returns False          :param permission_s:  a List of authz_abcs.Permission objects          :param logical_operator:  indicates whether *all* or at least one                                    permission check is true, *any*          :type: any OR all (functions from python stdlib)          :returns: a Boolean          \"\"\" \n         pass \n\n     def   check_permission (permission_s,   logical_operator): \n         \"\"\"          This method determines whether the requested Permission(s) are          collectively granted authorization.  The Permission(s) associated with          the subject are evaluated to determine whether authorization is implied          for each Permission requested.  Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          This method is similar to `is_permitted_collective` except that it          raises an AuthorizationException if collectively False else does not          return any value.          :param permission_s: a collection of 1..N permissions          :type permission_s: List of authz_abcs.Permission objects or Strings          :param logical_operator:  indicates whether all or at least one                                    permission check is true (any)          :type: any OR all (from python stdlib)          :raises UnauthorizedException: if any permission is unauthorized          \"\"\"  # Role-level methods:  # ------------------------------------------------- \n     def   has_role (roleid_s): \n         \"\"\"          Determines whether a Subject is a member of the Role(s) requested          :param roleid_s: 1..N role identifiers (strings)          :type roleid_s:  Set of Strings          :returns: a frozenset of tuple(s), each containing the Role identifier                    requested and a Boolean indicating whether the subject is                    a member of that Role                    - the tuple format is: (roleid, Boolean)          \"\"\" \n         pass \n\n     def   has_role_collective (roleid_s,   logical_operator): \n         \"\"\"          This method determines whether the Subject's role membership          collectively grants authorization for the roles requested.  The          Role(s) associated with the subject are evaluated to determine          whether the roles requested are sufficiently addressed by those that          the Subject is a member of. Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          If operator=ANY, returns True if any requested role membership is                           satisfied          If operator=ALL: returns True if all of the requested permissions are                           implied permission          Else returns False          :param roleid_s: 1..N role identifiers (strings)          :type roleid_s:  Set of Strings          :param logical_operator:  any or all          :type logical_operator:  function  (stdlib)          :rtype:  bool          \"\"\" \n         pass \n\n     def   check_role (role_ids,   logical_operator): \n         \"\"\"          This method determines whether the Subject's role membership          collectively grants authorization for the roles requested.  The          Role(s) associated with the subject are evaluated to determine          whether the roles requested are sufficiently addressed by those that          the Subject is a member of. Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          This method is similar to has_role_collective except that it raises          an AuthorizationException if collectively False else does not return any          :param roleid_s: 1..N role identifiers (strings)          :type roleid_s:  Set of Strings          :param logical_operator:  any or all          :type logical_operator:  function  (stdlib)          :raises  AuthorizationException:  if the user does not have sufficient                                            role membership          \"\"\" \n         pass   The first argument of every method is a List containing  either  authorization object instances ( Permission  or  Role )  or  String(s). Yosai does  not  support a commingling of the two supported types.  You will notice that some of the methods in the imperative-style authorization API include a second parameter,  logical_operator .  This parameter can be one of two values: either  any  or  all  functions from the python standard library.  Use  any  when you want to evaluate each item  independently  of the others and  all  when you want to evaluate items  collectively .  Note that the following set of examples assumes that a  yosai  instance has already\nbeen instantiated and configured with a SecurityManager.  See the  yosai init \ndocumentation for how to do that:",
            "title": "Imperative-Style Authorization"
        },
        {
            "location": "/authorization/#example-1-is_permitted",
            "text": "with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n         results   =   subject . is_permitted([ 'domain1:action1' ,   'domain2:action2' ]) \n\n         if   any(is_permitted   for   permission,   is_permitted   in   results): \n             print ( 'any permission is granted' ) \n\n         if   all(is_permitted   for   permission,   is_permitted   in   results): \n             print ( 'all permission is granted, too!' )    results  is a list of tuples, each containing a Permission object and a Boolean value indicating whether access is granted (True) or denied (False)",
            "title": "Example 1:  is_permitted"
        },
        {
            "location": "/authorization/#example-2-is_permitted_collective",
            "text": "with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n         any_result_check   =   subject . is_permitted_collective([ 'domain1:action1' , \n                                                                  'domain2:action2' ],   any) \n         if   any_result_check: \n             print ( 'any permission is granted' ) \n\n         all_result_check   =   subject . is_permitted_collective([ 'domain1:action1' , \n                                                                  'domain2:action2' ],   all) \n\n         if   all_result_check: \n             print ( 'all permission is granted, too!' )    any_result_check  and  all_result_check  are Boolean values",
            "title": "Example 2:  is_permitted_collective"
        },
        {
            "location": "/authorization/#example-3-check_permission",
            "text": "with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n         try : \n             subject . check_permission([ 'domain1:action1' , \n                                            'domain2:action2' ], \n                                           any) \n         except   AuthorizationException: \n             print ( 'any permission denied' ) \n         else : \n             print ( 'any permission granted' ) \n\n         try : \n             subject . check_permission([ 'domain1:action1' , \n                                            'domain2:action2' ], \n                                           all) \n         except   AuthorizationException: \n             print ( 'all permission denied' ) \n         else : \n             print ( 'all permission granted' )    check_permission  succeeds quietly else raises an AuthorizationException",
            "title": "Example 3:  check_permission"
        },
        {
            "location": "/authorization/#example-1-has_role",
            "text": "with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n         results   =   subject . has_role([ 'role1' ,   'role2' ]) \n\n         if   any(has_role   for   role,   has_role   in   results): \n             print ( 'any role is confirmed' ) \n\n         if   all(has_role   for   role,   has_role   in   results): \n             print ( 'all role is confirmed, too!' )    results  is a list of tuples, each containing a Role and a Boolean value indicating whether role membership is confirmed (True if so)",
            "title": "Example 1:  has_role"
        },
        {
            "location": "/authorization/#example-2-has_role_collective",
            "text": "with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n         any_result_check   =   subject . has_role_collective([ 'role1' ,   'role2' ],   any) \n\n         if   any_result_check: \n             print ( 'any role is confirmed' ) \n\n         all_result_check   =   subject . has_role_collective([ 'role1' ,   'role2' ],   all) \n\n         if   all_result_check: \n             print ( 'all role is confirmed, too!' )    any_result_check  and  all_result_check  are Boolean values",
            "title": "Example 2:  has_role_collective"
        },
        {
            "location": "/authorization/#example-3-check_role",
            "text": "with   Yosai . context(yosai): \n         subject   =   Yosai . get_current_subject() \n         try : \n             subject . check_role([ 'role1' ,   'role2' ],   any) \n\n         except   AuthorizationException: \n             print ( 'any role denied' ) \n         else : \n             print ( 'any role confirmed' ) \n\n         try : \n             subject . check_role([ 'role1' ,   'role2' ],   all) \n\n         except   AuthorizationException: \n             print ( 'all role denied' ) \n         else : \n             print ( 'all role confirmed' )    check_role  succeeds quietly else raises an AuthorizationException",
            "title": "Example 3:  check_role"
        },
        {
            "location": "/authorization/#references",
            "text": "OWASP Access Control Cheat Sheet",
            "title": "References"
        },
        {
            "location": "/sessionmanagement/",
            "text": "Sessions and Session Management\n\n\n\n\nUse Sessions to track the state of a user's interactions with your application across multiple requests, over a specified period of time.  Tracking user state with Sessions enables more feature-rich user experiences.  Further, Sessions play a major role in access control.\n\n\nSession Management involves creating, reading, updating, and deleting of Sessions and Session attributes, and validating Sessions.\n\n\nYosai's \nSessionManager\n uses a \nCachingSessionStore\n to cache sessions. If you are not caching sessions, you you are either using in-memory session storage  (the \nMemorySessionStore\n) or using your own custom SessionStore, which is beyond the scope of consideration in this documentation.\n\n\nAuthentication, Authorization, and Session Management are Related\n\n\nAccess is limited by user identity: a guest cannot perform the operations that an authenticated user can, and each authenticated user may perform different operations.\n\n\nThe identity of an authenticated user is recorded in the Session.\n\n\nSince access control is limited by identity, and identity is obtained from a Session, access control is considered \nbound\n to a Session.\n\n\nProperties of a Session , Session Risk, and Risk Countermeasures\n\n\nSessions are a \"threat vector\":  a path that an \"actor\" may exploit to attack a \"target\" (your application).  Sessions are exploited by a process known as hijacking.  Session Management helps to manage many of the inherent risks of Sessions through a series of countermeasures.  More information about these countermeasures follows in the documentation.\n\n\nThe Session Token\n\n\nA Session Token is like a smart chip, or magnetic strip, on a credit card in that it contains identification-- a session identifier (SessionID).  However, unlike the elements of a credit card, the Session Token has a much shorter lifespan.\n\n\nThe \nSessionID\n is a sensitive and critical piece of information.  It uniquely identifies a Session.  It is the Session's key in a SessionStore (cache) and it is the key that is sent with subsequent requests by a client (the user).\n\n\nOnce an authenticated session is established, the \nSessionID\n is the client's key to Yosai.  Therefore, it is very important that the session identifier be unique and very difficult to reproduce.  \n\n\nYosai's default method to generate a \nSessionID\n is as follows:\n\nsha256(sha512(urandom(20)).digest()).hexdigest()\n\n\nTemporal Risks and Countermeasures\n\n\nThe risk of compromising a Session increases as time passes.  To address time-driven risks, Yosai defines temporal properties in a Session -- idle time and maximum allowable time to live (TTL) -- that enable \"timing out\" of Sessions.\n\n\nWhen a Session \"times out\", it is considered \nexpired\n.  When a Session is \nexpired\n, it can no longer be used in Yosai, and therefore is no longer at risk of being hijacked.\n\n\nThe timeout thresholds are configured in the Yosai settings YAML file. Should you find their default settings unacceptable, you can easily change them.  The default settings are somewhat aggressive so as to minimize the risks that defaults may present and to encourage developers to take ownership of session time-out decisions.\n\n\nIdle time\n\n\n\n\nThis property represents the total permissible time for a user to be inactive in a system, or idle.  Picture idle timeout as an hourglass that is turned over and reset periodically. The way that idle time is reset is by updating the Session's \nlast_access_time\n attribute.  As to when the \nlast_access_time\n is updated depends on what \"auto_touch\" has been configured to or whether you've chosen an alternative time to touch than the default (per-access).\n\n\nA \nDefaultNativeSessionManager\n has an attribute, \"auto_touch\", that when set to True will allow the updating of a Session's \nlast_access_time\n attribute to the current time, whenever a session is accessed, following Session validation. As mentioned, when a Session should be touched depends on the type of application you are developing and thus auto_touch is a configurable feature.  When a Session is obtained from the SessionStore, it is immediately validated.  Should the validation not raise any exceptions, and if auto_touch is True, the Session will be \"touched\".  Touching a Session is the process of flipping and resetting the hourglass, so to speak, by updating the \nlast_access_time\n attribute of the Session.\n\n\nYosai's default idle time setting for a Session is \n5 minutes\n.\n\n\nTime to live\n\n\n\n\nA Session has a maximum allowable time period that it may exist.  It is the final countdown until a Session is expired. It cannot be reset, unlike idle timeout. Many computer systems refer to this as a TTL -- time to live.  Yosai's default time-to-live for a Session is \n30 minutes\n.\n\n\nStopping Sessions\n\n\nAside from expirations, another mechanism for rendering Sessions useless in is \nstopping\n them.  When a subject logs out of a system, the subject's Session is stopped.  Like an expired Session, a \nstopped\n Session can no longer be used and is consequently no longer at risk of being hijacked.\n\n\nSession Validation\n\n\nSession Validation is the process of determining whether a Session has stopped or expired.  When a session has stopped or expired, it is considered \ninvalid\n.\n\n\nA Session expires when the time duration between the current time and the last recorded time that a Session was accessed exceeds either timeout threshold.\n\n\nKeeping track of idle expiration presents performance challenges.  Therefore, Sessions are validated \nonly\n when they are accessed (i.e. subject.get_session()).\n\n\nthe last_access_timestamp synchronized with session usage presents a\n\n\nif the duration between the last_access_timestamp and the current time exceeds either timeout threshold, a session is considered expired\n\n\nBy default, Sessions are \"lazy validated\" in that they are validated at the time that [they are accessed?].\n\n\nAs discussed in an earlier section above, access control is \nbound\n to a Session. Since access control is \nbound\n to a Session, when a Session is invalidated so too does the authorization information cached for the Session.  Invalid authorization information is cleared from cache through event handling.\n\n\nIdle Timeout Edge Case\n\n\nMonitoring for idle timeout increases the complexity of Session Management.\nAs discussed, Session validation taxes the performance of an application and\ntherefore does not run before every authorization check.  Instead, validation\nis designed to maximize utility for the most popular use case-- one where the\nsubject instance has a short life span in memory and sessions validate when\nthey are accessed.\n\n\nTherefore, it is recommended that you release a Subject instance for garbage\ncollection between requests.\n\n\nThe Session Synchronization Design Challenge\n\n\nKeeping the last_access_timestamp synchronized with session usage presents a performance design challenge that you are encouraged to help improve.  Ideas are welcome!\n\n\nSession Invalidation\n\n\nBy default, whenever Yosai detects an invalid session, it attempts to delete it from the underlying session data store via the SessionStore.delete(session) method.  However, should you decide not to automatically delete invalid sessions, you can easily opt-out of this process.  For example, if your application uses a SessionStore that backs a queryable data store, perhaps your dev team wants old or invalid sessions to be available for a certain period of time. Storing invalid sessions would allow you to run queries against the data store to see, for example, how many sessions a user has created over the last week, or the average duration of a user's sessions, or similar reporting-type queries.\n\n\nAt Session expiration, Yosai ties up loose ends, so to speak, through its event-driven architecture.\n\n\nSession Usage\n\n\nSession Initialization\n\n\nA Session can be used to manage state for a Subject regardless of whether the Subject has authenticated itself or remains anonymous.  Yosai initializes a server-side Session when a Subject is instantiated.\n\n\nfrom\n \nyosai.core\n \nimport\n \nYosai,\n \nUsernamePasswordToken\n\n\n\n# creates an \"anonymous session\" if the current executing subject hasn't\n\n\n# logged in yet:\n\n\nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n\nwith\n \nYosai\n.\ncontext(yosai):\n\n  \nguest\n \n=\n \nYosai\n.\nget_current_subject()\n  \n# session is created in the process\n\n  \nsession\n \n=\n \nsubject\n.\nget_session()\n\n\n\n\n\n\nAfter a user authenticates itself, Yosai creates a new session for the user. This is done for a few reasons.  The user's access to the system changes as the user's identity changes (from anonymous to authenticated).  A new, \"authenticated session\" replaces the \"anonymous session\" the moment that a subject is authenticated as a user:\n\n\nfrom\n \nyosai.core\n \nimport\n \nYosai,\n \nUsernamePasswordToken\n\n\n\nwith\n \nYosai\n.\ncontext(yosai):\n\n  \n# creates an \"anonymous session\" if the current executing subject hasn't\n\n  \n# logged in yet:\n\n  \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n\n  \nauthc_token\n \n=\n \nUsernamePasswordToken(username\n=\n'thedude'\n,\n\n                                      \ncredentials\n=\n'letsgobowling'\n)\n\n\n  \n# creates an \"authenticated session\" if login in successful, raising\n\n  \n# an exception otherwise (try/except left out to simplify the example):\n\n  \nsubject\n.\nlogin(authc_token)\n\n\n\n\n\n\n\n\nIt is recommended that the session be regenerated by the application after     \nany\n privilege level change within the associated user session.\n\n\n\n\nSession Storage\n\n\nWhenever a Session is created or updated, its data is persisted to a storage location so that it may be accessible by the application at a later time. Similarly, when a Session is invalid and longer being used, it is deleted from storage so that the Session data store space is not exhausted (if you're not taking advantage of TTL expiration in your data store).\n\n\nThe SessionManager implementations delegate these Create/Read/Update/Delete (CRUD) operations to an internal component, the SessionStore, which reflects the Data Access Object (DAO) design pattern.\n\n\nThe power of the SessionStore is that you can implement this interface to communicate with any data store you wish. This means your session data can reside in memory, on the file system, in a relational database or NoSQL data store, or any other location you want. You have control over persistence behavior.\n\n\nYosai features an in-memory MemorySessionStore and CachingSessionStore.  The CachingSessionStore is the default, and recommended, SessionStore for Yosai.\n\n\nSession Events\n\n\nAn Event is emitted to the singleton EventBus, in Yosai, when a Session is \nstarted\n, \nstopped\n, or \nexpired\n.  If you would like to learn more about Event processing, please refer to the documentation about Event Processing.\n\n\nEvents are communicated using a publish-subscribe paradigm.  In the case of Sessions, a \nSessionEventHandler\n publishes an event to a channel (an internal Event Bus). The EventBus relays an event to consumers who have subscribed to the event's topic. It relays the event by calling the callback method registered for a consumer, using the event payload as its argument(s).\n\n\nThe following table lists the Session-related events and who the subscriber(s) are:\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nSESSION.START\n\n\nEL\n\n\n\n\n\n\nSESSION.STOP\n\n\nMRA, EL\n\n\n\n\n\n\nSESSION.EXPIRE\n\n\nMRA, EL\n\n\n\n\n\n\n\n\n\n\nMRA = \nyosai.core.authz.authz.ModularRealmAuthorizer\n\n\nSEH = \nyosai.core.session.session.SessionEventHandler\n\n\n\n\nExample:  SESSION.EXPIRE Event Processing\n\n\nAt Yosai initialization, \nyosai.core.authz.authz.ModularRealmAuthorizer\n subscribes to a few event topics, one of which is 'SESSION.EXPIRE'. When it subscribes to the 'SESSION.EXPIRE' topic, it registers a callback method, \nsession_clears_cache\n.  This callback method is called by the EventBus whenever a 'SESSION.EXPIRE' event is emitted to the bus.\n\n\nA \nSESSION.EXPIRE\n event is emitted by a \nyosai.core.session.session.SessionEventHandler\n when Session Validation has recognized a Session as expired.\n\n\nAs of yosai.core v0.1.0, the \nModularRealmAuthorizer\n and \nEventLogger\n are the two subscribers of the \nSESSION.EXPIRE\n topic (see table above).  The callback method registered for each subscriber is called in an arbitrary, sequential fasion (PyPubSub design) when a SessionEventHandler emits a SESSION.EXPIRE event to the Eventbus.\n\n\nHere is an example of an \nexpired-session\n event processing through Yosai, omitting event logging processing:\n\n\n\n\nSession Tutorial\n\n\nIn this tutorial, you will learn how to use the Session API to perform server-side session management.  We'll use a shopping cart example to illustrate how to manage state using a Session object.  You will learn how to:\n\n\n\n\ndefine marshalling logic required to properly (de)serialize custom objects\n\n\nmanage sessions using Yosai's Session API, including:\n\n\nget_attribute\n\n\nset_attribute\n\n\nremove_attribute\n\n\n\n\nThis is \nnot\n a primer on how to write your own e-commerce shopping cart application.  This example is intended to illustrate the Session API.  This ShoppingCart uses a really stripped down, dumb model intended to show you how to control the marshalling of custom\nobjects.\n\n\nMarshalling supports standard object types from the standard library.  When you use objects other than standard primitives, such as objects from the collections library,\nyou'll need to control conversion of your objects to supported data types, and vice versa, by implementing \nsetstate\n and \ngetstate\n methods within your serializables:\n\n\nShoppingCartItem\n \n=\n \ncollections\n.\nnamedtuple(\n'ShoppingCartItem'\n,\n \n'upc title'\n)\n\n\n\nclass\n \nShoppingCart\n:\n\n    \ndef\n \n__init__\n(self):\n\n        \nself\n.\nbasket\n \n=\n \ncollections\n.\ndefaultdict(int)\n\n\n    \ndef\n \nadd_item\n(self,\n \nitem,\n \nquantity\n=\n1\n):\n\n        \n\"\"\"\n\n\n        :param item: a ShoppingCartItem namedtuple\n\n\n        :type quantity: int\n\n\n        \"\"\"\n\n        \nself\n.\nbasket[item]\n \n+=\n \nquantity\n\n\n    \ndef\n \nremove_item\n(self,\n \nitem):\n\n        \n\"\"\"\n\n\n        :param item: a ShoppingCartItem namedtuple\n\n\n        \"\"\"\n\n        \nself\n.\nbasket\n.\npop(item)\n\n\n    \ndef\n \n__getstate__\n(self):\n\n        \n# neither defaultdict nor tuple key is supported for serialization\n\n        \n# so we must convert them:\n\n        \nreturn\n \n{\n'basket'\n:\n \n{\n'{0}|{1}'\n.\nformat(key\n.\nupc,\n \nkey\n.\ntitle):\n \nvalue\n\n                           \nfor\n \nkey,\n \nvalue\n \nin\n \nself\n.\nbasket\n.\nitems()}}\n\n\n    \ndef\n \n__setstate__\n(self,\n \nstate):\n\n        \nself\n.\nbasket\n \n=\n \ncollections\n.\ndefaultdict(int)\n\n        \nfor\n \nkey,\n \nvalue\n \nin\n \nstate[\n'basket'\n]\n.\nitems():\n\n            \nkeys\n \n=\n \nkey\n.\nsplit(\n\"|\"\n)\n\n            \nself\n.\nbasket[ShoppingCartItem(upc\n=\nkeys[\n0\n],\n \ntitle\n=\nkeys[\n1\n])]\n \n=\n \nvalue\n\n\n\n\n\n\nYou are ready to initialize Yosai with shopping-cart enabled session management\ncapabilities.  Simply pass the serializable during Yosai initialization within\na list:\n\n\n    \nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n,\n\n                  \nsession_attributes\n=\n[ShoppingCart])\n\n\n\n\n\n\nHere's one way you could interact with the shopping cart in your application using\nYosai session management:\n\n\nShopping Cart Manager\n\n\nclass\n \nShoppingCartSessionManager\n:\n\n\n    \n@staticmethod\n\n    \ndef\n \nlist_items\n(session):\n\n        \nshopping_cart\n \n=\n \nsession\n.\nget_attribute(\n'shopping_cart'\n)\n\n        \nif\n \nshopping_cart:\n\n            \nreturn\n \nshopping_cart\n.\nitems()\n\n        \nreturn\n \nNone\n\n\n    \n@staticmethod\n\n    \ndef\n \nadd_item\n(session,\n \nitem,\n \nquantity\n=\n1\n):\n\n        \n\"\"\"\n\n\n        :param item: a ShoppingCartItem namedtuple\n\n\n        \"\"\"\n\n        \nshopping_cart\n \n=\n \nsession\n.\nget_attribute(\n'shopping_cart'\n)\n\n        \nif\n \nshopping_cart:\n\n            \nshopping_cart\n.\nadd_item(item,\n \nquantity)\n\n        \nelse\n:\n\n            \nshopping_cart\n \n=\n \nShoppingCart()\n\n        \nsession\n.\nset_attribute(\n'shopping_cart'\n,\n \nshopping_cart)\n\n\n\n    \n@staticmethod\n\n    \ndef\n \nremove_item\n(session,\n \nitem):\n\n        \nshopping_cart\n \n=\n \nsession\n.\nget_attribute(\n'shopping_cart'\n)\n\n        \nif\n \nshopping_cart:\n\n            \nshopping_cart\n.\nremove_item(item)\n\n            \nsession\n.\nset_attribute(\n'shopping_cart'\n,\n \nshopping_cart)\n\n\n\n\n\n\nLet's now see all of our objects in action. We'll add items to the shopping cart\nand then remove one.\n\n\nOperation 1:  Add four items to the shopping cart\n\n\n    \nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n,\n\n                  \nsession_attributes\n=\n[ShoppingCart])\n\n\n    \ncart\n \n=\n \nShoppingCartSessionManager\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n      \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n      \nsession\n \n=\n \nsubject\n.\nget_session()\n\n\n      \n# could easily use functools.partial for this, but keeping it explicit\n\n      \n# for the example so as to not confuse:\n\n      \ncart\n.\nadd_item(session,\n \n'0043000200216'\n,\n \n4\n)\n\n      \ncart\n.\nadd_item(session,\n \n'016000119772'\n,\n \n1\n)\n\n      \ncart\n.\nadd_item(session,\n \n'52159012038'\n,\n \n3\n)\n\n      \ncart\n.\nadd_item(session,\n \n'00028400028196'\n,\n \n1\n)\n\n\n      \ncart\n.\nlist_items(session)\n\n\n\n\n\n\nOperation 2:  Remove an item from the shopping cart\n\n\n    \nyosai\n \n=\n \nYosai(env_var\n=\n'YOSAI_SETTINGS'\n,\n\n                  \nsession_attributes\n=\n[ShoppingCart])\n\n\n    \ncart\n \n=\n \nShoppingCartSessionManager(session)\n\n\n    \nwith\n \nYosai\n.\ncontext(yosai):\n\n      \nsubject\n \n=\n \nYosai\n.\nget_current_subject()\n\n      \nsession\n \n=\n \nsubject\n.\nget_session()\n\n\n      \ncart\n.\nremove_item(session,\n \n'00028400028196'\n)\n\n\n      \ncart\n.\nlist_items(session)\n\n\n\n\n\n\nHere\n is a fully working example of the code shared above.\n\n\nReferences\n\n\nOWASP Session Management CheatSheet",
            "title": "Session Management"
        },
        {
            "location": "/sessionmanagement/#sessions-and-session-management",
            "text": "Use Sessions to track the state of a user's interactions with your application across multiple requests, over a specified period of time.  Tracking user state with Sessions enables more feature-rich user experiences.  Further, Sessions play a major role in access control.  Session Management involves creating, reading, updating, and deleting of Sessions and Session attributes, and validating Sessions.  Yosai's  SessionManager  uses a  CachingSessionStore  to cache sessions. If you are not caching sessions, you you are either using in-memory session storage  (the  MemorySessionStore ) or using your own custom SessionStore, which is beyond the scope of consideration in this documentation.",
            "title": "Sessions and Session Management"
        },
        {
            "location": "/sessionmanagement/#authentication-authorization-and-session-management-are-related",
            "text": "Access is limited by user identity: a guest cannot perform the operations that an authenticated user can, and each authenticated user may perform different operations.  The identity of an authenticated user is recorded in the Session.  Since access control is limited by identity, and identity is obtained from a Session, access control is considered  bound  to a Session.",
            "title": "Authentication, Authorization, and Session Management are Related"
        },
        {
            "location": "/sessionmanagement/#properties-of-a-session-session-risk-and-risk-countermeasures",
            "text": "Sessions are a \"threat vector\":  a path that an \"actor\" may exploit to attack a \"target\" (your application).  Sessions are exploited by a process known as hijacking.  Session Management helps to manage many of the inherent risks of Sessions through a series of countermeasures.  More information about these countermeasures follows in the documentation.",
            "title": "Properties of a Session , Session Risk, and Risk Countermeasures"
        },
        {
            "location": "/sessionmanagement/#the-session-token",
            "text": "A Session Token is like a smart chip, or magnetic strip, on a credit card in that it contains identification-- a session identifier (SessionID).  However, unlike the elements of a credit card, the Session Token has a much shorter lifespan.  The  SessionID  is a sensitive and critical piece of information.  It uniquely identifies a Session.  It is the Session's key in a SessionStore (cache) and it is the key that is sent with subsequent requests by a client (the user).  Once an authenticated session is established, the  SessionID  is the client's key to Yosai.  Therefore, it is very important that the session identifier be unique and very difficult to reproduce.    Yosai's default method to generate a  SessionID  is as follows: sha256(sha512(urandom(20)).digest()).hexdigest()",
            "title": "The Session Token"
        },
        {
            "location": "/sessionmanagement/#temporal-risks-and-countermeasures",
            "text": "The risk of compromising a Session increases as time passes.  To address time-driven risks, Yosai defines temporal properties in a Session -- idle time and maximum allowable time to live (TTL) -- that enable \"timing out\" of Sessions.  When a Session \"times out\", it is considered  expired .  When a Session is  expired , it can no longer be used in Yosai, and therefore is no longer at risk of being hijacked.  The timeout thresholds are configured in the Yosai settings YAML file. Should you find their default settings unacceptable, you can easily change them.  The default settings are somewhat aggressive so as to minimize the risks that defaults may present and to encourage developers to take ownership of session time-out decisions.",
            "title": "Temporal Risks and Countermeasures"
        },
        {
            "location": "/sessionmanagement/#idle-time",
            "text": "This property represents the total permissible time for a user to be inactive in a system, or idle.  Picture idle timeout as an hourglass that is turned over and reset periodically. The way that idle time is reset is by updating the Session's  last_access_time  attribute.  As to when the  last_access_time  is updated depends on what \"auto_touch\" has been configured to or whether you've chosen an alternative time to touch than the default (per-access).  A  DefaultNativeSessionManager  has an attribute, \"auto_touch\", that when set to True will allow the updating of a Session's  last_access_time  attribute to the current time, whenever a session is accessed, following Session validation. As mentioned, when a Session should be touched depends on the type of application you are developing and thus auto_touch is a configurable feature.  When a Session is obtained from the SessionStore, it is immediately validated.  Should the validation not raise any exceptions, and if auto_touch is True, the Session will be \"touched\".  Touching a Session is the process of flipping and resetting the hourglass, so to speak, by updating the  last_access_time  attribute of the Session.  Yosai's default idle time setting for a Session is  5 minutes .",
            "title": "Idle time"
        },
        {
            "location": "/sessionmanagement/#time-to-live",
            "text": "A Session has a maximum allowable time period that it may exist.  It is the final countdown until a Session is expired. It cannot be reset, unlike idle timeout. Many computer systems refer to this as a TTL -- time to live.  Yosai's default time-to-live for a Session is  30 minutes .",
            "title": "Time to live"
        },
        {
            "location": "/sessionmanagement/#stopping-sessions",
            "text": "Aside from expirations, another mechanism for rendering Sessions useless in is  stopping  them.  When a subject logs out of a system, the subject's Session is stopped.  Like an expired Session, a  stopped  Session can no longer be used and is consequently no longer at risk of being hijacked.",
            "title": "Stopping Sessions"
        },
        {
            "location": "/sessionmanagement/#session-validation",
            "text": "Session Validation is the process of determining whether a Session has stopped or expired.  When a session has stopped or expired, it is considered  invalid .  A Session expires when the time duration between the current time and the last recorded time that a Session was accessed exceeds either timeout threshold.  Keeping track of idle expiration presents performance challenges.  Therefore, Sessions are validated  only  when they are accessed (i.e. subject.get_session()).  the last_access_timestamp synchronized with session usage presents a  if the duration between the last_access_timestamp and the current time exceeds either timeout threshold, a session is considered expired  By default, Sessions are \"lazy validated\" in that they are validated at the time that [they are accessed?].  As discussed in an earlier section above, access control is  bound  to a Session. Since access control is  bound  to a Session, when a Session is invalidated so too does the authorization information cached for the Session.  Invalid authorization information is cleared from cache through event handling.",
            "title": "Session Validation"
        },
        {
            "location": "/sessionmanagement/#idle-timeout-edge-case",
            "text": "Monitoring for idle timeout increases the complexity of Session Management.\nAs discussed, Session validation taxes the performance of an application and\ntherefore does not run before every authorization check.  Instead, validation\nis designed to maximize utility for the most popular use case-- one where the\nsubject instance has a short life span in memory and sessions validate when\nthey are accessed.  Therefore, it is recommended that you release a Subject instance for garbage\ncollection between requests.",
            "title": "Idle Timeout Edge Case"
        },
        {
            "location": "/sessionmanagement/#the-session-synchronization-design-challenge",
            "text": "Keeping the last_access_timestamp synchronized with session usage presents a performance design challenge that you are encouraged to help improve.  Ideas are welcome!",
            "title": "The Session Synchronization Design Challenge"
        },
        {
            "location": "/sessionmanagement/#session-invalidation",
            "text": "By default, whenever Yosai detects an invalid session, it attempts to delete it from the underlying session data store via the SessionStore.delete(session) method.  However, should you decide not to automatically delete invalid sessions, you can easily opt-out of this process.  For example, if your application uses a SessionStore that backs a queryable data store, perhaps your dev team wants old or invalid sessions to be available for a certain period of time. Storing invalid sessions would allow you to run queries against the data store to see, for example, how many sessions a user has created over the last week, or the average duration of a user's sessions, or similar reporting-type queries.  At Session expiration, Yosai ties up loose ends, so to speak, through its event-driven architecture.",
            "title": "Session Invalidation"
        },
        {
            "location": "/sessionmanagement/#session-usage",
            "text": "",
            "title": "Session Usage"
        },
        {
            "location": "/sessionmanagement/#session-initialization",
            "text": "A Session can be used to manage state for a Subject regardless of whether the Subject has authenticated itself or remains anonymous.  Yosai initializes a server-side Session when a Subject is instantiated.  from   yosai.core   import   Yosai,   UsernamePasswordToken  # creates an \"anonymous session\" if the current executing subject hasn't  # logged in yet:  yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' )  with   Yosai . context(yosai): \n   guest   =   Yosai . get_current_subject()    # session is created in the process \n   session   =   subject . get_session()   After a user authenticates itself, Yosai creates a new session for the user. This is done for a few reasons.  The user's access to the system changes as the user's identity changes (from anonymous to authenticated).  A new, \"authenticated session\" replaces the \"anonymous session\" the moment that a subject is authenticated as a user:  from   yosai.core   import   Yosai,   UsernamePasswordToken  with   Yosai . context(yosai): \n   # creates an \"anonymous session\" if the current executing subject hasn't \n   # logged in yet: \n   subject   =   Yosai . get_current_subject() \n\n   authc_token   =   UsernamePasswordToken(username = 'thedude' , \n                                       credentials = 'letsgobowling' ) \n\n   # creates an \"authenticated session\" if login in successful, raising \n   # an exception otherwise (try/except left out to simplify the example): \n   subject . login(authc_token)    It is recommended that the session be regenerated by the application after      any  privilege level change within the associated user session.",
            "title": "Session Initialization"
        },
        {
            "location": "/sessionmanagement/#session-storage",
            "text": "Whenever a Session is created or updated, its data is persisted to a storage location so that it may be accessible by the application at a later time. Similarly, when a Session is invalid and longer being used, it is deleted from storage so that the Session data store space is not exhausted (if you're not taking advantage of TTL expiration in your data store).  The SessionManager implementations delegate these Create/Read/Update/Delete (CRUD) operations to an internal component, the SessionStore, which reflects the Data Access Object (DAO) design pattern.  The power of the SessionStore is that you can implement this interface to communicate with any data store you wish. This means your session data can reside in memory, on the file system, in a relational database or NoSQL data store, or any other location you want. You have control over persistence behavior.  Yosai features an in-memory MemorySessionStore and CachingSessionStore.  The CachingSessionStore is the default, and recommended, SessionStore for Yosai.",
            "title": "Session Storage"
        },
        {
            "location": "/sessionmanagement/#session-events",
            "text": "An Event is emitted to the singleton EventBus, in Yosai, when a Session is  started ,  stopped , or  expired .  If you would like to learn more about Event processing, please refer to the documentation about Event Processing.  Events are communicated using a publish-subscribe paradigm.  In the case of Sessions, a  SessionEventHandler  publishes an event to a channel (an internal Event Bus). The EventBus relays an event to consumers who have subscribed to the event's topic. It relays the event by calling the callback method registered for a consumer, using the event payload as its argument(s).  The following table lists the Session-related events and who the subscriber(s) are:     Event Topic  Subscriber(s)      SESSION.START  EL    SESSION.STOP  MRA, EL    SESSION.EXPIRE  MRA, EL      MRA =  yosai.core.authz.authz.ModularRealmAuthorizer  SEH =  yosai.core.session.session.SessionEventHandler",
            "title": "Session Events"
        },
        {
            "location": "/sessionmanagement/#example-sessionexpire-event-processing",
            "text": "At Yosai initialization,  yosai.core.authz.authz.ModularRealmAuthorizer  subscribes to a few event topics, one of which is 'SESSION.EXPIRE'. When it subscribes to the 'SESSION.EXPIRE' topic, it registers a callback method,  session_clears_cache .  This callback method is called by the EventBus whenever a 'SESSION.EXPIRE' event is emitted to the bus.  A  SESSION.EXPIRE  event is emitted by a  yosai.core.session.session.SessionEventHandler  when Session Validation has recognized a Session as expired.  As of yosai.core v0.1.0, the  ModularRealmAuthorizer  and  EventLogger  are the two subscribers of the  SESSION.EXPIRE  topic (see table above).  The callback method registered for each subscriber is called in an arbitrary, sequential fasion (PyPubSub design) when a SessionEventHandler emits a SESSION.EXPIRE event to the Eventbus.  Here is an example of an  expired-session  event processing through Yosai, omitting event logging processing:",
            "title": "Example:  SESSION.EXPIRE Event Processing"
        },
        {
            "location": "/sessionmanagement/#session-tutorial",
            "text": "In this tutorial, you will learn how to use the Session API to perform server-side session management.  We'll use a shopping cart example to illustrate how to manage state using a Session object.  You will learn how to:   define marshalling logic required to properly (de)serialize custom objects  manage sessions using Yosai's Session API, including:  get_attribute  set_attribute  remove_attribute   This is  not  a primer on how to write your own e-commerce shopping cart application.  This example is intended to illustrate the Session API.  This ShoppingCart uses a really stripped down, dumb model intended to show you how to control the marshalling of custom\nobjects.  Marshalling supports standard object types from the standard library.  When you use objects other than standard primitives, such as objects from the collections library,\nyou'll need to control conversion of your objects to supported data types, and vice versa, by implementing  setstate  and  getstate  methods within your serializables:  ShoppingCartItem   =   collections . namedtuple( 'ShoppingCartItem' ,   'upc title' )  class   ShoppingCart : \n     def   __init__ (self): \n         self . basket   =   collections . defaultdict(int) \n\n     def   add_item (self,   item,   quantity = 1 ): \n         \"\"\"          :param item: a ShoppingCartItem namedtuple          :type quantity: int          \"\"\" \n         self . basket[item]   +=   quantity \n\n     def   remove_item (self,   item): \n         \"\"\"          :param item: a ShoppingCartItem namedtuple          \"\"\" \n         self . basket . pop(item) \n\n     def   __getstate__ (self): \n         # neither defaultdict nor tuple key is supported for serialization \n         # so we must convert them: \n         return   { 'basket' :   { '{0}|{1}' . format(key . upc,   key . title):   value \n                            for   key,   value   in   self . basket . items()}} \n\n     def   __setstate__ (self,   state): \n         self . basket   =   collections . defaultdict(int) \n         for   key,   value   in   state[ 'basket' ] . items(): \n             keys   =   key . split( \"|\" ) \n             self . basket[ShoppingCartItem(upc = keys[ 0 ],   title = keys[ 1 ])]   =   value   You are ready to initialize Yosai with shopping-cart enabled session management\ncapabilities.  Simply pass the serializable during Yosai initialization within\na list:       yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' , \n                   session_attributes = [ShoppingCart])   Here's one way you could interact with the shopping cart in your application using\nYosai session management:",
            "title": "Session Tutorial"
        },
        {
            "location": "/sessionmanagement/#shopping-cart-manager",
            "text": "class   ShoppingCartSessionManager : \n\n     @staticmethod \n     def   list_items (session): \n         shopping_cart   =   session . get_attribute( 'shopping_cart' ) \n         if   shopping_cart: \n             return   shopping_cart . items() \n         return   None \n\n     @staticmethod \n     def   add_item (session,   item,   quantity = 1 ): \n         \"\"\"          :param item: a ShoppingCartItem namedtuple          \"\"\" \n         shopping_cart   =   session . get_attribute( 'shopping_cart' ) \n         if   shopping_cart: \n             shopping_cart . add_item(item,   quantity) \n         else : \n             shopping_cart   =   ShoppingCart() \n         session . set_attribute( 'shopping_cart' ,   shopping_cart) \n\n\n     @staticmethod \n     def   remove_item (session,   item): \n         shopping_cart   =   session . get_attribute( 'shopping_cart' ) \n         if   shopping_cart: \n             shopping_cart . remove_item(item) \n             session . set_attribute( 'shopping_cart' ,   shopping_cart)   Let's now see all of our objects in action. We'll add items to the shopping cart\nand then remove one.",
            "title": "Shopping Cart Manager"
        },
        {
            "location": "/sessionmanagement/#operation-1-add-four-items-to-the-shopping-cart",
            "text": "yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' , \n                   session_attributes = [ShoppingCart]) \n\n     cart   =   ShoppingCartSessionManager \n\n     with   Yosai . context(yosai): \n       subject   =   Yosai . get_current_subject() \n       session   =   subject . get_session() \n\n       # could easily use functools.partial for this, but keeping it explicit \n       # for the example so as to not confuse: \n       cart . add_item(session,   '0043000200216' ,   4 ) \n       cart . add_item(session,   '016000119772' ,   1 ) \n       cart . add_item(session,   '52159012038' ,   3 ) \n       cart . add_item(session,   '00028400028196' ,   1 ) \n\n       cart . list_items(session)",
            "title": "Operation 1:  Add four items to the shopping cart"
        },
        {
            "location": "/sessionmanagement/#operation-2-remove-an-item-from-the-shopping-cart",
            "text": "yosai   =   Yosai(env_var = 'YOSAI_SETTINGS' , \n                   session_attributes = [ShoppingCart]) \n\n     cart   =   ShoppingCartSessionManager(session) \n\n     with   Yosai . context(yosai): \n       subject   =   Yosai . get_current_subject() \n       session   =   subject . get_session() \n\n       cart . remove_item(session,   '00028400028196' ) \n\n       cart . list_items(session)",
            "title": "Operation 2:  Remove an item from the shopping cart"
        },
        {
            "location": "/sessionmanagement/#here-is-a-fully-working-example-of-the-code-shared-above",
            "text": "",
            "title": "Here is a fully working example of the code shared above."
        },
        {
            "location": "/sessionmanagement/#references",
            "text": "OWASP Session Management CheatSheet",
            "title": "References"
        },
        {
            "location": "/events/",
            "text": "Event-Driven Architecture\n\n\n\n\nYosai features an event-driven architecture where events emitted during\nauthentication, authorization, and session management trigger subsequent\nprocessing.\n\n\nEvents are communicated using a publish-subscribe paradigm.  An event publisher\nemits the event to a channel (an internal Event Bus) that relays the event to\nconsumers who have subscribed to the event's topic.  An EventBus singleton is\nshared throughout the running instance of Yosai, passed down from the SecurityManager.\n\n\n\n\nAn EventBus relays published events to event subscribers and provides a mechanism for\nregistering and unregistering event subscribers. With this pubsub paradigm,\ncomponents can publish or consume events without tightly coupling consumers to\nproducers.  This promotes flexibility through loose coupling and high cohesion\nbetween components, leading to a more pluggable architecture.\n\n\nSending Events\n\n\nIf a component wishes to publish events to other components:\n\nevent_bus.publish(topic, *kwargs)\n\n\nThe event bus dispatches the event 'message' to components that wish to receive\nevents of that type (known as subscribers).\n\n\nReceiving Events\n\n\nA component can receive events of interest by doing the following.\n\n\nFor each event topic you wish to consume, create a callback method\nthat will be called when an specific type of event is communicated across\nthe event bus.  Register the callback with the event_bus:\n\nevent_bus.register(topic, callback)\n\n\nEvent Schedule\n\n\nThe following table lists the Events that are used in Yosai, who the\npublisher of an event is, and who the subscriber(s) are:\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nPublisher\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nSESSION.START\n\n\nSEH\n\n\nEL\n\n\n\n\n\n\nSESSION.STOP\n\n\nSEH\n\n\nMRA, EL\n\n\n\n\n\n\nSESSION.EXPIRE\n\n\nSEH\n\n\nMRA, EL\n\n\n\n\n\n\nAUTHENTICATION.SUCCEEDED\n\n\nDA\n\n\nMRA, EL\n\n\n\n\n\n\nAUTHENTICATION.FAILED\n\n\nDA\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.GRANTED\n\n\nMRA\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.DENIED\n\n\nMRA\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.RESULTS\n\n\nMRA\n\n\nEL\n\n\n\n\n\n\n\n\n\n\nDA = \nyosai.core.authc.authc.DefaultAuthenticator\n\n\nEL = \nyosai.core.event.event.EventLogger\n\n\nMRA = \nyosai.core.authz.authz.ModularRealmAuthorizer\n\n\nSEH = \nyosai.core.session.session.SessionEventHandler\n\n\n\n\nEvent Logging\n\n\n\n\nCommunicating events in a structured format facilitates processing of log\nentries by systems independent of Yosai.  Therefore, events are\nlogged in a structured format by reducing event payloads to their serializable\nform.\n\n\nYosai includes an optional logging module that features JSON encoded formatting.\n\nIt is highly recommended that you use this feature or one like it to benefit by\nstructured logging.",
            "title": "Event Processing"
        },
        {
            "location": "/events/#event-driven-architecture",
            "text": "Yosai features an event-driven architecture where events emitted during\nauthentication, authorization, and session management trigger subsequent\nprocessing.  Events are communicated using a publish-subscribe paradigm.  An event publisher\nemits the event to a channel (an internal Event Bus) that relays the event to\nconsumers who have subscribed to the event's topic.  An EventBus singleton is\nshared throughout the running instance of Yosai, passed down from the SecurityManager.   An EventBus relays published events to event subscribers and provides a mechanism for\nregistering and unregistering event subscribers. With this pubsub paradigm,\ncomponents can publish or consume events without tightly coupling consumers to\nproducers.  This promotes flexibility through loose coupling and high cohesion\nbetween components, leading to a more pluggable architecture.",
            "title": "Event-Driven Architecture"
        },
        {
            "location": "/events/#sending-events",
            "text": "If a component wishes to publish events to other components: event_bus.publish(topic, *kwargs)  The event bus dispatches the event 'message' to components that wish to receive\nevents of that type (known as subscribers).",
            "title": "Sending Events"
        },
        {
            "location": "/events/#receiving-events",
            "text": "A component can receive events of interest by doing the following.  For each event topic you wish to consume, create a callback method\nthat will be called when an specific type of event is communicated across\nthe event bus.  Register the callback with the event_bus: event_bus.register(topic, callback)",
            "title": "Receiving Events"
        },
        {
            "location": "/events/#event-schedule",
            "text": "The following table lists the Events that are used in Yosai, who the\npublisher of an event is, and who the subscriber(s) are:     Event Topic  Publisher  Subscriber(s)      SESSION.START  SEH  EL    SESSION.STOP  SEH  MRA, EL    SESSION.EXPIRE  SEH  MRA, EL    AUTHENTICATION.SUCCEEDED  DA  MRA, EL    AUTHENTICATION.FAILED  DA  EL    AUTHORIZATION.GRANTED  MRA  EL    AUTHORIZATION.DENIED  MRA  EL    AUTHORIZATION.RESULTS  MRA  EL      DA =  yosai.core.authc.authc.DefaultAuthenticator  EL =  yosai.core.event.event.EventLogger  MRA =  yosai.core.authz.authz.ModularRealmAuthorizer  SEH =  yosai.core.session.session.SessionEventHandler",
            "title": "Event Schedule"
        },
        {
            "location": "/events/#event-logging",
            "text": "Communicating events in a structured format facilitates processing of log\nentries by systems independent of Yosai.  Therefore, events are\nlogged in a structured format by reducing event payloads to their serializable\nform.  Yosai includes an optional logging module that features JSON encoded formatting. \nIt is highly recommended that you use this feature or one like it to benefit by\nstructured logging.",
            "title": "Event Logging"
        },
        {
            "location": "/serialization/",
            "text": "Serialization\n\n\nYosai serializes objects when caching and when saving 'Remember Me' information.\n\n\nThe serialization process is as follows:\n\n\n\n\n\n\nReduce the state of a Yosai object to its primitive form (marshalling)\n\n\nEnrich the marshalled payload with metadata\n\n\nEncode the metadata-enriched payload\n\n\n\n\nasphalt.serialization\n\n\n\n\nYosai uses a forked copy of the Asphalt framework's serialization library to reduce\ncustom classes to a primitive form that can be serialized. Asphalt is an asyncio based microframework for network oriented applications and it has a great serialization\nlibrary.  If you would like to learn more about Asphalt, \nclick here\n.\n\n\nSerializables\n\n\nClasses in yosai.core and yosai.web that inherit from the \nSerializable\n abstract\nbase class are eligible for serialization in Yosai.  A Serializable class has its\nown marshalling methods, \ngetstate\n and \nsetstate\n, to control what gets\n(de)serialized and how.  These methods aren't \nrequired\n unless transformation is\nnecessary to accommodate the limitations of types supported by serialization\nlibraries.  In other words, a serializer can marshall based on an object's \ndict\n,\nwithout marshalling guidance if transformation isn't required.  However, since\nYosai is used for security purposes it is prudent to maintain tighter control\nover serialization.\n\n\nExamples\n\n\nTo understand how to reduce objects, you are encouraged to review the\nserialization source code of the \nSerializable\n classes in Yosai.  The\nfollowing classes are recommended for their diversity:\n\n\n\n\nauthz.authz.IndexedAuthorizationInfo\n\n\nsubject.identifier.SimpleIndentifierCollection\n\n\nsession.session.SimpleSession\n\n\nauthz.authz.WildcardPermission\n\n\n\n\nSerialization Manager\n\n\nA \nSerializationManager\n orchestrates the serialization process.  It is indended for your caching library, wrapping \"setters\" with serialization and \"getters\" with deserialization.\n\n\nFor instance, the Yosai extension, \nYosai DPCache\n, obtains a SerializationManager instance during its CacheHandler initialization process.  The \nSerializationManager\n proxies all cache communication.",
            "title": "Serialization"
        },
        {
            "location": "/serialization/#serialization",
            "text": "Yosai serializes objects when caching and when saving 'Remember Me' information.  The serialization process is as follows:    Reduce the state of a Yosai object to its primitive form (marshalling)  Enrich the marshalled payload with metadata  Encode the metadata-enriched payload",
            "title": "Serialization"
        },
        {
            "location": "/serialization/#asphaltserialization",
            "text": "Yosai uses a forked copy of the Asphalt framework's serialization library to reduce\ncustom classes to a primitive form that can be serialized. Asphalt is an asyncio based microframework for network oriented applications and it has a great serialization\nlibrary.  If you would like to learn more about Asphalt,  click here .",
            "title": "asphalt.serialization"
        },
        {
            "location": "/serialization/#serializables",
            "text": "Classes in yosai.core and yosai.web that inherit from the  Serializable  abstract\nbase class are eligible for serialization in Yosai.  A Serializable class has its\nown marshalling methods,  getstate  and  setstate , to control what gets\n(de)serialized and how.  These methods aren't  required  unless transformation is\nnecessary to accommodate the limitations of types supported by serialization\nlibraries.  In other words, a serializer can marshall based on an object's  dict ,\nwithout marshalling guidance if transformation isn't required.  However, since\nYosai is used for security purposes it is prudent to maintain tighter control\nover serialization.",
            "title": "Serializables"
        },
        {
            "location": "/serialization/#examples",
            "text": "To understand how to reduce objects, you are encouraged to review the\nserialization source code of the  Serializable  classes in Yosai.  The\nfollowing classes are recommended for their diversity:   authz.authz.IndexedAuthorizationInfo  subject.identifier.SimpleIndentifierCollection  session.session.SimpleSession  authz.authz.WildcardPermission",
            "title": "Examples"
        },
        {
            "location": "/serialization/#serialization-manager",
            "text": "A  SerializationManager  orchestrates the serialization process.  It is indended for your caching library, wrapping \"setters\" with serialization and \"getters\" with deserialization.  For instance, the Yosai extension,  Yosai DPCache , obtains a SerializationManager instance during its CacheHandler initialization process.  The  SerializationManager  proxies all cache communication.",
            "title": "Serialization Manager"
        },
        {
            "location": "/architecture/",
            "text": "Architectural Overview\n\n\nThe following diagram depicts Yosai's architecture. Note that only \none\n\nRealm is provided with \nyosai.core\n but others are shown to illustrate support for multiple realms (and their respective AccountStore).\n\n\n\n\nSubject\n\n\nA \nSubject\n represents state and security operations for a \nsingle\n\napplication user.  These operations include authentication (login/logout),\nauthorization (access control), and session access. A subject is Yosai's\nprimary mechanism for single-user security functionality.\n\n\nSecurity Manager\n\n\nA \nSecurityManager\n executes ALL security operations for ALL Subjects (aka users) across a single application.\n\n\nThe interface itself primarily exists as a convenience - it extends the\nAuthenticator, Authorizer, and SessionManager interfaces, thereby\nconsolidating these behaviors into a single point of reference.  For most\nYosai usages, this simplifies configuration and tends to be a more\nconvenient approach than referencing Authenticator, Authorizer, and\nSessionManager instances individually.  Instead, one only needs to interact\nwith a single SecurityManager instance.\n\n\nIn addition to the above three interfaces, this interface provides a number\nof methods supporting the behavior of Subject(s). A Subject executes\nauthentication, authorization, and session operations for a \nsingle\n user,\nand as such can only be managed by A SecurityManager that is aware of all\nthree functions.  The three parent interfaces on the other hand do not\n'know' about Subject(s) so as to ensure a clean separation of concerns.\n\n\nAuthenticator\n\n\nAn \nAuthenticator\n performs authentication for any given Subject (aka 'application user').  It uses an authentication strategy to coordinate authentication among one or more realms configured for authentication.\n\n\nAuthorizer\n\n\nAn \nAuthorizer\n performs authorization (access control) operations for any given Subject (aka 'application user').  It coordinates authorization requests among one or more realms configured for authorization.\n\n\nRealm\n\n\nA \nRealm\n access application-specific security entities such as accounts,\nroles, and permissions to perform authentication and authorization operations.\n\n\nRealms\n usually have a 1-to-1 relationship with an \nAccountStore\n,\nsuch as a NoSQL or relational database, file system, or other similar resource.\nHowever, since most Realm implementations are nearly identical, except for\nthe account query logic, a default realm implementation, \nAccountStoreRealm\n,\nis provided, allowing you to configure it with the data API-specific\n\nAccountStore\n instance.\n\n\nBecause most account stores usually contain Subject information such as\nusernames and passwords, a Realm can act as a pluggable authentication module in a \nPAM configuration\n\n.  This allows a Realm to perform \nboth\n authentication and authorization duties for a single account store, catering to most application needs.  If for some reason you don't want your Realm implementation to participate in authentication, override the \nsupports(authc_token)\n method to always return False.\n\n\nBecause every application is different, security data such as users and roles can be represented in any number of ways.  Yosai tries to maintain a non-intrusive development philosophy whenever possible -- it does not require you to implement or extend any \nUser\n, \nGroup\n or \nRole\n interfaces or classes.\n\n\nInstead, Yosai allows applications to implement this interface to access environment-specific account stores and data model objects.  The implementation can then be plugged in to the application's Yosai configuration. This modular technique abstracts away any environment/modeling details and allows Yosai to be deployed in practically any application environment.\n\n\nMost users will not implement this \nRealm\n interface directly, but will\ninstead use an \nAccountStoreRealm\n instance configured with an underlying\n\nAccountStore\n. This setup implies that there is an \nAccountStoreRealm\n\ninstance per \nAccountStore\n that the application needs to access.\n\n\nYosai introduces two Realm interfaces in order to separate authentication\nand authorization responsibilities.\n\n\nStore\n\n\nA \nStore\n is a data repository.  Yosai uses an \nAccountStore\n, specifically.  An \nAccountStore\n contains \nAccount\n information, such as credentials, roles, and permissions.\n\n\nCacheHandler\n\n\nA \nCacheHandler\n provides an abstraction on top of an underlying caching mechanism, such as \nyosai_dpcache\n, managing key generation and cache region interactions.\n\n\nEventBus\n\n\nAn \nEventbus\n can publish events to event subscribers as well as provide a\nmechanism for registering and unregistering event subscribers.\n\n\nAn event bus enables a publish/subscribe paradigm within Yosai -- components can publish or consume events they find relevant without needing to be tightly coupled to other components.",
            "title": "Architecture Overview"
        },
        {
            "location": "/architecture/#architectural-overview",
            "text": "The following diagram depicts Yosai's architecture. Note that only  one \nRealm is provided with  yosai.core  but others are shown to illustrate support for multiple realms (and their respective AccountStore).",
            "title": "Architectural Overview"
        },
        {
            "location": "/architecture/#subject",
            "text": "A  Subject  represents state and security operations for a  single \napplication user.  These operations include authentication (login/logout),\nauthorization (access control), and session access. A subject is Yosai's\nprimary mechanism for single-user security functionality.",
            "title": "Subject"
        },
        {
            "location": "/architecture/#security-manager",
            "text": "A  SecurityManager  executes ALL security operations for ALL Subjects (aka users) across a single application.  The interface itself primarily exists as a convenience - it extends the\nAuthenticator, Authorizer, and SessionManager interfaces, thereby\nconsolidating these behaviors into a single point of reference.  For most\nYosai usages, this simplifies configuration and tends to be a more\nconvenient approach than referencing Authenticator, Authorizer, and\nSessionManager instances individually.  Instead, one only needs to interact\nwith a single SecurityManager instance.  In addition to the above three interfaces, this interface provides a number\nof methods supporting the behavior of Subject(s). A Subject executes\nauthentication, authorization, and session operations for a  single  user,\nand as such can only be managed by A SecurityManager that is aware of all\nthree functions.  The three parent interfaces on the other hand do not\n'know' about Subject(s) so as to ensure a clean separation of concerns.",
            "title": "Security Manager"
        },
        {
            "location": "/architecture/#authenticator",
            "text": "An  Authenticator  performs authentication for any given Subject (aka 'application user').  It uses an authentication strategy to coordinate authentication among one or more realms configured for authentication.",
            "title": "Authenticator"
        },
        {
            "location": "/architecture/#authorizer",
            "text": "An  Authorizer  performs authorization (access control) operations for any given Subject (aka 'application user').  It coordinates authorization requests among one or more realms configured for authorization.",
            "title": "Authorizer"
        },
        {
            "location": "/architecture/#realm",
            "text": "A  Realm  access application-specific security entities such as accounts,\nroles, and permissions to perform authentication and authorization operations.  Realms  usually have a 1-to-1 relationship with an  AccountStore ,\nsuch as a NoSQL or relational database, file system, or other similar resource.\nHowever, since most Realm implementations are nearly identical, except for\nthe account query logic, a default realm implementation,  AccountStoreRealm ,\nis provided, allowing you to configure it with the data API-specific AccountStore  instance.  Because most account stores usually contain Subject information such as\nusernames and passwords, a Realm can act as a pluggable authentication module in a  PAM configuration \n.  This allows a Realm to perform  both  authentication and authorization duties for a single account store, catering to most application needs.  If for some reason you don't want your Realm implementation to participate in authentication, override the  supports(authc_token)  method to always return False.  Because every application is different, security data such as users and roles can be represented in any number of ways.  Yosai tries to maintain a non-intrusive development philosophy whenever possible -- it does not require you to implement or extend any  User ,  Group  or  Role  interfaces or classes.  Instead, Yosai allows applications to implement this interface to access environment-specific account stores and data model objects.  The implementation can then be plugged in to the application's Yosai configuration. This modular technique abstracts away any environment/modeling details and allows Yosai to be deployed in practically any application environment.  Most users will not implement this  Realm  interface directly, but will\ninstead use an  AccountStoreRealm  instance configured with an underlying AccountStore . This setup implies that there is an  AccountStoreRealm \ninstance per  AccountStore  that the application needs to access.  Yosai introduces two Realm interfaces in order to separate authentication\nand authorization responsibilities.",
            "title": "Realm"
        },
        {
            "location": "/architecture/#store",
            "text": "A  Store  is a data repository.  Yosai uses an  AccountStore , specifically.  An  AccountStore  contains  Account  information, such as credentials, roles, and permissions.",
            "title": "Store"
        },
        {
            "location": "/architecture/#cachehandler",
            "text": "A  CacheHandler  provides an abstraction on top of an underlying caching mechanism, such as  yosai_dpcache , managing key generation and cache region interactions.",
            "title": "CacheHandler"
        },
        {
            "location": "/architecture/#eventbus",
            "text": "An  Eventbus  can publish events to event subscribers as well as provide a\nmechanism for registering and unregistering event subscribers.  An event bus enables a publish/subscribe paradigm within Yosai -- components can publish or consume events they find relevant without needing to be tightly coupled to other components.",
            "title": "EventBus"
        },
        {
            "location": "/web/",
            "text": "Web Integration\n\n\nThis section of documentation is dedicated to \nyosai.web\n.  \n\n\nWhen you install Yosai from PyPI (using the pip installer), you are installing\na package that includes \nyosai.core\n, featuring the framework and a \"native\"\nlibrary, and \nyosai.web\n, which extends \nyosai.core\n to support web applications.\n\n\nWeb development is so popular that it makes sense to include support for it\nfrom the main Yosai project package.  Further, this approach is consistent with that\ntaken by the Apache Shiro project.\n\n\nArchitectural Overview\n\n\nYosai enables web support by extending, through inheritance, a few of the key\ncomponents (and sub-components), in its architecture:\n\n\n\n\nThese components are extended to support interaction with a web-specific API, known\nas a \nWebRegistry\n API, that manages a web application's cookies\nused to track SessionID and RememberMe and manages other related attributes.\n\n\nWeb Registry API\n\n\nyosai.web\n is designed to integrate with any kind of web application. It can integrate\nwith any application framework, such as Django, Pyramid, Flask, or Bottle.  This is\nmade possible through application-specific implementations of the WebRegistry API.  \n\n\nThe WebRegistry API is an interface, specified by an abstract base class (like the\nrest of the interfaces defined in Yosai). For instance, a \npyramid_yosai\n integration\nconsists of a PyramidWebRegistry implementation, a \ndjango_yosai\n integration\nconsist of a DjangoWebRegistry, etc.\n\n\nInitializing Web-enabled Yosai\n\n\nInstantiating a web-enabled instance of Yosai follows the same process as\ninstantiating a native Yosai instance except that a WebYosai class is used\nrather than a Yosai class.  However, web-enabled classes are\nused instead of the yosai.core native classes.  These web-enabled classes are\nautomatically used by a WebSecurityManager.  So, all you need to do in order to\nmake use of the web-enabled classes is specify in Yosai's yaml settings file that\nthe WebSecurityManager is used:\n\n\nSECURITY_MANAGER_CONFIG:                                                       \n    security_manager: yosai.web.WebSecurityManager  \n\n\n\n\n\nfrom\n \nyosai.web\n \nimport\n \nWebYosai\n\n\n\nyosai\n \n=\n \nWebYosai(env_var\n=\n'YOSAI_SETTINGS'\n)\n\n\n\n\n\n\nUsing a Web-enabled Yosai\n\n\nTo secure web applications with Yosai, you open a WebYosai context in an early\nstage of a web request's lifecycle, prior to calling views.  The context is\npassed two parameters-- a \nWebYosai\n instance and \nWebRegistry\n instance:\n\n\nweb_registry\n \n=\n \nxxxWebRegistry(request)\n\n\n\nwith\n \nWebYosai\n.\ncontext(yosai,\n \nweb_registry):\n\n    \nresponse\n \n=\n \nhandle(request)\n  \n# just an example of request hooking..\n\n\n\n\n\n\nA \nWebRegistry\n is specific to a web application implementation.  Consequently,\na \nWebRegistry\n must be created for each web framework / application used.\n\nFor instance, a \nPyramidWebRegistry\n is used when integrating Yosai with\napplications created with the Pyramid Web Framework.  In the example above,\n'xxx' is a placeholder for whatever specific web registry you use.\n\n\nMiddleware Support:  TBD\n\n\nYosai does not yet include any WSGI middleware ports of Apache Shiro's servlet\nrelated functionality.  Pull requests are welcome.",
            "title": "Web Integration"
        },
        {
            "location": "/web/#web-integration",
            "text": "This section of documentation is dedicated to  yosai.web .    When you install Yosai from PyPI (using the pip installer), you are installing\na package that includes  yosai.core , featuring the framework and a \"native\"\nlibrary, and  yosai.web , which extends  yosai.core  to support web applications.  Web development is so popular that it makes sense to include support for it\nfrom the main Yosai project package.  Further, this approach is consistent with that\ntaken by the Apache Shiro project.",
            "title": "Web Integration"
        },
        {
            "location": "/web/#architectural-overview",
            "text": "Yosai enables web support by extending, through inheritance, a few of the key\ncomponents (and sub-components), in its architecture:   These components are extended to support interaction with a web-specific API, known\nas a  WebRegistry  API, that manages a web application's cookies\nused to track SessionID and RememberMe and manages other related attributes.",
            "title": "Architectural Overview"
        },
        {
            "location": "/web/#web-registry-api",
            "text": "yosai.web  is designed to integrate with any kind of web application. It can integrate\nwith any application framework, such as Django, Pyramid, Flask, or Bottle.  This is\nmade possible through application-specific implementations of the WebRegistry API.    The WebRegistry API is an interface, specified by an abstract base class (like the\nrest of the interfaces defined in Yosai). For instance, a  pyramid_yosai  integration\nconsists of a PyramidWebRegistry implementation, a  django_yosai  integration\nconsist of a DjangoWebRegistry, etc.",
            "title": "Web Registry API"
        },
        {
            "location": "/web/#initializing-web-enabled-yosai",
            "text": "Instantiating a web-enabled instance of Yosai follows the same process as\ninstantiating a native Yosai instance except that a WebYosai class is used\nrather than a Yosai class.  However, web-enabled classes are\nused instead of the yosai.core native classes.  These web-enabled classes are\nautomatically used by a WebSecurityManager.  So, all you need to do in order to\nmake use of the web-enabled classes is specify in Yosai's yaml settings file that\nthe WebSecurityManager is used:  SECURITY_MANAGER_CONFIG:                                                       \n    security_manager: yosai.web.WebSecurityManager    from   yosai.web   import   WebYosai  yosai   =   WebYosai(env_var = 'YOSAI_SETTINGS' )",
            "title": "Initializing Web-enabled Yosai"
        },
        {
            "location": "/web/#using-a-web-enabled-yosai",
            "text": "To secure web applications with Yosai, you open a WebYosai context in an early\nstage of a web request's lifecycle, prior to calling views.  The context is\npassed two parameters-- a  WebYosai  instance and  WebRegistry  instance:  web_registry   =   xxxWebRegistry(request)  with   WebYosai . context(yosai,   web_registry): \n     response   =   handle(request)    # just an example of request hooking..   A  WebRegistry  is specific to a web application implementation.  Consequently,\na  WebRegistry  must be created for each web framework / application used. \nFor instance, a  PyramidWebRegistry  is used when integrating Yosai with\napplications created with the Pyramid Web Framework.  In the example above,\n'xxx' is a placeholder for whatever specific web registry you use.",
            "title": "Using a Web-enabled Yosai"
        },
        {
            "location": "/web/#middleware-support-tbd",
            "text": "Yosai does not yet include any WSGI middleware ports of Apache Shiro's servlet\nrelated functionality.  Pull requests are welcome.",
            "title": "Middleware Support:  TBD"
        },
        {
            "location": "/devstatus/",
            "text": "Testing Status\n\n\nIn Progress\n\n\nAs of Sept 2016, focus is on creating support for 2-Factor Authentication (2FA),\nwith special emphasis on One-Time Passwords (OTP) using secure devices such as \nNitrokey\n.\n\n\nRelease Notes\n\n\nRelease v0.2 (Sept 2016)\n\n\n\n\nYosai can be integrated with any web application now that yosai.web development\nand testing is complete.  The first web integration released is \npyramid_yosai\n.\n\n\nAll authc and authz decorators are now accessible through a common interface.\n\n\nYosai's SecurityManager is now created entirely from framework configuration\n  settings.\n\n\nSerialization was dramatically changed, replacing Marshmallow with a forked\ninstance of Asphalt serialization.  These changes yielded \ndramatic\n improvements\nin performance, ease of use, and type support.",
            "title": "Development Status"
        },
        {
            "location": "/devstatus/#testing-status",
            "text": "",
            "title": "Testing Status"
        },
        {
            "location": "/devstatus/#in-progress",
            "text": "As of Sept 2016, focus is on creating support for 2-Factor Authentication (2FA),\nwith special emphasis on One-Time Passwords (OTP) using secure devices such as  Nitrokey .",
            "title": "In Progress"
        },
        {
            "location": "/devstatus/#release-notes",
            "text": "",
            "title": "Release Notes"
        },
        {
            "location": "/devstatus/#release-v02-sept-2016",
            "text": "Yosai can be integrated with any web application now that yosai.web development\nand testing is complete.  The first web integration released is  pyramid_yosai .  All authc and authz decorators are now accessible through a common interface.  Yosai's SecurityManager is now created entirely from framework configuration\n  settings.  Serialization was dramatically changed, replacing Marshmallow with a forked\ninstance of Asphalt serialization.  These changes yielded  dramatic  improvements\nin performance, ease of use, and type support.",
            "title": "Release v0.2 (Sept 2016)"
        },
        {
            "location": "/library/",
            "text": "Extensions and Integrations\n\n\n\n\nThe mission of The Yosai Project is to secure any kind of Python application.\nExtensions and integrations are added in piecemeal to the Yosai framework to\ncreate the ideal security stack necessary for your application.  You specify\nwhich components to use from within Yosai's yaml settings file.\n\n\nExtensions\n\n\nAs illustrated, Yosai consists of a core library.  To provide a complete security solution for applications, the core library uses \nextensions\n -- components that extend operations enabled by the core.  Examples of extensions include:\n- credentials repositories such as relational databases or LDAP directories\n- access control policies residing in data sources such as relational databases\n- authentication methodologies such as social-media based authentication or\n  multi-factor authentication\n- caching mechanisms\n\n\nIntegrations\n\n\nYosai is designed to provide security related functionality in such a way that\nit can be used with ANY kind of application, including desktop apps, web apps,\ninternet-enabled devices, etc.\n\n\nYosai is adapted to an application through what is known as an \nintegration\n\nlibrary.\n\n\nSince a large number of applications are web-based applications, a\nlibrary, yosai.web, is included.  Integrations are created to adopt yosai.web\ncomponents to a specific web application.  For instance, the pyramid_yosai\nproject integrates yosai with the Pyramid Web Framework.\n\n\nDevelopers are encouraged to submit to The Yosai Project integrations for\nlicense-compatible projects.\n\n\n\n\nYosai is being released with \"batteries included\" so that it may be used in a\nproject without requiring additional implementation (for quick starts).  To achieve this goal, two integration projects were added to The Yosai Project, providing access to a peristence layer and caching:\n\n\nYosai AlchemyStore\n\n\nAn AccountStore implemented with SQLAlchemy.  The project includes a\nbasic RBAC data model that uses a flat, non-heirarchical design.  \n\n\nYosai DPCache\n\n\nThis is an integration of the dogpile.cache project.  Yosai reduces objects\nto their serializable form using Marshmallow, encodes them, and then caches.\nObjects obtained from cache are de-serialized into reduced form and then\nre-materialized into Yosai objects.  dogpile.cache supports Redis, Memcached,\nand Riak off the shelf, featuring thread-safe asynchronous interaction using a\ndogpile lock mechanism.  A \u201cdogpile\u201d lock is one that allows a single thread to\ngenerate an expensive resource while other threads use the \u201cold\u201d value until\nthe \u201cnew\u201d value is ready.\n\n\nCurrently, only the Redis backend has been updated and tested.  If you would like to add other backends, your pull request is welcome.  \n\n\nPyramid Yosai\n\n\nThis library\n integrates Yosai with the \nPyramid Web Framework\n.\nA fully functional demo project, \nMonsterRx\n, was\ncreated to show how to use pyramid_yosai and highlights some of Yosai's key features.",
            "title": "Library"
        },
        {
            "location": "/library/#extensions-and-integrations",
            "text": "The mission of The Yosai Project is to secure any kind of Python application.\nExtensions and integrations are added in piecemeal to the Yosai framework to\ncreate the ideal security stack necessary for your application.  You specify\nwhich components to use from within Yosai's yaml settings file.",
            "title": "Extensions and Integrations"
        },
        {
            "location": "/library/#extensions",
            "text": "As illustrated, Yosai consists of a core library.  To provide a complete security solution for applications, the core library uses  extensions  -- components that extend operations enabled by the core.  Examples of extensions include:\n- credentials repositories such as relational databases or LDAP directories\n- access control policies residing in data sources such as relational databases\n- authentication methodologies such as social-media based authentication or\n  multi-factor authentication\n- caching mechanisms",
            "title": "Extensions"
        },
        {
            "location": "/library/#integrations",
            "text": "Yosai is designed to provide security related functionality in such a way that\nit can be used with ANY kind of application, including desktop apps, web apps,\ninternet-enabled devices, etc.  Yosai is adapted to an application through what is known as an  integration \nlibrary.  Since a large number of applications are web-based applications, a\nlibrary, yosai.web, is included.  Integrations are created to adopt yosai.web\ncomponents to a specific web application.  For instance, the pyramid_yosai\nproject integrates yosai with the Pyramid Web Framework.  Developers are encouraged to submit to The Yosai Project integrations for\nlicense-compatible projects.   Yosai is being released with \"batteries included\" so that it may be used in a\nproject without requiring additional implementation (for quick starts).  To achieve this goal, two integration projects were added to The Yosai Project, providing access to a peristence layer and caching:",
            "title": "Integrations"
        },
        {
            "location": "/library/#yosai-alchemystore",
            "text": "An AccountStore implemented with SQLAlchemy.  The project includes a\nbasic RBAC data model that uses a flat, non-heirarchical design.",
            "title": "Yosai AlchemyStore"
        },
        {
            "location": "/library/#yosai-dpcache",
            "text": "This is an integration of the dogpile.cache project.  Yosai reduces objects\nto their serializable form using Marshmallow, encodes them, and then caches.\nObjects obtained from cache are de-serialized into reduced form and then\nre-materialized into Yosai objects.  dogpile.cache supports Redis, Memcached,\nand Riak off the shelf, featuring thread-safe asynchronous interaction using a\ndogpile lock mechanism.  A \u201cdogpile\u201d lock is one that allows a single thread to\ngenerate an expensive resource while other threads use the \u201cold\u201d value until\nthe \u201cnew\u201d value is ready.  Currently, only the Redis backend has been updated and tested.  If you would like to add other backends, your pull request is welcome.",
            "title": "Yosai DPCache"
        },
        {
            "location": "/library/#pyramid-yosai",
            "text": "This library  integrates Yosai with the  Pyramid Web Framework .\nA fully functional demo project,  MonsterRx , was\ncreated to show how to use pyramid_yosai and highlights some of Yosai's key features.",
            "title": "Pyramid Yosai"
        },
        {
            "location": "/community/",
            "text": "Community Discussion\n\n\nGoogle Groups\n\n\nMailing List:  https://groups.google.com/d/forum/yosai",
            "title": "Community"
        },
        {
            "location": "/community/#community-discussion",
            "text": "",
            "title": "Community Discussion"
        },
        {
            "location": "/community/#google-groups",
            "text": "Mailing List:  https://groups.google.com/d/forum/yosai",
            "title": "Google Groups"
        },
        {
            "location": "/contributing/",
            "text": "How to Contribute to the Yosai Project\n\n\nThere are many ways you can contribute to the Yosai Project, from bug identification\nto refactoring, writing extensions or creating integrations.  It is important \nthat our working environment be friendly and welcoming to all potential contributors.\n\nWith that given, you are to abide by some simple guidelines outlined in the \n\nCode of Conduct\n.\n\n\nEasy Ways to Contribute\n\n\nThe Yosai community has a Google Group.  The \nCommunity page\n i\nhas more information about that.\n\n\nIf you want to file a bug report, suggest a feature, or ask a code-related\nquestion, please go to the \nyosaiproject/yosai\n repository on GitHub and\n\ncreate a new Issue\n. (You\nwill need a \nGitHub account\n (free).) Please\ndescribe the issue clearly, including steps to reproduce when you report a bug.\n\n\nHow to Contribute Code or Documentation\n\n\nStep 0 - Prepare and Familiarize Yourself\n\n\nTo contribute code or documentation, you need a \nGitHub account\n.\n\n\nFamiliarize yourself with Yosai's coding convention, architecture, and documentation \n including:\n\n\n\n\ntesting requirements\n\n\ndocumentation strategy\n\n\nsemantic versioning\n\n\n\n\nStep 1 - Fork yosai on GitHub\n\n\nIn your web browser, go to \nthe Yosai repository on GitHub\n \nand click the \nFork\n button in the top right corner. This creates a new Git \nrepository named \nyosai\n in \nyour\n GitHub account.\n\n\nStep 2 - Clone Your Fork\n\n\n(This only has to be done once.) In your local terminal, use Git to clone \nyour\n \n\nyosai\n repository to your local computer. Also add the original GitHub \nyosaiproject/yosai repository as a remote named \nupstream\n (a convention):\n\n\ngit clone git@github.com:your-github-username/yosai.git\n\ncd\n yosai\ngit add upstream git@github.com:yosaiproject/yosai.git\n\n\n\n\n\nStep 3 - Fetch and Merge the Latest from \nupstream/develop\n\n\nSwitch to the \ndevelop\n branch locally, fetch all \nupstream\n branches, and\nmerge the just-fetched \nupstream/develop\n branch with the local \ndevelop\n\nbranch: \n\n\ngit checkout develop\ngit fetch upstream\ngit merge upstream/develop\n\n\n\n\n\nStep 4 - Create a New Branch for Each Bug/Feature\n\n\nIf your new branch is to \nfix a bug\n identified in a specific GitHub Issue \nwith number \nISSNO\n, then name your new branch \nbug/ISSNO/short-description-here\n. \nFor example, \nbug/12/fix-password-salt-format\n.\n\n\nIf your new branch is to \nadd a feature\n requested in a specific GitHub Issue\nwith number \nISSNO\n, then name your new branch \nfeat/ISSNO/short-description-here\n. \nFor example, \nfeat/237/multi-factor-authentication\n.\n\n\nOtherwise, please give your new branch a short, descriptive, all-lowercase name.\n\n\ngit checkout -b new-branch-name\n\n\n\n\n\nStep 5 - Make Edits, git add, git commit\n\n\nWith your new branch checked out locally, make changes or additions to the code\nor documentation, git add them, and git commit them.  \n\n\ngit add new-or-changed-file\ngit commit -m \n\"Short description of new or changed things\"\n\n\n\n\n\n\nRemember to write tests for new code, including unit (isolated) tests and \nintegrated tests.  Target a unit test coverage ratio of 90% tested.  Test\ncoverage of less than 90% affected source code will be scrutinized and potentially \nrejected.\n\n\nPlease run all existing tests to make sure you didn't break something.  Tox\nis provided to help you run tests.\n\n\nRemember to write or modify documentation to reflect your additions or changes.\n\n\nYou will want to merge changes from upstream (i.e. the original repository)\ninto your new branch from time to time, using something like: \n\n\ngit fetch upstream\ngit merge upstream/develop\n\n\n\n\n\nStep 6 - Push Your New Branch to origin\n\n\nEnsure that you've \ncommited\n all that you want to include in your pull request. \nThen push your new branch to origin (i.e. \nyour\n remote yosai repository).\n\n\ngit push origin new-branch-name\n\n\n\n\n\nStep 7 - Create a Pull Request\n\n\nGo to the GitHub website and to \nyour\n remote yosai repository (i.e. something \nlike https://github.com/your-user-name/yosai). \n\n\nSee [GitHub's documentation on how to initiate and send a pull request]\n(https://help.github.com/articles/using-pull-requests/). Note that the\ndestination repository should be \nyosaiproject/yosai\n and the destination\nbranch will typically be \ndevelop\n.\n\n\nSend the pull request.\n\n\nSomeone will then merge your branch or suggest changes. If we suggest changes,\nyou won't have to open a new pull request, you can just push new code to the\nsame branch (on \norigin\n) as you did before creating the pull request.\n\n\nQuick Links\n\n\n\n\nGeneral GitHub Documentation\n\n\nCode of Conduct",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#how-to-contribute-to-the-yosai-project",
            "text": "There are many ways you can contribute to the Yosai Project, from bug identification\nto refactoring, writing extensions or creating integrations.  It is important \nthat our working environment be friendly and welcoming to all potential contributors. \nWith that given, you are to abide by some simple guidelines outlined in the  Code of Conduct .",
            "title": "How to Contribute to the Yosai Project"
        },
        {
            "location": "/contributing/#easy-ways-to-contribute",
            "text": "The Yosai community has a Google Group.  The  Community page  i\nhas more information about that.  If you want to file a bug report, suggest a feature, or ask a code-related\nquestion, please go to the  yosaiproject/yosai  repository on GitHub and create a new Issue . (You\nwill need a  GitHub account  (free).) Please\ndescribe the issue clearly, including steps to reproduce when you report a bug.",
            "title": "Easy Ways to Contribute"
        },
        {
            "location": "/contributing/#how-to-contribute-code-or-documentation",
            "text": "",
            "title": "How to Contribute Code or Documentation"
        },
        {
            "location": "/contributing/#step-0-prepare-and-familiarize-yourself",
            "text": "To contribute code or documentation, you need a  GitHub account .  Familiarize yourself with Yosai's coding convention, architecture, and documentation \n including:   testing requirements  documentation strategy  semantic versioning",
            "title": "Step 0 - Prepare and Familiarize Yourself"
        },
        {
            "location": "/contributing/#step-1-fork-yosai-on-github",
            "text": "In your web browser, go to  the Yosai repository on GitHub  \nand click the  Fork  button in the top right corner. This creates a new Git \nrepository named  yosai  in  your  GitHub account.",
            "title": "Step 1 - Fork yosai on GitHub"
        },
        {
            "location": "/contributing/#step-2-clone-your-fork",
            "text": "(This only has to be done once.) In your local terminal, use Git to clone  your   yosai  repository to your local computer. Also add the original GitHub \nyosaiproject/yosai repository as a remote named  upstream  (a convention):  git clone git@github.com:your-github-username/yosai.git cd  yosai\ngit add upstream git@github.com:yosaiproject/yosai.git",
            "title": "Step 2 - Clone Your Fork"
        },
        {
            "location": "/contributing/#step-3-fetch-and-merge-the-latest-from-upstreamdevelop",
            "text": "Switch to the  develop  branch locally, fetch all  upstream  branches, and\nmerge the just-fetched  upstream/develop  branch with the local  develop \nbranch:   git checkout develop\ngit fetch upstream\ngit merge upstream/develop",
            "title": "Step 3 - Fetch and Merge the Latest from upstream/develop"
        },
        {
            "location": "/contributing/#step-4-create-a-new-branch-for-each-bugfeature",
            "text": "If your new branch is to  fix a bug  identified in a specific GitHub Issue \nwith number  ISSNO , then name your new branch  bug/ISSNO/short-description-here . \nFor example,  bug/12/fix-password-salt-format .  If your new branch is to  add a feature  requested in a specific GitHub Issue\nwith number  ISSNO , then name your new branch  feat/ISSNO/short-description-here . \nFor example,  feat/237/multi-factor-authentication .  Otherwise, please give your new branch a short, descriptive, all-lowercase name.  git checkout -b new-branch-name",
            "title": "Step 4 - Create a New Branch for Each Bug/Feature"
        },
        {
            "location": "/contributing/#step-5-make-edits-git-add-git-commit",
            "text": "With your new branch checked out locally, make changes or additions to the code\nor documentation, git add them, and git commit them.    git add new-or-changed-file\ngit commit -m  \"Short description of new or changed things\"   Remember to write tests for new code, including unit (isolated) tests and \nintegrated tests.  Target a unit test coverage ratio of 90% tested.  Test\ncoverage of less than 90% affected source code will be scrutinized and potentially \nrejected.  Please run all existing tests to make sure you didn't break something.  Tox\nis provided to help you run tests.  Remember to write or modify documentation to reflect your additions or changes.  You will want to merge changes from upstream (i.e. the original repository)\ninto your new branch from time to time, using something like:   git fetch upstream\ngit merge upstream/develop",
            "title": "Step 5 - Make Edits, git add, git commit"
        },
        {
            "location": "/contributing/#step-6-push-your-new-branch-to-origin",
            "text": "Ensure that you've  commited  all that you want to include in your pull request. \nThen push your new branch to origin (i.e.  your  remote yosai repository).  git push origin new-branch-name",
            "title": "Step 6 - Push Your New Branch to origin"
        },
        {
            "location": "/contributing/#step-7-create-a-pull-request",
            "text": "Go to the GitHub website and to  your  remote yosai repository (i.e. something \nlike https://github.com/your-user-name/yosai).   See [GitHub's documentation on how to initiate and send a pull request]\n(https://help.github.com/articles/using-pull-requests/). Note that the\ndestination repository should be  yosaiproject/yosai  and the destination\nbranch will typically be  develop .  Send the pull request.  Someone will then merge your branch or suggest changes. If we suggest changes,\nyou won't have to open a new pull request, you can just push new code to the\nsame branch (on  origin ) as you did before creating the pull request.",
            "title": "Step 7 - Create a Pull Request"
        },
        {
            "location": "/contributing/#quick-links",
            "text": "General GitHub Documentation  Code of Conduct",
            "title": "Quick Links"
        },
        {
            "location": "/code_of_conduct/",
            "text": "Contributor Code of Conduct\n\n\nAs contributors and maintainers of this project, and in the interest of\nfostering an open and welcoming community, we pledge to respect all people who\ncontribute to the project.\n\n\nWe are committed to making participation in this project a harassment-free\nexperience for everyone, regardless of level of experience, gender, gender\nidentity and expression, sexual orientation, disability, personal appearance,\nbody size, race, ethnicity, age, religion, or nationality.\n\n\nExamples of unacceptable behavior by participants include:\n\n\n\n\nThe use of sexualized language or imagery\n\n\nPersonal attacks\n\n\nTrolling or insulting/derogatory comments\n\n\nPublic or private harassment\n\n\nPublishing other's private information, such as physical or electronic\n  addresses, without explicit permission\n\n\nDeliberate intimidation\n\n\nOther unethical or unprofessional conduct\n\n\n\n\nProject maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.\n\n\nBy adopting this Code of Conduct, project maintainers commit themselves to\nfairly and consistently applying these principles to every aspect of managing\nthis project. Project maintainers who do not follow or enforce the Code of\nConduct may be permanently removed from the project team.\n\n\nThis Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community.\n\n\nInstances of abusive, harassing, or otherwise unacceptable behavior directed at\nyourself or another community member may be reported by contacting a project\nmaintainer. All complaints will be reviewed and investigated and will result in\na response that is appropriate to the circumstances. Maintainers are obligated\nto maintain confidentiality with regard to the reporter of an incident.\n\n\nThis Code of Conduct is adapted from the \nContributor Covenant\n,\nversion 1.3.0, available at\n\nhttp://contributor-covenant.org/version/1/3/0/",
            "title": "Code of Conduct"
        },
        {
            "location": "/code_of_conduct/#contributor-code-of-conduct",
            "text": "As contributors and maintainers of this project, and in the interest of\nfostering an open and welcoming community, we pledge to respect all people who\ncontribute to the project.  We are committed to making participation in this project a harassment-free\nexperience for everyone, regardless of level of experience, gender, gender\nidentity and expression, sexual orientation, disability, personal appearance,\nbody size, race, ethnicity, age, religion, or nationality.  Examples of unacceptable behavior by participants include:   The use of sexualized language or imagery  Personal attacks  Trolling or insulting/derogatory comments  Public or private harassment  Publishing other's private information, such as physical or electronic\n  addresses, without explicit permission  Deliberate intimidation  Other unethical or unprofessional conduct   Project maintainers have the right and responsibility to remove, edit, or\nreject comments, commits, code, wiki edits, issues, and other contributions\nthat are not aligned to this Code of Conduct, or to ban temporarily or\npermanently any contributor for other behaviors that they deem inappropriate,\nthreatening, offensive, or harmful.  By adopting this Code of Conduct, project maintainers commit themselves to\nfairly and consistently applying these principles to every aspect of managing\nthis project. Project maintainers who do not follow or enforce the Code of\nConduct may be permanently removed from the project team.  This Code of Conduct applies both within project spaces and in public spaces\nwhen an individual is representing the project or its community.  Instances of abusive, harassing, or otherwise unacceptable behavior directed at\nyourself or another community member may be reported by contacting a project\nmaintainer. All complaints will be reviewed and investigated and will result in\na response that is appropriate to the circumstances. Maintainers are obligated\nto maintain confidentiality with regard to the reporter of an incident.  This Code of Conduct is adapted from the  Contributor Covenant ,\nversion 1.3.0, available at http://contributor-covenant.org/version/1/3/0/",
            "title": "Contributor Code of Conduct"
        },
        {
            "location": "/credits/",
            "text": "Respectful Acknowledgement\n\n\n\n\nYosai would not exist without Apache Shiro. Yosai is a port-fork of Apache Shiro, version 2 alpha.  Further, source documentation and sections of this web site's documentation are derived from Apache Shiro sources.\n\n\nNaming Yosai\n\n\nIn Japanese, the word Shiro means Castle.  Yosai means fortress.\n\nLike the names, the projects are similar in meaning, but different.",
            "title": "Credits"
        },
        {
            "location": "/credits/#respectful-acknowledgement",
            "text": "Yosai would not exist without Apache Shiro. Yosai is a port-fork of Apache Shiro, version 2 alpha.  Further, source documentation and sections of this web site's documentation are derived from Apache Shiro sources.",
            "title": "Respectful Acknowledgement"
        },
        {
            "location": "/credits/#naming-yosai",
            "text": "In Japanese, the word Shiro means Castle.  Yosai means fortress. \nLike the names, the projects are similar in meaning, but different.",
            "title": "Naming Yosai"
        }
    ]
}