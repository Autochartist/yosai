{
    "docs": [
        {
            "location": "/",
            "text": "Introduction\n\n\nWithin this section of documentation, you will learn the fundamental concepts presented in Yosai.  More detailed documentation, including tutorials, is available in subsequent sections.\n\n\nWhat is Yosai?\n\n\nYosai helps you to control who can use your application and how it is used,\nmanaging state between requests.  In other words, Yosai offers authentication,\n authorization, and session management, respectively.\n\n\nArchitectural Overview: yosai.core\n\n\nYosai is a framework, allowing you to add or replace components that are designed according to documented interface specifications.  More specifically, the framework is defined using a collection of abstract base classes.\n\n\n\n\nAlthough it is customizable, Yosai features a set of default implementations to address its most anticipated uses. It is \"built to contract\", featuring concrete implementations of abstract base classes that collectively define Yosai's architecture. Developers who find Yosai's default concrete implementations unsuitable for their needs may implement their own components according to ABC specifications and swap components.\n\n\nFundamentals\n\n\nIntroducing: Subject\n\n\nThe three core services provided by Yosai are:\n\n\n\n\nAuthentication\n\n\nAuthorization\n\n\nSession Management\n\n\n\n\nThese services share a common API that you will use to interact with them:  the Subject API.\n\n\nEvery security related operation is performed in the context of a \nSubject\n.\nThe term \"Subject\" is generally synonymous with \"User\" except that aside from\nhuman beings also includes non-human, system entities.  In other words, a \nSubject\n is a \nperson\n or a \nthing\n.\n\n\nAuthentication\n\n\nIn this example, we \"log in\" a Subject, performing password-based authentication\nthat raises an AuthenticationException if authentication were to fail:\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils,\n \nAuthenticationToken\n\n\n    \nauthc_token\n \n=\n \nUsernamePasswordToken(username\n=\nthedude\n,\n\n                                        \ncredentials\n=\nletsgobowling\n)\n\n    \nsubject\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n    \nsubject\n.\nlogin(authc_token)\n\n\n\n\n\n\n\n\nUsernamePasswordToken is a consolidation of a user account's identifying\nattributes (username) and credentials (password) submitted by a user\nduring an authentication attempt\n\n\n\n\nAuthorization\n\n\nAuthorization is conducted in your application either by decorating methods with an authorization check, such as in the example below, or by expicitly calling\none of Subject's access control methods.\n\n\nThe following example confirms whether the user logged in above has sufficient\nprivileges to approve a bowling tournament application.  We illustrate what is known as the \ndeclarative style\n authorization.  Information about authorization styles can be found in the authorization documentation.\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \ncheck_permission\n\n\n    \n@check_permission\n([\ntournament:approve\n])\n\n    \ndef\n \napprove_tournament_application\n(self,\n \ntournament_application):\n\n        \ntournament_application\n.\nstatus\n \n=\n \nAPPROVED\n\n        \nself\n.\nnotify_approval(tournament_application)\n\n\n\n\n\n\nSession Management\n\n\nYosai offers session management for anonymous guests or authenticated users.\nIn the Authentication example above, the Subject is automatically allocated a\nnew session in Yosai following successful authentication.  We manage\nthe attributes of a session through a CRUD-like series of methods:\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils\n\n\n    \nsubject\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n\n    \nsession\n \n=\n \nsubject\n.\nget_session()\n\n    \nsession\n.\nset_attribute(\nfull_name\n,\n \nJeffrey Lebowski\n)\n\n\n\n\n\n\nInitializing Yosai\n\n\nWith Yosai initialized, you can authenticate, authorize, and manage sessions.\n\n\nTo initialize Yosai, you must specify, at a minimum:\n- What CacheHandler to use, if you are caching\n- The AccountStore instance(s) from which to obtain authentication and\n  authorization information\n- The \nmarshmallow\n serialization Schema you will use to (de)serialize\n  Session state (user-defined session attributes), if you are caching\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils\n\n\n    \nrealm\n \n=\n \nAccountStoreRealm()\n\n\n    \nSecurityUtils\n.\ninit_yosai(cache_handler\n=\nDPCacheHandler(),\n\n                             \nrealms\n=\n(realm,),\n\n                             \nsession_schema\n=\nMySessionSchema)\n\n\n\n\n\n\n\n\n\n\nCacheHandler is a Yosai extension\n\n\nThe underlying AccountStore that is referenced by the AccountStoreRealm\n  object is also a Yosai extension\n\n\nMySessionSchema is a \nmarshmallow\n Schema class",
            "title": "Home"
        },
        {
            "location": "/#introduction",
            "text": "Within this section of documentation, you will learn the fundamental concepts presented in Yosai.  More detailed documentation, including tutorials, is available in subsequent sections.",
            "title": "Introduction"
        },
        {
            "location": "/#what-is-yosai",
            "text": "Yosai helps you to control who can use your application and how it is used,\nmanaging state between requests.  In other words, Yosai offers authentication,\n authorization, and session management, respectively.",
            "title": "What is Yosai?"
        },
        {
            "location": "/#architectural-overview-yosaicore",
            "text": "Yosai is a framework, allowing you to add or replace components that are designed according to documented interface specifications.  More specifically, the framework is defined using a collection of abstract base classes.   Although it is customizable, Yosai features a set of default implementations to address its most anticipated uses. It is \"built to contract\", featuring concrete implementations of abstract base classes that collectively define Yosai's architecture. Developers who find Yosai's default concrete implementations unsuitable for their needs may implement their own components according to ABC specifications and swap components.",
            "title": "Architectural Overview: yosai.core"
        },
        {
            "location": "/#fundamentals",
            "text": "",
            "title": "Fundamentals"
        },
        {
            "location": "/#introducing-subject",
            "text": "The three core services provided by Yosai are:   Authentication  Authorization  Session Management   These services share a common API that you will use to interact with them:  the Subject API.  Every security related operation is performed in the context of a  Subject .\nThe term \"Subject\" is generally synonymous with \"User\" except that aside from\nhuman beings also includes non-human, system entities.  In other words, a  Subject  is a  person  or a  thing .",
            "title": "Introducing: Subject"
        },
        {
            "location": "/#authentication",
            "text": "In this example, we \"log in\" a Subject, performing password-based authentication\nthat raises an AuthenticationException if authentication were to fail:       from   yosai.core   import   SecurityUtils,   AuthenticationToken \n\n     authc_token   =   UsernamePasswordToken(username = thedude , \n                                         credentials = letsgobowling ) \n     subject   =   SecurityUtils . get_subject() \n     subject . login(authc_token)    UsernamePasswordToken is a consolidation of a user account's identifying\nattributes (username) and credentials (password) submitted by a user\nduring an authentication attempt",
            "title": "Authentication"
        },
        {
            "location": "/#authorization",
            "text": "Authorization is conducted in your application either by decorating methods with an authorization check, such as in the example below, or by expicitly calling\none of Subject's access control methods.  The following example confirms whether the user logged in above has sufficient\nprivileges to approve a bowling tournament application.  We illustrate what is known as the  declarative style  authorization.  Information about authorization styles can be found in the authorization documentation.       from   yosai.core   import   check_permission \n\n     @check_permission ([ tournament:approve ]) \n     def   approve_tournament_application (self,   tournament_application): \n         tournament_application . status   =   APPROVED \n         self . notify_approval(tournament_application)",
            "title": "Authorization"
        },
        {
            "location": "/#session-management",
            "text": "Yosai offers session management for anonymous guests or authenticated users.\nIn the Authentication example above, the Subject is automatically allocated a\nnew session in Yosai following successful authentication.  We manage\nthe attributes of a session through a CRUD-like series of methods:       from   yosai.core   import   SecurityUtils \n\n     subject   =   SecurityUtils . get_subject() \n\n     session   =   subject . get_session() \n     session . set_attribute( full_name ,   Jeffrey Lebowski )",
            "title": "Session Management"
        },
        {
            "location": "/#initializing-yosai",
            "text": "With Yosai initialized, you can authenticate, authorize, and manage sessions.  To initialize Yosai, you must specify, at a minimum:\n- What CacheHandler to use, if you are caching\n- The AccountStore instance(s) from which to obtain authentication and\n  authorization information\n- The  marshmallow  serialization Schema you will use to (de)serialize\n  Session state (user-defined session attributes), if you are caching       from   yosai.core   import   SecurityUtils \n\n     realm   =   AccountStoreRealm() \n\n     SecurityUtils . init_yosai(cache_handler = DPCacheHandler(), \n                              realms = (realm,), \n                              session_schema = MySessionSchema)     CacheHandler is a Yosai extension  The underlying AccountStore that is referenced by the AccountStoreRealm\n  object is also a Yosai extension  MySessionSchema is a  marshmallow  Schema class",
            "title": "Initializing Yosai"
        },
        {
            "location": "/installation_setup/",
            "text": "Installation and Setup\n\n\nInstallation\n\n\nFirst, install Yosai from PyPi:\n    \npip install yosai\n\n\nThis will install yosai.core, including its default configuration, and\nits dependencies.\n\n\nSetup\n\n\nYosai can be configured in two ways:\n- using a YAML config file, whose location must be specified in an environment variable, \nYOSAI_CORE_SETTINGS\n\n- using Yosai defaults, which are specified in a YAML config file located in the\n  /config directory of the yosai package\n\n\nConfiguration\n\n\nFollowing is a copy of the default YAML config file.  As you will see, settings\nare organized according to the services that use them:\n\n\nAUTHC_CONFIG\n:\n\n    \ndefault_algorithm\n:\n \nbcrypt_sha256\n\n    \nhash_algorithms\n:\n\n        \nbcrypt_sha256\n:\n \n{}\n\n        \nsha256_crypt\n:\n\n            \ndefault_rounds\n:\n \n110000\n\n            \nmax_rounds\n:\n \n1000000\n\n            \nmin_rounds\n:\n \n1000\n\n            \nsalt_size\n:\n \n16\n\n\n\n\nMGT_CONFIG\n:\n\n    \nDEFAULT_CIPHER_KEY\n:\n \nyou\n \nneed\n \nto\n \nupdate\n \nthis\n \nusing\n \nthe\n \nfernet\n \nkeygen\n\n\n\n\nSESSION_CONFIG\n:\n\n    \nsession_timeout\n:\n\n        \nabsolute_timeout\n:\n \n1800\n\n        \nidle_timeout\n:\n \n300\n\n    \nsession_validation\n:\n\n        \nscheduler_enabled\n:\n \nfalse\n\n        \ntime_interval\n:\n \n3600\n\n\n\n\n\n\nConfiguration:  AUTHC_CONFIG\n\n\nThese are cryptographic hashing settings used to configure the \nCryptContext\n object obtained from the \nPasslib\n library.\n\n\nConfiguration:  MGT_CONFIG\n\n\nDEFAULT_CIPHER_KEY\n is a setting that contains a cipher key used by the Fernet key generator.  As you can see, a default value isn't provided and you must generate your own.  This key is used for (de)encryption during \"RememberMe\" processing. \nyosai.core.mgt.AbstractRememberMeManager\n\n\nConfiguration: SESSION_CONFIG\n\n\nA session has two timeout thresholds: idle and absolute time-to-live.  If you\nare using manual session validation, you can manage settings for it within the respective section in the config.  Time is represented in seconds.",
            "title": "Installation and Setup"
        },
        {
            "location": "/installation_setup/#installation-and-setup",
            "text": "",
            "title": "Installation and Setup"
        },
        {
            "location": "/installation_setup/#installation",
            "text": "First, install Yosai from PyPi:\n     pip install yosai  This will install yosai.core, including its default configuration, and\nits dependencies.",
            "title": "Installation"
        },
        {
            "location": "/installation_setup/#setup",
            "text": "Yosai can be configured in two ways:\n- using a YAML config file, whose location must be specified in an environment variable,  YOSAI_CORE_SETTINGS \n- using Yosai defaults, which are specified in a YAML config file located in the\n  /config directory of the yosai package",
            "title": "Setup"
        },
        {
            "location": "/installation_setup/#configuration",
            "text": "Following is a copy of the default YAML config file.  As you will see, settings\nare organized according to the services that use them:  AUTHC_CONFIG : \n     default_algorithm :   bcrypt_sha256 \n     hash_algorithms : \n         bcrypt_sha256 :   {} \n         sha256_crypt : \n             default_rounds :   110000 \n             max_rounds :   1000000 \n             min_rounds :   1000 \n             salt_size :   16  MGT_CONFIG : \n     DEFAULT_CIPHER_KEY :   you   need   to   update   this   using   the   fernet   keygen  SESSION_CONFIG : \n     session_timeout : \n         absolute_timeout :   1800 \n         idle_timeout :   300 \n     session_validation : \n         scheduler_enabled :   false \n         time_interval :   3600",
            "title": "Configuration"
        },
        {
            "location": "/installation_setup/#configuration-authc_config",
            "text": "These are cryptographic hashing settings used to configure the  CryptContext  object obtained from the  Passlib  library.",
            "title": "Configuration:  AUTHC_CONFIG"
        },
        {
            "location": "/installation_setup/#configuration-mgt_config",
            "text": "DEFAULT_CIPHER_KEY  is a setting that contains a cipher key used by the Fernet key generator.  As you can see, a default value isn't provided and you must generate your own.  This key is used for (de)encryption during \"RememberMe\" processing.  yosai.core.mgt.AbstractRememberMeManager",
            "title": "Configuration:  MGT_CONFIG"
        },
        {
            "location": "/installation_setup/#configuration-session_config",
            "text": "A session has two timeout thresholds: idle and absolute time-to-live.  If you\nare using manual session validation, you can manage settings for it within the respective section in the config.  Time is represented in seconds.",
            "title": "Configuration: SESSION_CONFIG"
        },
        {
            "location": "/authentication/",
            "text": "Authentication\n\n\n\n\nAn application bases much of its security on knowing who a user of the system is. Authentication is the process of verifying identity, proving that a subject \nis\n who \nit\n claims to be.\n\n\nPowerful Authentication using a Simple API\n\n\nMost of your interactions with Yosai are based on the currently executing user,\ncalled a \nSubject\n.  You can easily obtain a handle on your subject instance\nfrom anywhere in your code through the SecurityUtils API.\n\n\nWhen a developer wishes to authenticate a user using password-based methods,\nthe first step requires instantiation of an \nAuthenticationToken\n object\nrecognizable by Yosai.  The \nUsernamePasswordToken\n is one such kind of token that\n is already implemented in Yosai as part of default support for password-based\nauthentication. \nUsernamePasswordToken\n is a consolidation of a user account's\nidentifying attributes (username) and credentials (password).\n\n\nLogging-In and Logging-Out\n\n\nLogging-In\n\n\nWhen you \nlog-in\n, you are attempting to make a secured system recognize your\npresence.  The system recognizes who you are by verifying your identity.  Once your\nidentity is verified, the system considers you present (logged in) by creating a new,\nverified session for you.  \n\n\nThere are two key processes involved with logging-in:\n- Session Management\n- Authentication\n\n\nSession Management\n\n\nLogging-in consists of authentication followed by instantiation of a new session,\nremoving a guest session that was created for you earlier.\n\n\nAs you first interact with a system secured with Yosai, Yosai recognizes you as\na \nguest\n.  A guest is granted an anonymous session (a new one is created) during\nthe guest's first interaction with the system.  Once authenticated, you are\ngranted elevated access to the system: your status in the system changes\nfrom when you were anonymous.  The elevation of status involves deleting the anonymous\nsession and creating a new, \nverified\n session for you. Once authenticated, you\nare considered present through the existence of this \nverified\n session.\n\n\nAuthentication, with Example\n\n\nAuthentication\n is the process of verifying identity.  \n\n\nIn the following example, we log-in a Subject by performing password-based\nauthentication.  This process would raise an AuthenticationException\nif it were to fail.  Yosai features a rich exception hierarchy that offers detailed\nexplanations as to why a login failed. This exception hierarchy helps developers\ndiagnose bugs or customer service issues related to authentication.\n\n\nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils,\n \nUsernamePasswordToken\n\n\n\ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n\n\nauthc_token\n \n=\n \nUsernamePasswordToken(username\n=\nthedude\n,\n\n                                    \ncredentials\n=\nletsgobowling\n)\n\n\nauthc_token\n.\nremember_me\n \n=\n \nTrue\n\n\n\ntry\n:\n\n    \ncurrent_user\n.\nlogin(authc_token)\n\n\nexcept\n \nUnknownAccountException:\n\n    \n# insert here\n\n\nexcept\n \nIncorrectCredentialsException:\n\n    \n# insert here\n\n\nexcept\n \nLockedAccountException:\n\n    \n# insert here\n\n\nexcept\n \nExcessiveAttemptsException:\n\n    \n# insert here\n\n\nexcept\n \nAuthenticationException:\n\n    \n# insert here\n\n\n\n\n\n\nAs you can see, authentication entails a single method call: \ncurrent_user.login(authc_token)\n. The Subject API requires a single method call to authenticate, regardless of the underlying authentication strategy chosen.\n\n\nNotice that \nremember_me\n is activated in the authentication token.  Yosai features\nnative 'remember me' support.  'Remember Me' is a popular feature where users are\nremembered when they return to an application.  Remembering your users offers a\nmore convenient user experience for them, although it does come at a cost in\nsecurity.\n\n\nCryptographic Hashing of Passwords\n\n\nFor password-based authentication, Yosai uses the Passlib library for\ncryptographic hashing and password verification.\n\n\nThe default hashing scheme chosen for Yosai is \nbcrypt_sha256\n. As per Passlib\ndocumentation [1], the \nbcrypt_sha256\n algorithm works as follows:\n\n\n\n\nFirst, the password is encoded to UTF-8 if not already encoded.\n\n\nThen, the UTF-8 encoded password is run through SHA2-256, generating a 32-byte digest\n\n\n\n\nThe 32-byte digest is encoded using base64, resulting in a 44-byte result\n  (including the trailing padding '='):\n      For the example \"password\", the output from this stage would be:\n        \"XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=\".\n\n\n\n\n\n\nFinally, the base64 string is passed on to the underlying bcrypt algorithm\n  as the new password to be hashed.\n\n\n\n\n\n\nFor more information about Passlib's bcrypt_sha256, you may \naccess its documentation here\n\n\nLogging Out\n\n\nWhen you \nlog-out\n, the system no longer recognizes your presence nor will it\nhonor any prior recognition of your identity (you would have to re-authenticate\nyourself if you re-engaged the system). When you log-out a user, you are\nreleasing the identifying state of the user by the application.  A Subject is\nlogged out when the Subject is done interacting with the application by calling:  \ncurrent_user.logout()\n, relinquishing all identifying information and\ninvalidating the user's session.  If you are logging out in a web app and use\nthe yosai.web library, the RememberMe cookie will also be deleted.\n\n\nAfter a Subject logs-out, the Subject instance is considered anonymous again\nand, except for web applications, can be re-used for login again if desired.\n\n\n\n\nBecause remembered identity in web applications is often persisted with cookies, and cookies can only be deleted before a Response body is committed, it is highly recommended to redirect the end-user to a new view or page immediately after calling current_user.logout(). Doing so guarantees that any security-related cookies are deleted as expected. This is a limitation of how HTTP cookies function and not a limitation of Yosai.\n\n\n\n\nAutomatic Log Out\n\n\nAutomatic log out happens at session expiration.  Yosai expires sessions in two\nways: idle timeout and absolute time to live timeout.  Please consult the\nSession Management documentation to learn more about timeouts.\n\n\nManual Log Out\n\n\nWhen you manually log-out, you are explicitly telling the system that your work\nis done and you do no wish to continue your current session with the system.\n\nManual log-out is initiated by a user engaging a log-out operation through a user\ninterface, such as click a \"log-out\" or \"sign out\" button, which would ultimately\ncall the \nlogout\n method in the Subject API:\n\n\nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils,\n \nUsernamePasswordToken\n\n\n\ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n\n\ncurrent_user\n.\nlogout()\n\n\n\n\n\n\nFactors of Authentication\n\n\nAuthentication methodologies involve three factors:\n\n\n\n\nsomething the user \nknows\n\n\nsomething the user \nhas\n\n\nsomething the user \nis\n\n\n\n\nAuthentication methods that depend on more than one factor, known as multi-factor\nauthentication (MFA) methods, are considered stronger fraud deterrents than single-factor\n methods as they are more difficult to compromise.  A bank ATM transaction involves\nMFA because it requires something the user \nhas\n -- a bank card -- \nand\n it\nrequires something the user \nknows\n -- a PIN code.\n\n\nThe use of a username/password to login is considered single-factor\nauthentication because it only involves something the user \nknows\n.\n\n\nYosai is designed to accommodate multi-factor authentication methods.  Be that\nas it may, no concrete MFA implementation is provided within the core library\nbecause the MFA chosen is discretionary and largely subject to change among\nprojects.  Instead, the Yosai community is encouraged to share extensions to\nenable MFA.\n\n\nHowever, although no multi-factor solution is provided, a single-factor,\npassword-based authentication is provided in yosai.core because it remains the\nmost widely used form of authentication.  You could see an example of it in the\nlogging-in documentation above.\n\n\nNative Support for 'Remember Me' Services\n\n\nAs shown in the example above, Yosai supports \"Remember Me\" in addition to\nthe normal login process.  Yosai makes a very precise distinction between a\nremembered Subject and an actual authenticated Subject:\n\n\nRemembered\n\n\nA remembered Subject is not anonymous and has a known identity (i.e. subject.identifiers is non-empty). However, this identity is remembered from a previous authentication during a previous session. A subject is considered remembered if subject.is_remembered returns True.\n\n\nAuthenticated\n\n\nAn authenticated Subject is one that has been successfully\nauthenticated (i.e. the login method was called without any exception raised)\nduring the Subject's current session. A subject is considered authenticated\nif subject.authenticated returns True.\n\n\nMutually Exclusive\n\n\nRemembered and authenticated states are mutually exclusive --  a True value\nfor one indicates a False value for the other and vice versa.\n\n\nWhy the Distinction?\n\n\nThe word 'authentication' has a very strong connotation of proof. That is,\nthere is an expected guarantee that the Subject has proven that it is who it\nclaims to be.\n\n\nWhen a user is merely remembered by a previous interaction with the application,\nthe state of proof no longer exists.  The remembered identity gives the system\nan idea who that user \nprobably\n is, yet the system is has no guarantees that the remembered Subject represents an expected user. Once the subject is authenticated, the user is no longer considered only remembered because its identity would have been verified during the current session.\n\n\nSo although many parts of the application can still perform user-specific logic\nbased on the remembered identifiers, such as customized views, it should\ntypically never perform highly-sensitive operations until the user has\nlegitimately verified its identity by executing a successful authentication\nattempt.\n\n\nFor example, a check whether a Subject can access financial information should\nalmost always depend on subject.authenticated rather than subject.is_remembered to guarantee an expected and verified identity.\n\n\nRemember-Me Example\n\n\nThe following is a fairly common scenario that helps illustrate why the the\ndistinction between remembered and authenticated is important.\n\n\nLet's say you're using Amazon.com. You've logged-in successfully and have added\na few books to your shopping cart. But you have to run off to a meeting, but\nforget to log out. By the time the meeting is over, it's time to go home and\nyou leave the office.\n\n\nThe next day when you come in to work, you realize you didn't complete your\npurchase, so you go back to amazon.com. This time, Amazon 'remembers' who you\nare, greets you by name, and still gives you some personalized book\nrecommendations. To Amazon, subject.is_remembered would return True.\n\n\nBut, what happens if you try to access your account to update your credit card\ninformation to make your book purchase? While Amazon 'remembers' you\n(is_remembered is True), it cannot guarantee that you are in fact you (for\nexample, maybe a co-worker is using your computer).\n\n\nSo before you can perform a sensitive action like updating credit card\ninformation, Amazon will force you to login so that they can guarantee your\nidentity. After you login, your identity has been verified and to Amazon,\nsubject.authenticated would now be True.\n\n\nThis scenario happens so frequently for many types of applications, so the\nfunctionality is built in to Yosai so that you may leverage it for your own\napplication. Now, whether you use subject.is_remembered or subject.authenticated to customize your views and workflows is up to you, but Yosai will maintain this\nfundamental state in case you need it.\n\n\nAuthentication Events\n\n\nAn Event is emitted to the singleton EventBus when the results of\nauthentication are obtained, indicating whether authentication succeeded or\nfailed (without compromising credentials).  If you would like to learn more\nabout Event processing, please refer to the documentation about Event\nProcessing.\n\n\nEvents are communicated using a publish-subscribe paradigm.  In the case of\nAuthentication, the \nDefaultAuthenticator\n publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).\n\n\nThe following table lists the Authentication-related events and subscriber(s):\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nAUTHENTICATION.SUCCEEDED\n\n\nMRA, EL\n\n\n\n\n\n\nAUTHENTICATION.FAILED\n\n\nEL\n\n\n\n\n\n\n\n\n\n\nMRA = \nyosai.core.authz.authz.ModularRealmAuthorizer\n\n\nEL = \nyosai.core.event.event.EventLogger\n\n\n\n\nReferences\n\n\nOWASP Authentication Cheat Sheet",
            "title": "Authentication"
        },
        {
            "location": "/authentication/#authentication",
            "text": "An application bases much of its security on knowing who a user of the system is. Authentication is the process of verifying identity, proving that a subject  is  who  it  claims to be.",
            "title": "Authentication"
        },
        {
            "location": "/authentication/#powerful-authentication-using-a-simple-api",
            "text": "Most of your interactions with Yosai are based on the currently executing user,\ncalled a  Subject .  You can easily obtain a handle on your subject instance\nfrom anywhere in your code through the SecurityUtils API.  When a developer wishes to authenticate a user using password-based methods,\nthe first step requires instantiation of an  AuthenticationToken  object\nrecognizable by Yosai.  The  UsernamePasswordToken  is one such kind of token that\n is already implemented in Yosai as part of default support for password-based\nauthentication.  UsernamePasswordToken  is a consolidation of a user account's\nidentifying attributes (username) and credentials (password).",
            "title": "Powerful Authentication using a Simple API"
        },
        {
            "location": "/authentication/#logging-in-and-logging-out",
            "text": "",
            "title": "Logging-In and Logging-Out"
        },
        {
            "location": "/authentication/#logging-in",
            "text": "When you  log-in , you are attempting to make a secured system recognize your\npresence.  The system recognizes who you are by verifying your identity.  Once your\nidentity is verified, the system considers you present (logged in) by creating a new,\nverified session for you.    There are two key processes involved with logging-in:\n- Session Management\n- Authentication",
            "title": "Logging-In"
        },
        {
            "location": "/authentication/#session-management",
            "text": "Logging-in consists of authentication followed by instantiation of a new session,\nremoving a guest session that was created for you earlier.  As you first interact with a system secured with Yosai, Yosai recognizes you as\na  guest .  A guest is granted an anonymous session (a new one is created) during\nthe guest's first interaction with the system.  Once authenticated, you are\ngranted elevated access to the system: your status in the system changes\nfrom when you were anonymous.  The elevation of status involves deleting the anonymous\nsession and creating a new,  verified  session for you. Once authenticated, you\nare considered present through the existence of this  verified  session.",
            "title": "Session Management"
        },
        {
            "location": "/authentication/#authentication-with-example",
            "text": "Authentication  is the process of verifying identity.    In the following example, we log-in a Subject by performing password-based\nauthentication.  This process would raise an AuthenticationException\nif it were to fail.  Yosai features a rich exception hierarchy that offers detailed\nexplanations as to why a login failed. This exception hierarchy helps developers\ndiagnose bugs or customer service issues related to authentication.  from   yosai.core   import   SecurityUtils,   UsernamePasswordToken  current_user   =   SecurityUtils . get_subject()  authc_token   =   UsernamePasswordToken(username = thedude , \n                                     credentials = letsgobowling )  authc_token . remember_me   =   True  try : \n     current_user . login(authc_token)  except   UnknownAccountException: \n     # insert here  except   IncorrectCredentialsException: \n     # insert here  except   LockedAccountException: \n     # insert here  except   ExcessiveAttemptsException: \n     # insert here  except   AuthenticationException: \n     # insert here   As you can see, authentication entails a single method call:  current_user.login(authc_token) . The Subject API requires a single method call to authenticate, regardless of the underlying authentication strategy chosen.  Notice that  remember_me  is activated in the authentication token.  Yosai features\nnative 'remember me' support.  'Remember Me' is a popular feature where users are\nremembered when they return to an application.  Remembering your users offers a\nmore convenient user experience for them, although it does come at a cost in\nsecurity.",
            "title": "Authentication, with Example"
        },
        {
            "location": "/authentication/#cryptographic-hashing-of-passwords",
            "text": "For password-based authentication, Yosai uses the Passlib library for\ncryptographic hashing and password verification.  The default hashing scheme chosen for Yosai is  bcrypt_sha256 . As per Passlib\ndocumentation [1], the  bcrypt_sha256  algorithm works as follows:   First, the password is encoded to UTF-8 if not already encoded.  Then, the UTF-8 encoded password is run through SHA2-256, generating a 32-byte digest   The 32-byte digest is encoded using base64, resulting in a 44-byte result\n  (including the trailing padding '='):\n      For the example \"password\", the output from this stage would be:\n        \"XohImNooBHFR0OVvjcYpJ3NgPQ1qq73WKhHvch0VQtg=\".    Finally, the base64 string is passed on to the underlying bcrypt algorithm\n  as the new password to be hashed.    For more information about Passlib's bcrypt_sha256, you may  access its documentation here",
            "title": "Cryptographic Hashing of Passwords"
        },
        {
            "location": "/authentication/#logging-out",
            "text": "When you  log-out , the system no longer recognizes your presence nor will it\nhonor any prior recognition of your identity (you would have to re-authenticate\nyourself if you re-engaged the system). When you log-out a user, you are\nreleasing the identifying state of the user by the application.  A Subject is\nlogged out when the Subject is done interacting with the application by calling:   current_user.logout() , relinquishing all identifying information and\ninvalidating the user's session.  If you are logging out in a web app and use\nthe yosai.web library, the RememberMe cookie will also be deleted.  After a Subject logs-out, the Subject instance is considered anonymous again\nand, except for web applications, can be re-used for login again if desired.   Because remembered identity in web applications is often persisted with cookies, and cookies can only be deleted before a Response body is committed, it is highly recommended to redirect the end-user to a new view or page immediately after calling current_user.logout(). Doing so guarantees that any security-related cookies are deleted as expected. This is a limitation of how HTTP cookies function and not a limitation of Yosai.",
            "title": "Logging Out"
        },
        {
            "location": "/authentication/#automatic-log-out",
            "text": "Automatic log out happens at session expiration.  Yosai expires sessions in two\nways: idle timeout and absolute time to live timeout.  Please consult the\nSession Management documentation to learn more about timeouts.",
            "title": "Automatic Log Out"
        },
        {
            "location": "/authentication/#manual-log-out",
            "text": "When you manually log-out, you are explicitly telling the system that your work\nis done and you do no wish to continue your current session with the system. \nManual log-out is initiated by a user engaging a log-out operation through a user\ninterface, such as click a \"log-out\" or \"sign out\" button, which would ultimately\ncall the  logout  method in the Subject API:  from   yosai.core   import   SecurityUtils,   UsernamePasswordToken  current_user   =   SecurityUtils . get_subject()  current_user . logout()",
            "title": "Manual Log Out"
        },
        {
            "location": "/authentication/#factors-of-authentication",
            "text": "Authentication methodologies involve three factors:   something the user  knows  something the user  has  something the user  is   Authentication methods that depend on more than one factor, known as multi-factor\nauthentication (MFA) methods, are considered stronger fraud deterrents than single-factor\n methods as they are more difficult to compromise.  A bank ATM transaction involves\nMFA because it requires something the user  has  -- a bank card --  and  it\nrequires something the user  knows  -- a PIN code.  The use of a username/password to login is considered single-factor\nauthentication because it only involves something the user  knows .  Yosai is designed to accommodate multi-factor authentication methods.  Be that\nas it may, no concrete MFA implementation is provided within the core library\nbecause the MFA chosen is discretionary and largely subject to change among\nprojects.  Instead, the Yosai community is encouraged to share extensions to\nenable MFA.  However, although no multi-factor solution is provided, a single-factor,\npassword-based authentication is provided in yosai.core because it remains the\nmost widely used form of authentication.  You could see an example of it in the\nlogging-in documentation above.",
            "title": "Factors of Authentication"
        },
        {
            "location": "/authentication/#native-support-for-remember-me-services",
            "text": "As shown in the example above, Yosai supports \"Remember Me\" in addition to\nthe normal login process.  Yosai makes a very precise distinction between a\nremembered Subject and an actual authenticated Subject:",
            "title": "Native Support for 'Remember Me' Services"
        },
        {
            "location": "/authentication/#remembered",
            "text": "A remembered Subject is not anonymous and has a known identity (i.e. subject.identifiers is non-empty). However, this identity is remembered from a previous authentication during a previous session. A subject is considered remembered if subject.is_remembered returns True.",
            "title": "Remembered"
        },
        {
            "location": "/authentication/#authenticated",
            "text": "An authenticated Subject is one that has been successfully\nauthenticated (i.e. the login method was called without any exception raised)\nduring the Subject's current session. A subject is considered authenticated\nif subject.authenticated returns True.",
            "title": "Authenticated"
        },
        {
            "location": "/authentication/#mutually-exclusive",
            "text": "Remembered and authenticated states are mutually exclusive --  a True value\nfor one indicates a False value for the other and vice versa.",
            "title": "Mutually Exclusive"
        },
        {
            "location": "/authentication/#why-the-distinction",
            "text": "The word 'authentication' has a very strong connotation of proof. That is,\nthere is an expected guarantee that the Subject has proven that it is who it\nclaims to be.  When a user is merely remembered by a previous interaction with the application,\nthe state of proof no longer exists.  The remembered identity gives the system\nan idea who that user  probably  is, yet the system is has no guarantees that the remembered Subject represents an expected user. Once the subject is authenticated, the user is no longer considered only remembered because its identity would have been verified during the current session.  So although many parts of the application can still perform user-specific logic\nbased on the remembered identifiers, such as customized views, it should\ntypically never perform highly-sensitive operations until the user has\nlegitimately verified its identity by executing a successful authentication\nattempt.  For example, a check whether a Subject can access financial information should\nalmost always depend on subject.authenticated rather than subject.is_remembered to guarantee an expected and verified identity.",
            "title": "Why the Distinction?"
        },
        {
            "location": "/authentication/#remember-me-example",
            "text": "The following is a fairly common scenario that helps illustrate why the the\ndistinction between remembered and authenticated is important.  Let's say you're using Amazon.com. You've logged-in successfully and have added\na few books to your shopping cart. But you have to run off to a meeting, but\nforget to log out. By the time the meeting is over, it's time to go home and\nyou leave the office.  The next day when you come in to work, you realize you didn't complete your\npurchase, so you go back to amazon.com. This time, Amazon 'remembers' who you\nare, greets you by name, and still gives you some personalized book\nrecommendations. To Amazon, subject.is_remembered would return True.  But, what happens if you try to access your account to update your credit card\ninformation to make your book purchase? While Amazon 'remembers' you\n(is_remembered is True), it cannot guarantee that you are in fact you (for\nexample, maybe a co-worker is using your computer).  So before you can perform a sensitive action like updating credit card\ninformation, Amazon will force you to login so that they can guarantee your\nidentity. After you login, your identity has been verified and to Amazon,\nsubject.authenticated would now be True.  This scenario happens so frequently for many types of applications, so the\nfunctionality is built in to Yosai so that you may leverage it for your own\napplication. Now, whether you use subject.is_remembered or subject.authenticated to customize your views and workflows is up to you, but Yosai will maintain this\nfundamental state in case you need it.",
            "title": "Remember-Me Example"
        },
        {
            "location": "/authentication/#authentication-events",
            "text": "An Event is emitted to the singleton EventBus when the results of\nauthentication are obtained, indicating whether authentication succeeded or\nfailed (without compromising credentials).  If you would like to learn more\nabout Event processing, please refer to the documentation about Event\nProcessing.  Events are communicated using a publish-subscribe paradigm.  In the case of\nAuthentication, the  DefaultAuthenticator  publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).  The following table lists the Authentication-related events and subscriber(s):     Event Topic  Subscriber(s)      AUTHENTICATION.SUCCEEDED  MRA, EL    AUTHENTICATION.FAILED  EL      MRA =  yosai.core.authz.authz.ModularRealmAuthorizer  EL =  yosai.core.event.event.EventLogger",
            "title": "Authentication Events"
        },
        {
            "location": "/authentication/#references",
            "text": "OWASP Authentication Cheat Sheet",
            "title": "References"
        },
        {
            "location": "/authorization/",
            "text": "Authorization\n\n\n\n\nAuthorization, also known as Access Control, is concerned with the rules and\nmechanisms governing how someone or something accesses resources (in this context, within a software application). Informally speaking, authorization is concerned with \u201cwho can do what\u201d.\n\n\nRole-Based Access Control\n\n\nThere are many access control models \nin use today\n.  By default, Yosai\nenforces access control by evaluating roles and permissions assigned to a user.\nThese roles and permissions are derived from a Role-Based Access Control (RBAC) model. Note that although a default support for RBAC is provided, your Realm\nimplementation ultimately decides how your permissions and roles are grouped\ntogether and whether to return a \u201cyes\u201d or a \u201cno\u201d answer to Yosai.  This feature\nallows you to architect your application in the manner you chose.\n\n\nFor more information about RBAC\n\n\nyosai.core\n obtains roles and permissions from a repository, such as a\nrelational database.  Designing and implementing the RBAC data model and its\nauthorization policy it represents are concerns beyond the scope\nof yosai.core. As mentioned earlier, Yosai can support any data model for\naccess control and doesn\u2019t force one on you.  However, a basic, flat RBAC\nmodel was implemented for Yosai, \nas an extension\n, so to facilitate other extension projects.\n\n\nKey Concepts\n\n\nThe key concepts to understand about authorization in Yosai involve these relationships:\n\n\n\n\nPermissions are \nassociated with\n roles. Users are \nassigned to\n roles.\n\n\nA \nPermission\n specifies an action performed in the system on a resource.\n\n\nA \nRole\n is a group of permissions. Organizations are known to group permissions\nby task or various job functions. Roles can be granted new permissions as new\napplications and systems are incorporated, and permissions can be revoked from\nroles as needed.\n\n\nA \nUser\n refers to a person who interfaces with the software application.\nA user is provided a user account that allows an application to uniquely\nidentify it.  User accounts are often identified by a Username/UserID\nattribute or email address.  Users are assigned roles based on the user's\nresponsibilities and qualifications. Users can be easily reassigned from one role\nto another.\n\n\nYosai obtains a user's authorization information (assigned permissions\nand role memberships) and then determines whether the user meets\nthe access required to perform an operation in an application.\n\n\nAccess Control Levels and Styles\n\n\nTwo \"levels\" of access control are available:  \nrole-level\n and \npermission-level\n.\n\n\nYosai supports \"explicit\" role-level access control.  With explicit role-level\naccess control, a developer specifies the role names that are required to gain\naccess to an operation.\n\n\nPermission-level access control is considered superior to role level.\nWith it, a developer can model authorization requirements ranging from the most\nsummary to the most detailed.\n\n\nBoth levels of access control can be performed using two styles:\n\n\n\n\n\n\nThe \ndeclarative style\n of authorization involves use of a decorator that performs one of the two levels of access control.  The wrapped method is never called if authorization fails.\n\n\n\n\n\n\nThe \nimperative style\n of authorization involves in-line access control within the operation that requires authorization.\n\n\n\n\n\n\nLevels and Styles Illustrated\n\n\nFollowing is an example of what role-level authorization looks like when using\neither style of access control.  In this example, we only allow a user to\ndelete a comment from a message board (subreddit) if the user is a moderator or\nadmin.  In other words, the user is a member of \neither\n the moderator or admin\nroles.  In reality, we would layer additional access control to the\nremove_comment method so that the creator of the post may also delete the\ncomment, but this detail is left out for simplicity's sake and only to\nhighlight role-level access control:\n\n\nDeclarative Style\n\n\n@requires_role\n(roleid_s\n=\n[\nmoderator\n,\n \nadmin\n],\n \nlogical_operator\n=\nany)\n\n\ndef\n \nremove_comment\n(self,\n \nsubmission):\n\n   \nself\n.\ndatabase_handler\n.\ndelete(submission)\n\n\n\n\n\n\nImperative Style\n\n\ndef\n \nremove_comment\n(self,\n \nsubmission):\n\n    \nsubject\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n\n    \ntry\n:\n\n        \nsubject\n.\ncheck_role([\nmoderator\n,\n \ncreator\n],\n \nlogical_operator\n=\nany)\n\n    \nexcept\n \nUnauthorizedException:\n\n        \nprint\n(\nCannot remove comment:  Access Denied.\n)\n\n\n    \nself\n.\ndatabase_handler\n.\ndelete(submission)\n\n\n\n\n\n\n\n\nRole-level access control is inferior to permission-level access control, but since it has its niche use, is available in Yosai.  It is highly recommended that you choose permission-level access control policies for your application.\n\n\n\n\nPermissions\n\n\nA permission states what behavior can be performed in an application but not who\ncan perform them. Permissions are modeled in Yosai using a flexible design that\nallows a developer to choose an appropriate level of detail that suits the\nauthorization policy governing a software application.\n\n\nA Permission can be represented in Yosai as a \nformatted string\n or as a\n\nPermission\n object.  First, let's consider the formatted string.\n\n\n1. String-formatted Permission\n\n\nThe following string presents a permission formatted using a syntax recognized\nby Yosai.  Please do not pay attention to the actual labels used but rather the format: \n'section1:section2item1,section2item2:section3'\n\n\nThis Permission string is composed of delimited sections, one that you should notice that includes delimited sub-sections.  As you can see, the default \nsection delimiter\n is the \ncolon\n, and the sub-section delimiter is a \ncomma\n.\n\n\nA developer can control what the sections (or 'parts') of a permission represent. However, a default implementation of a Permission is provided in Yosai and it is formatted as follows: \n'domain:action:instance'\n\n\n2. Permission object instance\n\n\nA \nDefaultPermission\n is expressed in Yosai as a \ncombination\n of resource type (domain), the action(s) that is acted upon that resource type, and instance(s) of that resource type. This three-section format suits many permission modeling requirements. However, should a developer have more complicated requirements, Permissions can be modeled in even more complicated manner.  For example, suppose you wish to set boundaries on a permission by contextualizing when a permission is granted. A permission can be bound to a particular context, also known as 'scoping', granting permission to perform an operation only under certain circumstances: \n'context:domain:action:target'\n\n\nPermission Modeling\n\n\nFollowing are a few examples of what a Permission string looks like.  We'll base these examples on Reddit \nmoderator permissioning\n, with liberties taken to their modeling so as to make it relevant for these examples.  If you are unfamiliar with the role of moderator, please \nvisit this site\n.\n\n\nModerators have management oversight of 'subreddit' message forums.\nTheir responsibilities provide them with controls to manage submissions and\ncomments (collectively, \"items\").  We'll use a few of these controls for\nour examples:\n\n\nPermission:  \"remove items\"\n\n\nThis seems straightforward, right?  A moderator can remove submissions and\ncomments.  Let's consider how item-removal permissioning may be modeled.\n\n\nOne way to model this is by using two permissions, each defining an operation\non a type of resource:\n\n\n1\n)\n \nsubmission:remove\n\n2\n)\n \ncomment:remove\n\n\n\n\n\n\nA moderator will either be assigned to a single role that includes both of these permissions or assigned to two roles where each role includes one of the above permissions.\n\n\nNote that if a moderator were to be assigned the above permissions that\nthe user would have moderator status across \nall\n of reddit.  Such power is too great and is hopefully beyond the grasp of any one individual in the production environment.  With this given, it is more likely that permission is \nscoped\n such that item removal is limited to a particular subreddit:\n\n\n1\n)\n \nsubreddit_id123:submission:remove\n\n2\n)\n \nsubreddit_id123:comment:remove\n\n\n\n\n\n\nWith these permissions, a user is \nauthorized\n to remove items within\nthe subreddit that the user is assigned a moderator role.\n\n\nPermission:  \"categorize items as NSFW\"\n\n\nThis permission marks items as not suitable for work environments. Let's add this new activity to the prior permission:\n\n\n1\n)\n \nsubreddit_id123:submission:remove, categorize_nsfw\n\n2\n)\n \nsubreddit_id123:comment:remove, categorize_nsfw\n\n\n\n\n\n\nThus far, we've defined two permissions that allow the removal of and\nlabeling of nsfw of submission and comment resource types.\n\n\nSuppose that you're a developer working for Reddit.  You receive a request to create a process for moderators to remove a message post, consisting of the submission AND the comments supporting it.  One of your team members uses the permission modeling above to provide you with a specification of the authorization that is required to remove a post:\n\n\nTo remove a post, a user must have BOTH permissions:\n\n\n1\n)\n \nsubreddit_id123:submission:remove, categorize_nsfw\n\n2\n)\n \nsubreddit_id123:comment:remove, categorize_nsfw\n\n\n\n\n\n\nYou Implement Your Authorization Policy, Yosai enforces it\n\n\nAccess control begins with an authorization policy.  A user is granted permissions through an authorization policy.  The policy states how a user is granted permission to perform an action on a type of resource, perhaps a specific resource instance, and potentially bounded by a particular context. A data model supporting the authorization policy is queried to obtain authorization information -- permissions and/or roles. The authorization policy, its data model, and the administrative system that manages the policy is decided by an organization and is outside the scope of Yosai's value proposition: Yosai enforces an authorization policy but does not provide one. Yosai obtains a user's permissions (or roles) from an outside source and then interprets them to determine whether a user is authorized.\n\n\nAuthorization Events\n\n\nAn Event is emitted to the singleton EventBus when the results of authorization are obtained.  The results are comprehensive:  every permission or role that is checked is included along with a Boolean indicating whether authorization was granted for it.  A summary \"granted\" or \"denied\" event is also communicated when a Boolean check-authorization is submitted to Yosai. If you would like to learn more about Event processing, please refer to the documentation about EventProcessing [here].\n\n\nEvents are communicated using a publish-subscribe paradigm.  In the case of\nAuthorization, the \nModularRealmAuthorizer\n publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).\n\n\nThe following table lists the Authorization-related events and subscriber(s):\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nAUTHORIZATION.GRANTED\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.DENIED\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.RESULTS\n\n\nEL\n\n\n\n\n\n\n\n\nEL = \nyosai.core.event.event.EventLogger\n\n\nAuthorization API Reference\n\n\nYosai provides role-level and permission-level access control.\n\n\nBoth levels of access control can be performed using two styles:\n\n\n\n\n\n\nThe \nDeclarative Style\n of authorization involves use of a decorator that performs one of the two levels of access control (role or permission).  The wrapped method is never called if authorization fails.\n\n\n\n\n\n\nThe \nImperative Style\n of authorization involves in-line access control within the operation that requires authorization.\n\n\n\n\n\n\nDeclarative-Style Authorization\n\n\nDeclarative-style authorization allows you to itemize access requirements for a function call.  There are two declarative-style \"authorizers\", one for permission-level and another for role-level access control.  An \nAuthorizationException\n is raised when a user fails to meet specified access requirements. Following is the API you may use for declarative-style\n\n\n    \n# Permission-level\n\n    \ndef\n \nrequires_permission\n(permission_s,\n \nlogical_operator\n=\nall):\n\n        \n\n\n        Requires that the calling Subject be authorized to the extent that is\n\n\n        required to satisfy the permission_s specified and the logical operation\n\n\n        upon them.\n\n\n\n        :param permission_s:   the permission(s) required\n\n\n        :type permission_s:  a List of Strings or List of Permission instances\n\n\n\n        :param logical_operator:  indicates whether all or at least one permission\n\n\n                                  is true (and, any)\n\n\n        :type: and OR all (from python standard library)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          permission\n\n\n        \n\n        \npass\n\n\n\n    \n# Role-level\n\n    \ndef\n \nrequires_role\n(roleid_s,\n \nlogical_operator\n=\nall):\n\n        \n\n\n        Requires that the calling Subject be authorized to the extent that is\n\n\n        required to satisfy the roleid_s specified and the logical operation\n\n\n        upon them.\n\n\n\n        :param roleid_s:   a collection of the role(s) required, specified by\n\n\n                           identifiers (such as a role name)\n\n\n        :type roleid_s:  a List of Strings\n\n\n\n        :param logical_operator:  indicates whether all or at least one permission\n\n\n                                  is true (and, any)\n\n\n        :type: and OR all (from python standard library)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          role membership\n\n\n        \n\n        \npass\n\n\n\n\n\n\nlogical_operator\n, the second parameter of both declarative-style authorizers, can be either \nany\n or \nall\n functions from the python standard library.  Use \nany\n when you want to evaluate each item \nindependently\n of the others and \nall\n when you want to evaluate items \ncollectively\n.\n\n\nExample 1:  All Permissions are Required\n\n\nThe following permissions are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@requires_permission\n([\ndomain1:action1\n,\n \ndomain2:action2\n],\n \nall)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nExample 2:  Any Permission Specified is Acceptable\n\n\nThe following permissions are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@requires_permission\n([\ndomain1:action1\n,\n \ndomain2:action2\n],\n \nany)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nExample 3:  All Roles are Required\n\n\nThe following roles are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:\n\n\n    \n@requires_role\n([\nrole1\n,\n \nrole2\n],\n \nall)\n\n    \ndef\n \nthis_function\n(\n...\n):\n\n        \n...\n\n\n\n\n\n\nExample 4:  Any Role Specified is Acceptable\n\n\nThe following roles are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:\n\n\n@requires_role\n([\nrole1\n,\n \nrole2\n],\n \nany)\n\n\ndef\n \nthis_function\n(\n...\n):\n\n    \n...\n\n\n\n\n\n\nImperative-Style Authorization\n\n\nImperative-Style authorization is used when you want to control access from within your source code, step by step, with more control over the process of checking access and responding to authorization results.  It is the more \"granular\" of the two styles.\n\n\nFollowing is the API you may use for imperative-style authorization:\n\n\n# Permission-level methods:\n\n\n# -------------------------------------------------\n\n    \ndef\n \nis_permitted\n(permission_s):\n\n        \n\n\n        Determines whether any Permission(s) associated with the subject\n\n\n        implies the requested Permission(s) provided.\n\n\n\n        :param permission_s: a collection of 1..N permissions, all of the same type\n\n\n        :type permission_s: List of Permission object(s) or String(s)\n\n\n\n        :returns: a List of tuple(s), containing the authz_abcs.Permission and a\n\n\n                  Boolean indicating whether the permission is granted\n\n\n        \n\n        \npass\n\n\n    \ndef\n \nis_permitted_collective\n(permission_s,\n \nlogical_operator):\n\n        \n\n\n        This method determines whether the requested Permission(s) are\n\n\n        collectively granted authorization.  The Permission(s) associated with\n\n\n        the subject are evaluated to determine whether authorization is implied\n\n\n        for each Permission requested.  Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        If operator=ANY: returns True if any requested permission is implied permission\n\n\n        If operator=ALL: returns True if all requested permissions are implied permission\n\n\n        Else returns False\n\n\n\n        :param permission_s:  a List of authz_abcs.Permission objects\n\n\n\n        :param logical_operator:  indicates whether *all* or at least one\n\n\n                                  permission check is true, *any*\n\n\n        :type: and OR all (functions from python stdlib)\n\n\n\n        :returns: a Boolean\n\n\n        \n\n        \npass\n\n\n    \ndef\n \ncheck_permission\n(permission_s,\n \nlogical_operator):\n\n        \n\n\n        This method determines whether the requested Permission(s) are\n\n\n        collectively granted authorization.  The Permission(s) associated with\n\n\n        the subject are evaluated to determine whether authorization is implied\n\n\n        for each Permission requested.  Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        This method is similar to `is_permitted_collective` except that it\n\n\n        raises an AuthorizationException if collectively False else does not\n\n\n        return any value.\n\n\n\n        :param permission_s: a collection of 1..N permissions\n\n\n        :type permission_s: List of authz_abcs.Permission objects or Strings\n\n\n\n        :param logical_operator:  indicates whether all or at least one\n\n\n                                  permission check is true (any)\n\n\n        :type: and OR all (from python stdlib)\n\n\n\n        :raises UnauthorizedException: if any permission is unauthorized\n\n\n        \n\n\n\n\n# Role-level methods:\n\n\n# -------------------------------------------------\n\n    \ndef\n \nhas_role\n(roleid_s):\n\n        \n\n\n        Determines whether a Subject is a member of the Role(s) requested\n\n\n\n        :param roleid_s: 1..N role identifiers (strings)\n\n\n        :type roleid_s:  Set of Strings\n\n\n\n        :returns: a frozenset of tuple(s), each containing the Role identifier\n\n\n                  requested and a Boolean indicating whether the subject is\n\n\n                  a member of that Role\n\n\n                  - the tuple format is: (roleid, Boolean)\n\n\n        \n\n        \npass\n\n\n    \ndef\n \nhas_role_collective\n(roleid_s,\n \nlogical_operator):\n\n        \n\n\n        This method determines whether the Subject\ns role membership\n\n\n        collectively grants authorization for the roles requested.  The\n\n\n        Role(s) associated with the subject are evaluated to determine\n\n\n        whether the roles requested are sufficiently addressed by those that\n\n\n        the Subject is a member of. Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        If operator=ANY, returns True if any requested role membership is\n\n\n                         satisfied\n\n\n        If operator=ALL: returns True if all of the requested permissions are\n\n\n                         implied permission\n\n\n        Else returns False\n\n\n\n        :param roleid_s: 1..N role identifiers (strings)\n\n\n        :type roleid_s:  Set of Strings\n\n\n\n        :param logical_operator:  any or all\n\n\n        :type logical_operator:  function  (stdlib)\n\n\n\n        :rtype:  bool\n\n\n        \n\n        \npass\n\n\n    \ndef\n \ncheck_role\n(role_ids,\n \nlogical_operator):\n\n        \n\n\n        This method determines whether the Subject\ns role membership\n\n\n        collectively grants authorization for the roles requested.  The\n\n\n        Role(s) associated with the subject are evaluated to determine\n\n\n        whether the roles requested are sufficiently addressed by those that\n\n\n        the Subject is a member of. Results are collectively evaluated using\n\n\n        the logical operation provided: either ANY or ALL.\n\n\n\n        This method is similar to has_role_collective except that it raises\n\n\n        an AuthorizationException if collectively False else does not return any\n\n\n\n        :param roleid_s: 1..N role identifiers (strings)\n\n\n        :type roleid_s:  Set of Strings\n\n\n\n        :param logical_operator:  any or all\n\n\n        :type logical_operator:  function  (stdlib)\n\n\n\n        :raises  AuthorizationException:  if the user does not have sufficient\n\n\n                                          role membership\n\n\n        \n\n        \npass\n\n\n\n\n\n\nThe first argument of every method is a List containing \neither\n authorization object instances (\nPermission\n or \nRole\n) \nor\n String(s). Yosai does \nnot\n support a commingling of the two supported types.\n\n\nYou will notice that some of the methods in the imperative-style authorization API include a second parameter, \nlogical_operator\n.  This parameter can be one of two values: either \nany\n or \nall\n functions from the python standard library.  Use \nany\n when you want to evaluate each item \nindependently\n of the others and \nall\n when you want to evaluate items \ncollectively\n.\n\n\nExample 1:  is_permitted\n\n\n    \ncurrent_user\n \n=\n \nsubject\n.\nget_subject()\n\n    \nresults\n \n=\n \ncurrent_user\n.\nis_permitted([\ndomain1:action1\n,\n \ndomain2:action2\n])\n\n\n    \nif\n \nany(is_permitted\n \nfor\n \npermission,\n \nis_permitted\n \nin\n \nresults):\n\n        \nprint\n(\nany permission is granted\n)\n\n\n    \nif\n \nall(is_permitted\n \nfor\n \npermission,\n \nis_permitted\n \nin\n \nresults):\n\n        \nprint\n(\nall permission is granted, too!\n)\n\n\n\n\n\n\n\n\nresults\n is a list of tuples, each containing a Permission object and a Boolean value indicating whether access is granted (True) or denied (False)\n\n\n\n\nExample 2:  is_permitted_collective\n\n\n    \ncurrent_user\n \n=\n \nsubject\n.\nget_subject()\n\n    \nany_result_check\n \n=\n \ncurrent_user\n.\nis_permitted_collective([\ndomain1:action1\n,\n\n                                                             \ndomain2:action2\n],\n \nany)\n\n    \nif\n \nany_result_check:\n\n        \nprint\n(\nany permission is granted\n)\n\n\n    \nall_result_check\n \n=\n \ncurrent_user\n.\nis_permitted_collective([\ndomain1:action1\n,\n\n                                                             \ndomain2:action2\n],\n \nall)\n\n\n    \nif\n \nall_result_check:\n\n        \nprint\n(\nall permission is granted, too!\n)\n\n\n\n\n\n\n\n\nany_result_check\n and \nall_result_check\n are Boolean values\n\n\n\n\nExample 3:  check_permission\n\n\n    \ncurrent_user\n \n=\n \nsubject\n.\nget_subject()\n\n    \ntry\n:\n\n        \ncurrent_user\n.\ncheck_permission([\ndomain1:action1\n,\n\n                                       \ndomain2:action2\n],\n\n                                      \nany)\n\n    \nexcept\n \nAuthorizationException:\n\n        \nprint\n(\nany permission denied\n)\n\n    \nelse\n:\n\n        \nprint\n(\nany permission granted\n)\n\n\n    \ntry\n:\n\n        \ncurrent_user\n.\ncheck_permission([\ndomain1:action1\n,\n\n                                       \ndomain2:action2\n],\n\n                                      \nall)\n\n    \nexcept\n \nAuthorizationException:\n\n        \nprint\n(\nall permission denied\n)\n\n    \nelse\n:\n\n        \nprint\n(\nall permission granted\n)\n\n\n\n\n\n\n\n\ncheck_permission\n succeeds quietly else raises an AuthorizationException\n\n\n\n\nExample 1:  has_role\n\n\n    \ncurrent_user\n \n=\n \nsubject\n.\nget_subject()\n\n    \nresults\n \n=\n \ncurrent_user\n.\nhas_role([\nrole1\n,\n \nrole2\n])\n\n\n    \nif\n \nany(has_role\n \nfor\n \nrole,\n \nhas_role\n \nin\n \nresults):\n\n        \nprint\n(\nany role is confirmed\n)\n\n\n    \nif\n \nall(has_role\n \nfor\n \nrole,\n \nhas_role\n \nin\n \nresults):\n\n        \nprint\n(\nall role is confirmed, too!\n)\n\n\n\n\n\n\n\n\nresults\n is a list of tuples, each containing a Role and a Boolean value indicating whether role membership is confirmed (True if so)\n\n\n\n\nExample 2:  has_role_collective\n\n\n    \ncurrent_user\n \n=\n \nsubject\n.\nget_subject()\n\n    \nany_result_check\n \n=\n \ncurrent_user\n.\nhas_role_collective([\nrole1\n,\n \nrole2\n],\n \nany)\n\n\n    \nif\n \nany_result_check:\n\n        \nprint\n(\nany role is confirmed\n)\n\n\n    \nall_result_check\n \n=\n \ncurrent_user\n.\nhas_role_collective([\nrole1\n,\n \nrole2\n],\n \nall)\n\n\n    \nif\n \nall_result_check:\n\n        \nprint\n(\nall role is confirmed, too!\n)\n\n\n\n\n\n\n\n\nany_result_check\n and \nall_result_check\n are Boolean values\n\n\n\n\nExample 3:  check_role\n\n\n    \ncurrent_user\n \n=\n \nsubject\n.\nget_subject()\n\n    \ntry\n:\n\n        \ncurrent_user\n.\ncheck_role([\nrole1\n,\n \nrole2\n],\n \nany)\n\n\n    \nexcept\n \nAuthorizationException:\n\n        \nprint\n(\nany role denied\n)\n\n    \nelse\n:\n\n        \nprint\n(\nany role confirmed\n)\n\n\n    \ntry\n:\n\n        \ncurrent_user\n.\ncheck_role([\nrole1\n,\n \nrole2\n],\n \nall)\n\n\n    \nexcept\n \nAuthorizationException:\n\n        \nprint\n(\nall role denied\n)\n\n    \nelse\n:\n\n        \nprint\n(\nall role confirmed\n)\n\n\n\n\n\n\n\n\ncheck_role\n succeeds quietly else raises an AuthorizationException\n\n\n\n\nReferences\n\n\nOWASP Access Control Cheat Sheet",
            "title": "Authorization"
        },
        {
            "location": "/authorization/#authorization",
            "text": "Authorization, also known as Access Control, is concerned with the rules and\nmechanisms governing how someone or something accesses resources (in this context, within a software application). Informally speaking, authorization is concerned with \u201cwho can do what\u201d.",
            "title": "Authorization"
        },
        {
            "location": "/authorization/#role-based-access-control",
            "text": "There are many access control models  in use today .  By default, Yosai\nenforces access control by evaluating roles and permissions assigned to a user.\nThese roles and permissions are derived from a Role-Based Access Control (RBAC) model. Note that although a default support for RBAC is provided, your Realm\nimplementation ultimately decides how your permissions and roles are grouped\ntogether and whether to return a \u201cyes\u201d or a \u201cno\u201d answer to Yosai.  This feature\nallows you to architect your application in the manner you chose.  For more information about RBAC  yosai.core  obtains roles and permissions from a repository, such as a\nrelational database.  Designing and implementing the RBAC data model and its\nauthorization policy it represents are concerns beyond the scope\nof yosai.core. As mentioned earlier, Yosai can support any data model for\naccess control and doesn\u2019t force one on you.  However, a basic, flat RBAC\nmodel was implemented for Yosai,  as an extension , so to facilitate other extension projects.",
            "title": "Role-Based Access Control"
        },
        {
            "location": "/authorization/#key-concepts",
            "text": "The key concepts to understand about authorization in Yosai involve these relationships:   Permissions are  associated with  roles. Users are  assigned to  roles.  A  Permission  specifies an action performed in the system on a resource.  A  Role  is a group of permissions. Organizations are known to group permissions\nby task or various job functions. Roles can be granted new permissions as new\napplications and systems are incorporated, and permissions can be revoked from\nroles as needed.  A  User  refers to a person who interfaces with the software application.\nA user is provided a user account that allows an application to uniquely\nidentify it.  User accounts are often identified by a Username/UserID\nattribute or email address.  Users are assigned roles based on the user's\nresponsibilities and qualifications. Users can be easily reassigned from one role\nto another.  Yosai obtains a user's authorization information (assigned permissions\nand role memberships) and then determines whether the user meets\nthe access required to perform an operation in an application.",
            "title": "Key Concepts"
        },
        {
            "location": "/authorization/#access-control-levels-and-styles",
            "text": "Two \"levels\" of access control are available:   role-level  and  permission-level .  Yosai supports \"explicit\" role-level access control.  With explicit role-level\naccess control, a developer specifies the role names that are required to gain\naccess to an operation.  Permission-level access control is considered superior to role level.\nWith it, a developer can model authorization requirements ranging from the most\nsummary to the most detailed.  Both levels of access control can be performed using two styles:    The  declarative style  of authorization involves use of a decorator that performs one of the two levels of access control.  The wrapped method is never called if authorization fails.    The  imperative style  of authorization involves in-line access control within the operation that requires authorization.",
            "title": "Access Control Levels and Styles"
        },
        {
            "location": "/authorization/#levels-and-styles-illustrated",
            "text": "Following is an example of what role-level authorization looks like when using\neither style of access control.  In this example, we only allow a user to\ndelete a comment from a message board (subreddit) if the user is a moderator or\nadmin.  In other words, the user is a member of  either  the moderator or admin\nroles.  In reality, we would layer additional access control to the\nremove_comment method so that the creator of the post may also delete the\ncomment, but this detail is left out for simplicity's sake and only to\nhighlight role-level access control:",
            "title": "Levels and Styles Illustrated"
        },
        {
            "location": "/authorization/#declarative-style",
            "text": "@requires_role (roleid_s = [ moderator ,   admin ],   logical_operator = any)  def   remove_comment (self,   submission): \n    self . database_handler . delete(submission)",
            "title": "Declarative Style"
        },
        {
            "location": "/authorization/#imperative-style",
            "text": "def   remove_comment (self,   submission): \n     subject   =   SecurityUtils . get_subject() \n\n     try : \n         subject . check_role([ moderator ,   creator ],   logical_operator = any) \n     except   UnauthorizedException: \n         print ( Cannot remove comment:  Access Denied. ) \n\n     self . database_handler . delete(submission)    Role-level access control is inferior to permission-level access control, but since it has its niche use, is available in Yosai.  It is highly recommended that you choose permission-level access control policies for your application.",
            "title": "Imperative Style"
        },
        {
            "location": "/authorization/#permissions",
            "text": "A permission states what behavior can be performed in an application but not who\ncan perform them. Permissions are modeled in Yosai using a flexible design that\nallows a developer to choose an appropriate level of detail that suits the\nauthorization policy governing a software application.  A Permission can be represented in Yosai as a  formatted string  or as a Permission  object.  First, let's consider the formatted string.",
            "title": "Permissions"
        },
        {
            "location": "/authorization/#1-string-formatted-permission",
            "text": "The following string presents a permission formatted using a syntax recognized\nby Yosai.  Please do not pay attention to the actual labels used but rather the format:  'section1:section2item1,section2item2:section3'  This Permission string is composed of delimited sections, one that you should notice that includes delimited sub-sections.  As you can see, the default  section delimiter  is the  colon , and the sub-section delimiter is a  comma .  A developer can control what the sections (or 'parts') of a permission represent. However, a default implementation of a Permission is provided in Yosai and it is formatted as follows:  'domain:action:instance'",
            "title": "1. String-formatted Permission"
        },
        {
            "location": "/authorization/#2-permission-object-instance",
            "text": "A  DefaultPermission  is expressed in Yosai as a  combination  of resource type (domain), the action(s) that is acted upon that resource type, and instance(s) of that resource type. This three-section format suits many permission modeling requirements. However, should a developer have more complicated requirements, Permissions can be modeled in even more complicated manner.  For example, suppose you wish to set boundaries on a permission by contextualizing when a permission is granted. A permission can be bound to a particular context, also known as 'scoping', granting permission to perform an operation only under certain circumstances:  'context:domain:action:target'",
            "title": "2. Permission object instance"
        },
        {
            "location": "/authorization/#permission-modeling",
            "text": "Following are a few examples of what a Permission string looks like.  We'll base these examples on Reddit  moderator permissioning , with liberties taken to their modeling so as to make it relevant for these examples.  If you are unfamiliar with the role of moderator, please  visit this site .  Moderators have management oversight of 'subreddit' message forums.\nTheir responsibilities provide them with controls to manage submissions and\ncomments (collectively, \"items\").  We'll use a few of these controls for\nour examples:",
            "title": "Permission Modeling"
        },
        {
            "location": "/authorization/#permission-remove-items",
            "text": "This seems straightforward, right?  A moderator can remove submissions and\ncomments.  Let's consider how item-removal permissioning may be modeled.  One way to model this is by using two permissions, each defining an operation\non a type of resource:  1 )   submission:remove \n2 )   comment:remove   A moderator will either be assigned to a single role that includes both of these permissions or assigned to two roles where each role includes one of the above permissions.  Note that if a moderator were to be assigned the above permissions that\nthe user would have moderator status across  all  of reddit.  Such power is too great and is hopefully beyond the grasp of any one individual in the production environment.  With this given, it is more likely that permission is  scoped  such that item removal is limited to a particular subreddit:  1 )   subreddit_id123:submission:remove \n2 )   subreddit_id123:comment:remove   With these permissions, a user is  authorized  to remove items within\nthe subreddit that the user is assigned a moderator role.",
            "title": "Permission:  \"remove items\""
        },
        {
            "location": "/authorization/#permission-categorize-items-as-nsfw",
            "text": "This permission marks items as not suitable for work environments. Let's add this new activity to the prior permission:  1 )   subreddit_id123:submission:remove, categorize_nsfw \n2 )   subreddit_id123:comment:remove, categorize_nsfw   Thus far, we've defined two permissions that allow the removal of and\nlabeling of nsfw of submission and comment resource types.  Suppose that you're a developer working for Reddit.  You receive a request to create a process for moderators to remove a message post, consisting of the submission AND the comments supporting it.  One of your team members uses the permission modeling above to provide you with a specification of the authorization that is required to remove a post:  To remove a post, a user must have BOTH permissions:  1 )   subreddit_id123:submission:remove, categorize_nsfw \n2 )   subreddit_id123:comment:remove, categorize_nsfw",
            "title": "Permission:  \"categorize items as NSFW\""
        },
        {
            "location": "/authorization/#you-implement-your-authorization-policy-yosai-enforces-it",
            "text": "Access control begins with an authorization policy.  A user is granted permissions through an authorization policy.  The policy states how a user is granted permission to perform an action on a type of resource, perhaps a specific resource instance, and potentially bounded by a particular context. A data model supporting the authorization policy is queried to obtain authorization information -- permissions and/or roles. The authorization policy, its data model, and the administrative system that manages the policy is decided by an organization and is outside the scope of Yosai's value proposition: Yosai enforces an authorization policy but does not provide one. Yosai obtains a user's permissions (or roles) from an outside source and then interprets them to determine whether a user is authorized.",
            "title": "You Implement Your Authorization Policy, Yosai enforces it"
        },
        {
            "location": "/authorization/#authorization-events",
            "text": "An Event is emitted to the singleton EventBus when the results of authorization are obtained.  The results are comprehensive:  every permission or role that is checked is included along with a Boolean indicating whether authorization was granted for it.  A summary \"granted\" or \"denied\" event is also communicated when a Boolean check-authorization is submitted to Yosai. If you would like to learn more about Event processing, please refer to the documentation about EventProcessing [here].  Events are communicated using a publish-subscribe paradigm.  In the case of\nAuthorization, the  ModularRealmAuthorizer  publishes an event to a channel (an\ninternal Event Bus). The EventBus relays an event to consumers who have\nsubscribed to the event's topic. It relays the event by calling the callback\nmethod registered for a consumer, using the event payload as its argument(s).  The following table lists the Authorization-related events and subscriber(s):     Event Topic  Subscriber(s)      AUTHORIZATION.GRANTED  EL    AUTHORIZATION.DENIED  EL    AUTHORIZATION.RESULTS  EL     EL =  yosai.core.event.event.EventLogger",
            "title": "Authorization Events"
        },
        {
            "location": "/authorization/#authorization-api-reference",
            "text": "Yosai provides role-level and permission-level access control.  Both levels of access control can be performed using two styles:    The  Declarative Style  of authorization involves use of a decorator that performs one of the two levels of access control (role or permission).  The wrapped method is never called if authorization fails.    The  Imperative Style  of authorization involves in-line access control within the operation that requires authorization.",
            "title": "Authorization API Reference"
        },
        {
            "location": "/authorization/#declarative-style-authorization",
            "text": "Declarative-style authorization allows you to itemize access requirements for a function call.  There are two declarative-style \"authorizers\", one for permission-level and another for role-level access control.  An  AuthorizationException  is raised when a user fails to meet specified access requirements. Following is the API you may use for declarative-style       # Permission-level \n     def   requires_permission (permission_s,   logical_operator = all): \n                  Requires that the calling Subject be authorized to the extent that is          required to satisfy the permission_s specified and the logical operation          upon them.          :param permission_s:   the permission(s) required          :type permission_s:  a List of Strings or List of Permission instances          :param logical_operator:  indicates whether all or at least one permission                                    is true (and, any)          :type: and OR all (from python standard library)          :raises  AuthorizationException:  if the user does not have sufficient                                            permission           \n         pass \n\n\n     # Role-level \n     def   requires_role (roleid_s,   logical_operator = all): \n                  Requires that the calling Subject be authorized to the extent that is          required to satisfy the roleid_s specified and the logical operation          upon them.          :param roleid_s:   a collection of the role(s) required, specified by                             identifiers (such as a role name)          :type roleid_s:  a List of Strings          :param logical_operator:  indicates whether all or at least one permission                                    is true (and, any)          :type: and OR all (from python standard library)          :raises  AuthorizationException:  if the user does not have sufficient                                            role membership           \n         pass   logical_operator , the second parameter of both declarative-style authorizers, can be either  any  or  all  functions from the python standard library.  Use  any  when you want to evaluate each item  independently  of the others and  all  when you want to evaluate items  collectively .",
            "title": "Declarative-Style Authorization"
        },
        {
            "location": "/authorization/#example-1-all-permissions-are-required",
            "text": "The following permissions are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:       @requires_permission ([ domain1:action1 ,   domain2:action2 ],   all) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 1:  All Permissions are Required"
        },
        {
            "location": "/authorization/#example-2-any-permission-specified-is-acceptable",
            "text": "The following permissions are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:       @requires_permission ([ domain1:action1 ,   domain2:action2 ],   any) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 2:  Any Permission Specified is Acceptable"
        },
        {
            "location": "/authorization/#example-3-all-roles-are-required",
            "text": "The following roles are required, collectively, to call this_function.\nWhen this_function is called, the caller of this_function should be ready to handle an AuthorizationException if the user is denied access:       @requires_role ([ role1 ,   role2 ],   all) \n     def   this_function ( ... ): \n         ...",
            "title": "Example 3:  All Roles are Required"
        },
        {
            "location": "/authorization/#example-4-any-role-specified-is-acceptable",
            "text": "The following roles are required, each independently satisfying the access control requirement, to call this_function. When this_function is called, the caller should be ready to handle an AuthorizationException if the user is denied access:  @requires_role ([ role1 ,   role2 ],   any)  def   this_function ( ... ): \n     ...",
            "title": "Example 4:  Any Role Specified is Acceptable"
        },
        {
            "location": "/authorization/#imperative-style-authorization",
            "text": "Imperative-Style authorization is used when you want to control access from within your source code, step by step, with more control over the process of checking access and responding to authorization results.  It is the more \"granular\" of the two styles.  Following is the API you may use for imperative-style authorization:  # Permission-level methods:  # ------------------------------------------------- \n     def   is_permitted (permission_s): \n                  Determines whether any Permission(s) associated with the subject          implies the requested Permission(s) provided.          :param permission_s: a collection of 1..N permissions, all of the same type          :type permission_s: List of Permission object(s) or String(s)          :returns: a List of tuple(s), containing the authz_abcs.Permission and a                    Boolean indicating whether the permission is granted           \n         pass \n\n     def   is_permitted_collective (permission_s,   logical_operator): \n                  This method determines whether the requested Permission(s) are          collectively granted authorization.  The Permission(s) associated with          the subject are evaluated to determine whether authorization is implied          for each Permission requested.  Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          If operator=ANY: returns True if any requested permission is implied permission          If operator=ALL: returns True if all requested permissions are implied permission          Else returns False          :param permission_s:  a List of authz_abcs.Permission objects          :param logical_operator:  indicates whether *all* or at least one                                    permission check is true, *any*          :type: and OR all (functions from python stdlib)          :returns: a Boolean           \n         pass \n\n     def   check_permission (permission_s,   logical_operator): \n                  This method determines whether the requested Permission(s) are          collectively granted authorization.  The Permission(s) associated with          the subject are evaluated to determine whether authorization is implied          for each Permission requested.  Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          This method is similar to `is_permitted_collective` except that it          raises an AuthorizationException if collectively False else does not          return any value.          :param permission_s: a collection of 1..N permissions          :type permission_s: List of authz_abcs.Permission objects or Strings          :param logical_operator:  indicates whether all or at least one                                    permission check is true (any)          :type: and OR all (from python stdlib)          :raises UnauthorizedException: if any permission is unauthorized            # Role-level methods:  # ------------------------------------------------- \n     def   has_role (roleid_s): \n                  Determines whether a Subject is a member of the Role(s) requested          :param roleid_s: 1..N role identifiers (strings)          :type roleid_s:  Set of Strings          :returns: a frozenset of tuple(s), each containing the Role identifier                    requested and a Boolean indicating whether the subject is                    a member of that Role                    - the tuple format is: (roleid, Boolean)           \n         pass \n\n     def   has_role_collective (roleid_s,   logical_operator): \n                  This method determines whether the Subject s role membership          collectively grants authorization for the roles requested.  The          Role(s) associated with the subject are evaluated to determine          whether the roles requested are sufficiently addressed by those that          the Subject is a member of. Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          If operator=ANY, returns True if any requested role membership is                           satisfied          If operator=ALL: returns True if all of the requested permissions are                           implied permission          Else returns False          :param roleid_s: 1..N role identifiers (strings)          :type roleid_s:  Set of Strings          :param logical_operator:  any or all          :type logical_operator:  function  (stdlib)          :rtype:  bool           \n         pass \n\n     def   check_role (role_ids,   logical_operator): \n                  This method determines whether the Subject s role membership          collectively grants authorization for the roles requested.  The          Role(s) associated with the subject are evaluated to determine          whether the roles requested are sufficiently addressed by those that          the Subject is a member of. Results are collectively evaluated using          the logical operation provided: either ANY or ALL.          This method is similar to has_role_collective except that it raises          an AuthorizationException if collectively False else does not return any          :param roleid_s: 1..N role identifiers (strings)          :type roleid_s:  Set of Strings          :param logical_operator:  any or all          :type logical_operator:  function  (stdlib)          :raises  AuthorizationException:  if the user does not have sufficient                                            role membership           \n         pass   The first argument of every method is a List containing  either  authorization object instances ( Permission  or  Role )  or  String(s). Yosai does  not  support a commingling of the two supported types.  You will notice that some of the methods in the imperative-style authorization API include a second parameter,  logical_operator .  This parameter can be one of two values: either  any  or  all  functions from the python standard library.  Use  any  when you want to evaluate each item  independently  of the others and  all  when you want to evaluate items  collectively .",
            "title": "Imperative-Style Authorization"
        },
        {
            "location": "/authorization/#example-1-is_permitted",
            "text": "current_user   =   subject . get_subject() \n     results   =   current_user . is_permitted([ domain1:action1 ,   domain2:action2 ]) \n\n     if   any(is_permitted   for   permission,   is_permitted   in   results): \n         print ( any permission is granted ) \n\n     if   all(is_permitted   for   permission,   is_permitted   in   results): \n         print ( all permission is granted, too! )    results  is a list of tuples, each containing a Permission object and a Boolean value indicating whether access is granted (True) or denied (False)",
            "title": "Example 1:  is_permitted"
        },
        {
            "location": "/authorization/#example-2-is_permitted_collective",
            "text": "current_user   =   subject . get_subject() \n     any_result_check   =   current_user . is_permitted_collective([ domain1:action1 , \n                                                              domain2:action2 ],   any) \n     if   any_result_check: \n         print ( any permission is granted ) \n\n     all_result_check   =   current_user . is_permitted_collective([ domain1:action1 , \n                                                              domain2:action2 ],   all) \n\n     if   all_result_check: \n         print ( all permission is granted, too! )    any_result_check  and  all_result_check  are Boolean values",
            "title": "Example 2:  is_permitted_collective"
        },
        {
            "location": "/authorization/#example-3-check_permission",
            "text": "current_user   =   subject . get_subject() \n     try : \n         current_user . check_permission([ domain1:action1 , \n                                        domain2:action2 ], \n                                       any) \n     except   AuthorizationException: \n         print ( any permission denied ) \n     else : \n         print ( any permission granted ) \n\n     try : \n         current_user . check_permission([ domain1:action1 , \n                                        domain2:action2 ], \n                                       all) \n     except   AuthorizationException: \n         print ( all permission denied ) \n     else : \n         print ( all permission granted )    check_permission  succeeds quietly else raises an AuthorizationException",
            "title": "Example 3:  check_permission"
        },
        {
            "location": "/authorization/#example-1-has_role",
            "text": "current_user   =   subject . get_subject() \n     results   =   current_user . has_role([ role1 ,   role2 ]) \n\n     if   any(has_role   for   role,   has_role   in   results): \n         print ( any role is confirmed ) \n\n     if   all(has_role   for   role,   has_role   in   results): \n         print ( all role is confirmed, too! )    results  is a list of tuples, each containing a Role and a Boolean value indicating whether role membership is confirmed (True if so)",
            "title": "Example 1:  has_role"
        },
        {
            "location": "/authorization/#example-2-has_role_collective",
            "text": "current_user   =   subject . get_subject() \n     any_result_check   =   current_user . has_role_collective([ role1 ,   role2 ],   any) \n\n     if   any_result_check: \n         print ( any role is confirmed ) \n\n     all_result_check   =   current_user . has_role_collective([ role1 ,   role2 ],   all) \n\n     if   all_result_check: \n         print ( all role is confirmed, too! )    any_result_check  and  all_result_check  are Boolean values",
            "title": "Example 2:  has_role_collective"
        },
        {
            "location": "/authorization/#example-3-check_role",
            "text": "current_user   =   subject . get_subject() \n     try : \n         current_user . check_role([ role1 ,   role2 ],   any) \n\n     except   AuthorizationException: \n         print ( any role denied ) \n     else : \n         print ( any role confirmed ) \n\n     try : \n         current_user . check_role([ role1 ,   role2 ],   all) \n\n     except   AuthorizationException: \n         print ( all role denied ) \n     else : \n         print ( all role confirmed )    check_role  succeeds quietly else raises an AuthorizationException",
            "title": "Example 3:  check_role"
        },
        {
            "location": "/authorization/#references",
            "text": "OWASP Access Control Cheat Sheet",
            "title": "References"
        },
        {
            "location": "/sessionmanagement/",
            "text": "Sessions and Session Management\n\n\n\n\nUse Sessions to track the state of a user's interactions with your application across multiple requests, over a specified period of time.  Tracking user state with Sessions enables more feature-rich user experiences.  Further, Sessions play a major role in access control.\n\n\nSession Management involves creating, reading, updating, and deleting of Sessions and Session attributes, and validating Sessions.\n\n\nYosai's \nSessionManager\n uses a \nCachingSessionStore\n to cache sessions. If you are not caching sessions, you you are either using in-memory session storage  (the \nMemorySessionStore\n) or using your own custom SessionStore, which is beyond the scope of consideration in this documentation.\n\n\nAuthentication, Authorization, and Session Management are Related\n\n\nAccess is limited by user identity: a guest cannot perform the operations that an authenticated user can, and each authenticated user may perform different operations.\n\n\nThe identity of an authenticated user is recorded in the Session.\n\n\nSince access control is limited by identity, and identity is obtained from a Session, access control is considered \nbound\n to a Session.\n\n\nProperties of a Session , Session Risk, and Risk Countermeasures\n\n\nSessions are a \"threat vector\":  a path that an \"actor\" may exploit to attack a \"target\" (your application).  Sessions are exploited by a process known as hijacking.  Session Management helps to manage many of the inherent risks of Sessions through a series of countermeasures.  More information about these countermeasures follows in the documentation.\n\n\nThe Session Token\n\n\nA Session Token is like a smart chip, or magnetic strip, on a credit card in that it contains identification-- a session identifier (SessionID).  However, unlike the elements of a credit card, the Session Token has a much shorter lifespan.\n\n\nThe \nSessionID\n is a sensitive and critical piece of information.  It uniquely identifies a Session.  It is the Session's key in a SessionStore (cache) and it is the key that is sent with subsequent requests by a client (the user).\n\n\nOnce an authenticated session is established, the \nSessionID\n is the client's key to Yosai.  Therefore, it is very important that the session identifier be unique and very difficult to reproduce.  \n\n\nYosai's default method to generate a \nSessionID\n is as follows:\n\nsha256(sha512(urandom(20)).digest()).hexdigest()\n\n\nTemporal Risks and Countermeasures\n\n\nThe risk of compromising a Session increases as time passes.  To address time-driven risks, Yosai defines temporal properties in a Session -- idle time and maximum allowable time to live (TTL) -- that enable \"timing out\" of Sessions.\n\n\nWhen a Session \"times out\", it is considered \nexpired\n.  When a Session is \nexpired\n, it can no longer be used in Yosai, and therefore is no longer at risk of being hijacked.\n\n\nThe timeout thresholds are configured in the Yosai settings YAML file. Should you find their default settings unacceptable, you can easily change them.  The default settings are somewhat aggressive so as to minimize the risks that defaults may present and to encourage developers to take ownership of session time-out decisions.\n\n\nIdle time\n\n\n\n\nThis property represents the total permissible time for a user to be inactive in a system, or idle.  Picture idle timeout as an hourglass that is turned over and reset periodically. The way that idle time is reset is by updating the Session's \nlast_access_time\n attribute.  As to when the \nlast_access_time\n is updated depends on what \"auto_touch\" has been configured to or whether you've chosen an alternative time to touch than the default (per-access).\n\n\nA \nDefaultNativeSessionManager\n has an attribute, \"auto_touch\", that when set to True will allow the updating of a Session's \nlast_access_time\n attribute to the current time, whenever a session is accessed, following Session validation. As mentioned, when a Session should be touched depends on the type of application you are developing and thus auto_touch is a configurable feature.  When a Session is obtained from the SessionStore, it is immediately validated.  Should the validation not raise any exceptions, and if auto_touch is True, the Session will be \"touched\".  Touching a Session is the process of flipping and resetting the hourglass, so to speak, by updating the \nlast_access_time\n attribute of the Session.\n\n\nYosai's default idle time setting for a Session is \n5 minutes\n.\n\n\nTime to live\n\n\n\n\nA Session has a maximum allowable time period that it may exist.  It is the final countdown until a Session is expired. It cannot be reset, unlike idle timeout. Many computer systems refer to this as a TTL -- time to live.  Yosai's default time-to-live for a Session is \n30 minutes\n.\n\n\nStopping Sessions\n\n\nAside from expirations, another mechanism for rendering Sessions useless in is \nstopping\n them.  When a subject logs out of a system, the subject's Session is stopped.  Like an expired Session, a \nstopped\n Session can no longer be used and is consequently no longer at risk of being hijacked.\n\n\nSession Validation\n\n\nSession Validation is the process of determining whether a Session has stopped or expired.  When a session has stopped or expired, it is considered \ninvalid\n.\n\n\nA Session expires when the time duration between the current time and the last recorded time that a Session was accessed exceeds either timeout threshold.\n\n\nKeeping track of idle expiration presents performance challenges.  Therefore, Sessions are validated \nonly\n when they are accessed (i.e. subject.get_session()).\n\n\nthe last_access_timestamp synchronized with session usage presents a\n\n\nif the duration between the last_access_timestamp and the current time exceeds either timeout threshold, a session is considered expired\n\n\nBy default, Sessions are \"lazy validated\" in that they are validated at the time that [they are accessed?].\n\n\nAs discussed in an earlier section above, access control is \nbound\n to a Session. Since access control is \nbound\n to a Session, when a Session is invalidated so too does the authorization information cached for the Session.  Invalid authorization information is cleared from cache through event handling.\n\n\nIdle Timeout Edge Case\n\n\nMonitoring for idle timeout increases the complexity of Session Management.\nAs discussed, Session validation taxes the performance of an application and\ntherefore does not run before every authorization check.  Instead, validation\nis designed to maximize utility for the most popular use case-- one where the\nsubject instance has a short life span in memory and sessions validate when\nthey are accessed.\n\n\nTherefore, it is recommended that you release a Subject instance for garbage\ncollection between requests.\n\n\nThe Session Synchronization Design Challenge\n\n\nKeeping the last_access_timestamp synchronized with session usage presents a performance design challenge that you are encouraged to help improve.  Ideas are welcome!\n\n\nSession Invalidation\n\n\nBy default, whenever Yosai detects an invalid session, it attempts to delete it from the underlying session data store via the SessionStore.delete(session) method.  However, should you decide not to automatically delete invalid sessions, you can easily opt-out of this process.  For example, if your application uses a SessionStore that backs a queryable data store, perhaps your dev team wants old or invalid sessions to be available for a certain period of time. Storing invalid sessions would allow you to run queries against the data store to see, for example, how many sessions a user has created over the last week, or the average duration of a user's sessions, or similar reporting-type queries.\n\n\nAt Session expiration, Yosai ties up loose ends, so to speak, through its event-driven architecture.\n\n\nSession Usage\n\n\nSession Initialization\n\n\nA Session can be used to manage state for a Subject regardless of whether the Subject has authenticated itself or remains anonymous.  Yosai initializes a server-side Session the moment that a Subject is instantiated:\n\n\nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils,\n \nUsernamePasswordToken\n\n\n\n# creates an \nanonymous session\n if the current executing subject hasn\nt\n\n\n# logged in yet:\n\n\nguest\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n\n\n\n\n\nYou can then manage state as necessary using the session, but more about that later: .. code-block:: python     session = guest.get_session()  # returns an anonymous session (guest)\n\n\nAfter a user authenticates itself, Yosai creates a new session for the user. This is done for a few reasons.  The user's access to the system changes as the user's identity changes (from anonymous to authenticated).  A new, \"authenticated session\" replaces the \"anonymous session\" the moment that a subject is authenticated as a user:\n\n\nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils,\n \nUsernamePasswordToken\n\n\n\n# creates an \nanonymous session\n if the current executing subject hasn\nt\n\n\n# logged in yet:\n\n\ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n\n\nauthc_token\n \n=\n \nUsernamePasswordToken(username\n=\nthedude\n,\n\n                                    \ncredentials\n=\nletsgobowling\n)\n\n\n\n# creates an \nauthenticated session\n if login in successful, raising\n\n\n# an exception otherwise (try/except left out to simplify the example):\n\n\ncurrent_user\n.\nlogin(authc_token)\n\n\n\n\n\n\n\n\nIt is recommended that the session be regenerated by the application after     \nany\n privilege level change within the associated user session.\n\n\n\n\nSession Storage\n\n\nWhenever a Session is created or updated, its data is persisted to a storage location so that it may be accessible by the application at a later time. Similarly, when a Session is invalid and longer being used, it is deleted from storage so that the Session data store space is not exhausted (if you're not taking advantage of TTL expiration in your data store).\n\n\nThe SessionManager implementations delegate these Create/Read/Update/Delete (CRUD) operations to an internal component, the SessionStore, which reflects the Data Access Object (DAO) design pattern.\n\n\nThe power of the SessionStore is that you can implement this interface to communicate with any data store you wish. This means your session data can reside in memory, on the file system, in a relational database or NoSQL data store, or any other location you want. You have control over persistence behavior.\n\n\nYosai features an in-memory MemorySessionStore and CachingSessionStore.  The CachingSessionStore is the default, and recommended, SessionStore for Yosai.\n\n\nSession Events\n\n\nAn Event is emitted to the singleton EventBus, in Yosai, when a Session is \nstarted\n, \nstopped\n, or \nexpired\n.  If you would like to learn more about Event processing, please refer to the documentation about Event Processing.\n\n\nEvents are communicated using a publish-subscribe paradigm.  In the case of Sessions, a \nSessionEventHandler\n publishes an event to a channel (an internal Event Bus). The EventBus relays an event to consumers who have subscribed to the event's topic. It relays the event by calling the callback method registered for a consumer, using the event payload as its argument(s).\n\n\nThe following table lists the Session-related events and who the subscriber(s) are:\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nSESSION.START\n\n\nEL\n\n\n\n\n\n\nSESSION.STOP\n\n\nMRA, EL\n\n\n\n\n\n\nSESSION.EXPIRE\n\n\nMRA, EL\n\n\n\n\n\n\n\n\n\n\nMRA = \nyosai.core.authz.authz.ModularRealmAuthorizer\n\n\nSEH = \nyosai.core.session.session.SessionEventHandler\n\n\n\n\nExample:  SESSION.EXPIRE Event Processing\n\n\nAt Yosai initialization, \nyosai.core.authz.authz.ModularRealmAuthorizer\n subscribes to a few event topics, one of which is 'SESSION.EXPIRE'. When it subscribes to the 'SESSION.EXPIRE' topic, it registers a callback method, \nsession_clears_cache\n.  This callback method is called by the EventBus whenever a 'SESSION.EXPIRE' event is emitted to the bus.\n\n\nA \nSESSION.EXPIRE\n event is emitted by a \nyosai.core.session.session.SessionEventHandler\n when Session Validation has recognized a Session as expired.\n\n\nAs of yosai.core v0.1.0, the \nModularRealmAuthorizer\n and \nEventLogger\n are the two subscribers of the \nSESSION.EXPIRE\n topic (see table above).  The callback method registered for each subscriber is called in an arbitrary, sequential fasion (PyPubSub design) when a SessionEventHandler emits a SESSION.EXPIRE event to the Eventbus.\n\n\nHere is an example of an \nexpired-session\n event processing through Yosai, omitting event logging processing:\n\n\n\n\nSession Tutorial\n\n\nIn this tutorial, you will learn how to use the Session API to perform server-side session management.  We'll use a shopping cart example to illustrate how to manage state using a Session object.  You will learn how to:     1) define a \nmarshmallow\n Schema required to cache a shopping cart as        a Session attribute     2) manage a shopping cart using the Session API, including:\n- get_attribute\n- set_attribute\n- remove_attribute\n\n\nSerialization Strategy\n\n\nThis example uses Session caching.  Objects are serialized before they are cached.\n\n\nYosai uses the \nmarshmallow\n library in conjunction with an encoding library, such as MSGPack or JSON, to (de)serialize Serializable objects from(to) cache. \nmarshmallow\n requires you to specify the Schema of the object and how to properly (de)serialize it.  A Session is a Serializable object, therefore it requires its own \nmarshmallow.Schema\n definition.\n\n\nOnly \nSerializable\n objects can be serialized in Yosai.  A Serializable class implements the serialize_abcs.Serializable abstract base class, which requires that a \nmarshmallow.Schema\n class be defined for it within its \nserialization_schema\n classmethod.\n\n\nExample:  Shopping Cart Session Management\n\n\nThis is \nnot\n a primer on how to write your own e-commerce shopping cart application.  This example is intended to illustrate the Session API. \nIt is not intended for production use.\n\n\nAs per Wikipedia:\n\n\n\n\nA shopping cart is a piece of e-commerce software on a web server that allows visitors to an Internet site to select items for eventual purchase... The software allows online shopping customers to \naccumulate a list of items for purchase\n, described metaphorically as \"placing items in the shopping cart\" or \"add to cart.\" Upon checkout, the software typically calculates a total for the order, including shipping and handling (i.e., postage and packing) charges and the associated taxes, as applicable.\n\n\n\n\nSerializing a Shopping Cart in a Session\n\n\nLet's define our \nmarshmallow.Schema\n classes:\n\n\nclass\n \nShoppingCartItemSchema\n(Schema):\n\n    \nupc\n \n=\n \nfields\n.\nString()\n\n    \nquantity\n \n=\n \nfields\n.\nInt()\n\n\n\n# A shopping_cart is a dict that uses a UPC product code as its key and quantity\n\n\n# as its value:\n\n\nclass\n \nShoppingCartSchema\n(Schema):\n\n    \nitems\n \n=\n \nfields\n.\nNested(ShoppingCartItemSchema,\n \nmany\n=\nTrue)\n\n\n\n# this class is declared in case there are attributes other than a\n\n\n# shopping cart that need to be serialized:\n\n\nclass\n \nSessionAttributesSchema\n(Schema):\n\n    \nshopping_cart\n \n=\n \nfields\n.\nNested(ShoppingCartSchema)\n\n\n\n\n\n\nNow that you've defined \nSessionAttributesSchema\n, you are ready to initialize Yosai with shopping-cart enabled session management capabilities.  Simply pass the schema class as an argument at Yosai initialization.  The rest of the arguments passed to init_yosai are omitted for clarity:\n\n\n    \nSecurityUtils\n.\ninit_yosai(\n...\n \n# omitted for this example\n\n                             \n...\n \n# omitted for this example\n\n                             \nsession_schema\n=\nSessionAttributesSchema)\n\n\n\n\n\n\nShopping Cart\n\n\nShoppingCart is a facade to the Session API for managing the shopping_cart attribute within a Session.\n\n\nA \nshopping_cart\n is a dict that uses a UPC product code as its key and quantity as its value.\n\n\nA ShoppingCart allows you to add, update, and removes items and adjust the quantity of each item.\n\n\nclass\n \nShoppingCart\n(Serializable):\n\n    \ndef\n \n__init__\n(self,\n \ncurrent_user):\n\n        \n\n\n        :type current_user: subject_abcs.Subject\n\n\n        \n\n        \nself\n.\ncurrent_user\n \n=\n \ncurrent_user\n\n        \nself\n.\nsession\n \n=\n \nself\n.\ncurrent_user\n.\nget_session()\n\n\n    \ndef\n \nlist_items\n(self):\n\n        \nshopping_cart\n \n=\n \nself\n.\nsession\n.\nget_attribute(\nshopping_cart\n)\n\n        \nreturn\n \nshopping_cart\n.\nitems()\n\n\n    \ndef\n \nadd_item\n(self,\n \nupc,\n \nquantity):\n\n        \nshopping_cart\n \n=\n \nself\n.\nsession\n.\nget_attribute(\nshopping_cart\n)\n\n        \nshopping_cart[item]\n \n=\n \nquantity\n\n        \nsession\n.\nset_attribute(\nshopping_cart\n,\n \nshopping_cart)\n\n\n    \ndef\n \nupdate_item\n(self,\n \nupc,\n \nquantity):\n\n        \nshopping_cart\n \n=\n \nself\n.\nsession\n.\nget_attribute(\nshopping_cart\n)\n\n        \nshopping_cart[item]\n \n=\n \nquantity\n\n        \nsession\n.\nset_attribute(\nshopping_cart\n,\n \nshopping_cart)\n\n\n    \ndef\n \nremove_item\n(self,\n \nupc):\n\n        \nshopping_cart\n \n=\n \nself\n.\nsession\n.\nget_attribute(\nshopping_cart\n)\n\n        \nshopping_cart\n.\npop(item)\n\n        \nsession\n.\nset_attribute(\nshopping_cart\n,\n \nshopping_cart)\n\n\n\n\n\n\n\n\nThis class is designed based on the assumption that a new ShoppingCart     instance is obtained per request.  A Session is accessed at \ninit\n.     A Session is validated only when it is accessed.  If ShoppingCart were to be     used in a web application, it would be instantiated \nper request\n and     consequently the Session would be validated per-request.\n\n\n\n\nNow, you will see how your interaction with the ShoppingCart API impacts a user's Session.  We'll add four items to the shopping cart, remove one, and modify the quantity of another.  Finally, we'll remove the shopping_cart attribute entirely from the Session.\n\n\nOperation 1:  Add four items to the shopping cart\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils\n\n\n    \ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n    \nmy_cart\n \n=\n \nShoppingCart(current_user)\n\n\n    \nmy_cart\n.\nadd_item(\n0043000200216\n,\n \n4\n)\n  \n# we\nll modify the quantity of this later\n\n    \nmy_cart\n.\nadd_item(\n016000119772\n,\n \n1\n)\n\n    \nmy_cart\n.\nadd_item(\n52159012038\n,\n \n3\n)\n\n    \nmy_cart\n.\nadd_item(\n00028400028196\n,\n \n1\n)\n\n\n    \nmy_cart\n.\nlist_items()\n\n\n\n\n\n\nOperation 2:  Remove an item from the shopping cart\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils\n\n\n    \ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n    \nmy_cart\n \n=\n \nShoppingCart(current_user)\n\n\n    \nmy_cart\n.\nremove_item(\n00028400028196\n)\n\n\n     \nmy_cart\n.\nlist_items()\n\n\n\n\n\n\nOperation 3:  Modify the quantity of an item in the shopping cart\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils\n\n\n    \ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n    \nmy_cart\n \n=\n \nShoppingCart(current_user)\n\n\n    \nmy_cart\n.\nupdate_item(\n0043000200216\n,\n \n2\n)\n\n\n    \nmy_cart\n.\nlist_items()\n\n\n\n\n\n\nOperation 4:  Remove the shopping cart attribute from the Session\n\n\n    \nfrom\n \nyosai.core\n \nimport\n \nSecurityUtils\n\n\n    \ncurrent_user\n \n=\n \nSecurityUtils\n.\nget_subject()\n\n    \nsession\n \n=\n \nself\n.\ncurrent_user\n.\nget_session()\n\n    \nsession\n.\nremove_attribute(\nshopping_cart\n)\n\n\n\n\n\n\nReferences\n\n\nOWASP Session Management CheatSheet",
            "title": "Session Management"
        },
        {
            "location": "/sessionmanagement/#sessions-and-session-management",
            "text": "Use Sessions to track the state of a user's interactions with your application across multiple requests, over a specified period of time.  Tracking user state with Sessions enables more feature-rich user experiences.  Further, Sessions play a major role in access control.  Session Management involves creating, reading, updating, and deleting of Sessions and Session attributes, and validating Sessions.  Yosai's  SessionManager  uses a  CachingSessionStore  to cache sessions. If you are not caching sessions, you you are either using in-memory session storage  (the  MemorySessionStore ) or using your own custom SessionStore, which is beyond the scope of consideration in this documentation.",
            "title": "Sessions and Session Management"
        },
        {
            "location": "/sessionmanagement/#authentication-authorization-and-session-management-are-related",
            "text": "Access is limited by user identity: a guest cannot perform the operations that an authenticated user can, and each authenticated user may perform different operations.  The identity of an authenticated user is recorded in the Session.  Since access control is limited by identity, and identity is obtained from a Session, access control is considered  bound  to a Session.",
            "title": "Authentication, Authorization, and Session Management are Related"
        },
        {
            "location": "/sessionmanagement/#properties-of-a-session-session-risk-and-risk-countermeasures",
            "text": "Sessions are a \"threat vector\":  a path that an \"actor\" may exploit to attack a \"target\" (your application).  Sessions are exploited by a process known as hijacking.  Session Management helps to manage many of the inherent risks of Sessions through a series of countermeasures.  More information about these countermeasures follows in the documentation.",
            "title": "Properties of a Session , Session Risk, and Risk Countermeasures"
        },
        {
            "location": "/sessionmanagement/#the-session-token",
            "text": "A Session Token is like a smart chip, or magnetic strip, on a credit card in that it contains identification-- a session identifier (SessionID).  However, unlike the elements of a credit card, the Session Token has a much shorter lifespan.  The  SessionID  is a sensitive and critical piece of information.  It uniquely identifies a Session.  It is the Session's key in a SessionStore (cache) and it is the key that is sent with subsequent requests by a client (the user).  Once an authenticated session is established, the  SessionID  is the client's key to Yosai.  Therefore, it is very important that the session identifier be unique and very difficult to reproduce.    Yosai's default method to generate a  SessionID  is as follows: sha256(sha512(urandom(20)).digest()).hexdigest()",
            "title": "The Session Token"
        },
        {
            "location": "/sessionmanagement/#temporal-risks-and-countermeasures",
            "text": "The risk of compromising a Session increases as time passes.  To address time-driven risks, Yosai defines temporal properties in a Session -- idle time and maximum allowable time to live (TTL) -- that enable \"timing out\" of Sessions.  When a Session \"times out\", it is considered  expired .  When a Session is  expired , it can no longer be used in Yosai, and therefore is no longer at risk of being hijacked.  The timeout thresholds are configured in the Yosai settings YAML file. Should you find their default settings unacceptable, you can easily change them.  The default settings are somewhat aggressive so as to minimize the risks that defaults may present and to encourage developers to take ownership of session time-out decisions.",
            "title": "Temporal Risks and Countermeasures"
        },
        {
            "location": "/sessionmanagement/#idle-time",
            "text": "This property represents the total permissible time for a user to be inactive in a system, or idle.  Picture idle timeout as an hourglass that is turned over and reset periodically. The way that idle time is reset is by updating the Session's  last_access_time  attribute.  As to when the  last_access_time  is updated depends on what \"auto_touch\" has been configured to or whether you've chosen an alternative time to touch than the default (per-access).  A  DefaultNativeSessionManager  has an attribute, \"auto_touch\", that when set to True will allow the updating of a Session's  last_access_time  attribute to the current time, whenever a session is accessed, following Session validation. As mentioned, when a Session should be touched depends on the type of application you are developing and thus auto_touch is a configurable feature.  When a Session is obtained from the SessionStore, it is immediately validated.  Should the validation not raise any exceptions, and if auto_touch is True, the Session will be \"touched\".  Touching a Session is the process of flipping and resetting the hourglass, so to speak, by updating the  last_access_time  attribute of the Session.  Yosai's default idle time setting for a Session is  5 minutes .",
            "title": "Idle time"
        },
        {
            "location": "/sessionmanagement/#time-to-live",
            "text": "A Session has a maximum allowable time period that it may exist.  It is the final countdown until a Session is expired. It cannot be reset, unlike idle timeout. Many computer systems refer to this as a TTL -- time to live.  Yosai's default time-to-live for a Session is  30 minutes .",
            "title": "Time to live"
        },
        {
            "location": "/sessionmanagement/#stopping-sessions",
            "text": "Aside from expirations, another mechanism for rendering Sessions useless in is  stopping  them.  When a subject logs out of a system, the subject's Session is stopped.  Like an expired Session, a  stopped  Session can no longer be used and is consequently no longer at risk of being hijacked.",
            "title": "Stopping Sessions"
        },
        {
            "location": "/sessionmanagement/#session-validation",
            "text": "Session Validation is the process of determining whether a Session has stopped or expired.  When a session has stopped or expired, it is considered  invalid .  A Session expires when the time duration between the current time and the last recorded time that a Session was accessed exceeds either timeout threshold.  Keeping track of idle expiration presents performance challenges.  Therefore, Sessions are validated  only  when they are accessed (i.e. subject.get_session()).  the last_access_timestamp synchronized with session usage presents a  if the duration between the last_access_timestamp and the current time exceeds either timeout threshold, a session is considered expired  By default, Sessions are \"lazy validated\" in that they are validated at the time that [they are accessed?].  As discussed in an earlier section above, access control is  bound  to a Session. Since access control is  bound  to a Session, when a Session is invalidated so too does the authorization information cached for the Session.  Invalid authorization information is cleared from cache through event handling.",
            "title": "Session Validation"
        },
        {
            "location": "/sessionmanagement/#idle-timeout-edge-case",
            "text": "Monitoring for idle timeout increases the complexity of Session Management.\nAs discussed, Session validation taxes the performance of an application and\ntherefore does not run before every authorization check.  Instead, validation\nis designed to maximize utility for the most popular use case-- one where the\nsubject instance has a short life span in memory and sessions validate when\nthey are accessed.  Therefore, it is recommended that you release a Subject instance for garbage\ncollection between requests.",
            "title": "Idle Timeout Edge Case"
        },
        {
            "location": "/sessionmanagement/#the-session-synchronization-design-challenge",
            "text": "Keeping the last_access_timestamp synchronized with session usage presents a performance design challenge that you are encouraged to help improve.  Ideas are welcome!",
            "title": "The Session Synchronization Design Challenge"
        },
        {
            "location": "/sessionmanagement/#session-invalidation",
            "text": "By default, whenever Yosai detects an invalid session, it attempts to delete it from the underlying session data store via the SessionStore.delete(session) method.  However, should you decide not to automatically delete invalid sessions, you can easily opt-out of this process.  For example, if your application uses a SessionStore that backs a queryable data store, perhaps your dev team wants old or invalid sessions to be available for a certain period of time. Storing invalid sessions would allow you to run queries against the data store to see, for example, how many sessions a user has created over the last week, or the average duration of a user's sessions, or similar reporting-type queries.  At Session expiration, Yosai ties up loose ends, so to speak, through its event-driven architecture.",
            "title": "Session Invalidation"
        },
        {
            "location": "/sessionmanagement/#session-usage",
            "text": "",
            "title": "Session Usage"
        },
        {
            "location": "/sessionmanagement/#session-initialization",
            "text": "A Session can be used to manage state for a Subject regardless of whether the Subject has authenticated itself or remains anonymous.  Yosai initializes a server-side Session the moment that a Subject is instantiated:  from   yosai.core   import   SecurityUtils,   UsernamePasswordToken  # creates an  anonymous session  if the current executing subject hasn t  # logged in yet:  guest   =   SecurityUtils . get_subject()   You can then manage state as necessary using the session, but more about that later: .. code-block:: python     session = guest.get_session()  # returns an anonymous session (guest)  After a user authenticates itself, Yosai creates a new session for the user. This is done for a few reasons.  The user's access to the system changes as the user's identity changes (from anonymous to authenticated).  A new, \"authenticated session\" replaces the \"anonymous session\" the moment that a subject is authenticated as a user:  from   yosai.core   import   SecurityUtils,   UsernamePasswordToken  # creates an  anonymous session  if the current executing subject hasn t  # logged in yet:  current_user   =   SecurityUtils . get_subject()  authc_token   =   UsernamePasswordToken(username = thedude , \n                                     credentials = letsgobowling )  # creates an  authenticated session  if login in successful, raising  # an exception otherwise (try/except left out to simplify the example):  current_user . login(authc_token)    It is recommended that the session be regenerated by the application after      any  privilege level change within the associated user session.",
            "title": "Session Initialization"
        },
        {
            "location": "/sessionmanagement/#session-storage",
            "text": "Whenever a Session is created or updated, its data is persisted to a storage location so that it may be accessible by the application at a later time. Similarly, when a Session is invalid and longer being used, it is deleted from storage so that the Session data store space is not exhausted (if you're not taking advantage of TTL expiration in your data store).  The SessionManager implementations delegate these Create/Read/Update/Delete (CRUD) operations to an internal component, the SessionStore, which reflects the Data Access Object (DAO) design pattern.  The power of the SessionStore is that you can implement this interface to communicate with any data store you wish. This means your session data can reside in memory, on the file system, in a relational database or NoSQL data store, or any other location you want. You have control over persistence behavior.  Yosai features an in-memory MemorySessionStore and CachingSessionStore.  The CachingSessionStore is the default, and recommended, SessionStore for Yosai.",
            "title": "Session Storage"
        },
        {
            "location": "/sessionmanagement/#session-events",
            "text": "An Event is emitted to the singleton EventBus, in Yosai, when a Session is  started ,  stopped , or  expired .  If you would like to learn more about Event processing, please refer to the documentation about Event Processing.  Events are communicated using a publish-subscribe paradigm.  In the case of Sessions, a  SessionEventHandler  publishes an event to a channel (an internal Event Bus). The EventBus relays an event to consumers who have subscribed to the event's topic. It relays the event by calling the callback method registered for a consumer, using the event payload as its argument(s).  The following table lists the Session-related events and who the subscriber(s) are:     Event Topic  Subscriber(s)      SESSION.START  EL    SESSION.STOP  MRA, EL    SESSION.EXPIRE  MRA, EL      MRA =  yosai.core.authz.authz.ModularRealmAuthorizer  SEH =  yosai.core.session.session.SessionEventHandler",
            "title": "Session Events"
        },
        {
            "location": "/sessionmanagement/#example-sessionexpire-event-processing",
            "text": "At Yosai initialization,  yosai.core.authz.authz.ModularRealmAuthorizer  subscribes to a few event topics, one of which is 'SESSION.EXPIRE'. When it subscribes to the 'SESSION.EXPIRE' topic, it registers a callback method,  session_clears_cache .  This callback method is called by the EventBus whenever a 'SESSION.EXPIRE' event is emitted to the bus.  A  SESSION.EXPIRE  event is emitted by a  yosai.core.session.session.SessionEventHandler  when Session Validation has recognized a Session as expired.  As of yosai.core v0.1.0, the  ModularRealmAuthorizer  and  EventLogger  are the two subscribers of the  SESSION.EXPIRE  topic (see table above).  The callback method registered for each subscriber is called in an arbitrary, sequential fasion (PyPubSub design) when a SessionEventHandler emits a SESSION.EXPIRE event to the Eventbus.  Here is an example of an  expired-session  event processing through Yosai, omitting event logging processing:",
            "title": "Example:  SESSION.EXPIRE Event Processing"
        },
        {
            "location": "/sessionmanagement/#session-tutorial",
            "text": "In this tutorial, you will learn how to use the Session API to perform server-side session management.  We'll use a shopping cart example to illustrate how to manage state using a Session object.  You will learn how to:     1) define a  marshmallow  Schema required to cache a shopping cart as        a Session attribute     2) manage a shopping cart using the Session API, including:\n- get_attribute\n- set_attribute\n- remove_attribute",
            "title": "Session Tutorial"
        },
        {
            "location": "/sessionmanagement/#serialization-strategy",
            "text": "This example uses Session caching.  Objects are serialized before they are cached.  Yosai uses the  marshmallow  library in conjunction with an encoding library, such as MSGPack or JSON, to (de)serialize Serializable objects from(to) cache.  marshmallow  requires you to specify the Schema of the object and how to properly (de)serialize it.  A Session is a Serializable object, therefore it requires its own  marshmallow.Schema  definition.  Only  Serializable  objects can be serialized in Yosai.  A Serializable class implements the serialize_abcs.Serializable abstract base class, which requires that a  marshmallow.Schema  class be defined for it within its  serialization_schema  classmethod.",
            "title": "Serialization Strategy"
        },
        {
            "location": "/sessionmanagement/#example-shopping-cart-session-management",
            "text": "This is  not  a primer on how to write your own e-commerce shopping cart application.  This example is intended to illustrate the Session API.  It is not intended for production use.  As per Wikipedia:   A shopping cart is a piece of e-commerce software on a web server that allows visitors to an Internet site to select items for eventual purchase... The software allows online shopping customers to  accumulate a list of items for purchase , described metaphorically as \"placing items in the shopping cart\" or \"add to cart.\" Upon checkout, the software typically calculates a total for the order, including shipping and handling (i.e., postage and packing) charges and the associated taxes, as applicable.",
            "title": "Example:  Shopping Cart Session Management"
        },
        {
            "location": "/sessionmanagement/#serializing-a-shopping-cart-in-a-session",
            "text": "Let's define our  marshmallow.Schema  classes:  class   ShoppingCartItemSchema (Schema): \n     upc   =   fields . String() \n     quantity   =   fields . Int()  # A shopping_cart is a dict that uses a UPC product code as its key and quantity  # as its value:  class   ShoppingCartSchema (Schema): \n     items   =   fields . Nested(ShoppingCartItemSchema,   many = True)  # this class is declared in case there are attributes other than a  # shopping cart that need to be serialized:  class   SessionAttributesSchema (Schema): \n     shopping_cart   =   fields . Nested(ShoppingCartSchema)   Now that you've defined  SessionAttributesSchema , you are ready to initialize Yosai with shopping-cart enabled session management capabilities.  Simply pass the schema class as an argument at Yosai initialization.  The rest of the arguments passed to init_yosai are omitted for clarity:       SecurityUtils . init_yosai( ...   # omitted for this example \n                              ...   # omitted for this example \n                              session_schema = SessionAttributesSchema)",
            "title": "Serializing a Shopping Cart in a Session"
        },
        {
            "location": "/sessionmanagement/#shopping-cart",
            "text": "ShoppingCart is a facade to the Session API for managing the shopping_cart attribute within a Session.  A  shopping_cart  is a dict that uses a UPC product code as its key and quantity as its value.  A ShoppingCart allows you to add, update, and removes items and adjust the quantity of each item.  class   ShoppingCart (Serializable): \n     def   __init__ (self,   current_user): \n                  :type current_user: subject_abcs.Subject           \n         self . current_user   =   current_user \n         self . session   =   self . current_user . get_session() \n\n     def   list_items (self): \n         shopping_cart   =   self . session . get_attribute( shopping_cart ) \n         return   shopping_cart . items() \n\n     def   add_item (self,   upc,   quantity): \n         shopping_cart   =   self . session . get_attribute( shopping_cart ) \n         shopping_cart[item]   =   quantity \n         session . set_attribute( shopping_cart ,   shopping_cart) \n\n     def   update_item (self,   upc,   quantity): \n         shopping_cart   =   self . session . get_attribute( shopping_cart ) \n         shopping_cart[item]   =   quantity \n         session . set_attribute( shopping_cart ,   shopping_cart) \n\n     def   remove_item (self,   upc): \n         shopping_cart   =   self . session . get_attribute( shopping_cart ) \n         shopping_cart . pop(item) \n         session . set_attribute( shopping_cart ,   shopping_cart)    This class is designed based on the assumption that a new ShoppingCart     instance is obtained per request.  A Session is accessed at  init .     A Session is validated only when it is accessed.  If ShoppingCart were to be     used in a web application, it would be instantiated  per request  and     consequently the Session would be validated per-request.   Now, you will see how your interaction with the ShoppingCart API impacts a user's Session.  We'll add four items to the shopping cart, remove one, and modify the quantity of another.  Finally, we'll remove the shopping_cart attribute entirely from the Session.",
            "title": "Shopping Cart"
        },
        {
            "location": "/sessionmanagement/#operation-1-add-four-items-to-the-shopping-cart",
            "text": "from   yosai.core   import   SecurityUtils \n\n     current_user   =   SecurityUtils . get_subject() \n     my_cart   =   ShoppingCart(current_user) \n\n     my_cart . add_item( 0043000200216 ,   4 )    # we ll modify the quantity of this later \n     my_cart . add_item( 016000119772 ,   1 ) \n     my_cart . add_item( 52159012038 ,   3 ) \n     my_cart . add_item( 00028400028196 ,   1 ) \n\n     my_cart . list_items()",
            "title": "Operation 1:  Add four items to the shopping cart"
        },
        {
            "location": "/sessionmanagement/#operation-2-remove-an-item-from-the-shopping-cart",
            "text": "from   yosai.core   import   SecurityUtils \n\n     current_user   =   SecurityUtils . get_subject() \n     my_cart   =   ShoppingCart(current_user) \n\n     my_cart . remove_item( 00028400028196 ) \n\n      my_cart . list_items()",
            "title": "Operation 2:  Remove an item from the shopping cart"
        },
        {
            "location": "/sessionmanagement/#operation-3-modify-the-quantity-of-an-item-in-the-shopping-cart",
            "text": "from   yosai.core   import   SecurityUtils \n\n     current_user   =   SecurityUtils . get_subject() \n     my_cart   =   ShoppingCart(current_user) \n\n     my_cart . update_item( 0043000200216 ,   2 ) \n\n     my_cart . list_items()",
            "title": "Operation 3:  Modify the quantity of an item in the shopping cart"
        },
        {
            "location": "/sessionmanagement/#operation-4-remove-the-shopping-cart-attribute-from-the-session",
            "text": "from   yosai.core   import   SecurityUtils \n\n     current_user   =   SecurityUtils . get_subject() \n     session   =   self . current_user . get_session() \n     session . remove_attribute( shopping_cart )",
            "title": "Operation 4:  Remove the shopping cart attribute from the Session"
        },
        {
            "location": "/sessionmanagement/#references",
            "text": "OWASP Session Management CheatSheet",
            "title": "References"
        },
        {
            "location": "/events/",
            "text": "Event-Driven Architecture\n\n\n\n\nYosai features an event-driven architecture where events emitted during\nauthentication, authorization, and session management trigger subsequent\nprocessing.\n\n\nEvents are communicated using a publish-subscribe paradigm.  An event publisher\nemits the event to a channel (an internal Event Bus) that relays the event to\nconsumers who have subscribed to the event's topic. The EventBus is a singleton\nshared throughout the running instance of Yosai.\n\n\n\n\nAn EventBus relays published events to event subscribers and provides a mechanism for\nregistering and unregistering event subscribers. With this pubsub paradigm,\ncomponents can publish or consume events without tightly coupling consumers to\nproducers.  This promotes flexibility through loose coupling and high cohesion\nbetween components, leading to a more pluggable architecture.\n\n\nSending Events\n\n\nIf a component wishes to publish events to other components:\n\nevent_bus.publish(topic, *kwargs)\n\n\nThe event bus dispatches the event 'message' to components that wish to receive\nevents of that type (known as subscribers).\n\n\nReceiving Events\n\n\nA component can receive events of interest by doing the following.\n\n\nFor each event topic you wish to consume, create a callback method\nthat will be called when an specific type of event is communicated across\nthe event bus.  Register the callback with the event_bus:\n\nevent_bus.register(topic, callback)\n\n\nEvent Schedule\n\n\nThe following table lists the Events that are used in Yosai, who the\npublisher of an event is, and who the subscriber(s) are:\n\n\n\n\n\n\n\n\nEvent Topic\n\n\nPublisher\n\n\nSubscriber(s)\n\n\n\n\n\n\n\n\n\n\nSESSION.START\n\n\nSEH\n\n\nEL\n\n\n\n\n\n\nSESSION.STOP\n\n\nSEH\n\n\nMRA, EL\n\n\n\n\n\n\nSESSION.EXPIRE\n\n\nSEH\n\n\nMRA, EL\n\n\n\n\n\n\nAUTHENTICATION.SUCCEEDED\n\n\nDA\n\n\nMRA, EL\n\n\n\n\n\n\nAUTHENTICATION.FAILED\n\n\nDA\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.GRANTED\n\n\nMRA\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.DENIED\n\n\nMRA\n\n\nEL\n\n\n\n\n\n\nAUTHORIZATION.RESULTS\n\n\nMRA\n\n\nEL\n\n\n\n\n\n\n\n\n\n\nDA = \nyosai.core.authc.authc.DefaultAuthenticator\n\n\nEL = \nyosai.core.event.event.EventLogger\n\n\nMRA = \nyosai.core.authz.authz.ModularRealmAuthorizer\n\n\nSEH = \nyosai.core.session.session.SessionEventHandler\n\n\n\n\nEvent Logging\n\n\n\n\nCommunicating events in a structured format facilitates processing of log\nentries by systems independent of Yosai.  Therefore, events are\nlogged in a structured format by reducing event payloads to their serializable\nform using \nmarshmallow\n.\n\n\nIn addition to reducing payloads using marshmallow, Yosai includes an optional\nlogging module that features JSON encoded formatting.  It is highly recommended\nthat you use it or another structured format for logging events.",
            "title": "Event Processing"
        },
        {
            "location": "/events/#event-driven-architecture",
            "text": "Yosai features an event-driven architecture where events emitted during\nauthentication, authorization, and session management trigger subsequent\nprocessing.  Events are communicated using a publish-subscribe paradigm.  An event publisher\nemits the event to a channel (an internal Event Bus) that relays the event to\nconsumers who have subscribed to the event's topic. The EventBus is a singleton\nshared throughout the running instance of Yosai.   An EventBus relays published events to event subscribers and provides a mechanism for\nregistering and unregistering event subscribers. With this pubsub paradigm,\ncomponents can publish or consume events without tightly coupling consumers to\nproducers.  This promotes flexibility through loose coupling and high cohesion\nbetween components, leading to a more pluggable architecture.",
            "title": "Event-Driven Architecture"
        },
        {
            "location": "/events/#sending-events",
            "text": "If a component wishes to publish events to other components: event_bus.publish(topic, *kwargs)  The event bus dispatches the event 'message' to components that wish to receive\nevents of that type (known as subscribers).",
            "title": "Sending Events"
        },
        {
            "location": "/events/#receiving-events",
            "text": "A component can receive events of interest by doing the following.  For each event topic you wish to consume, create a callback method\nthat will be called when an specific type of event is communicated across\nthe event bus.  Register the callback with the event_bus: event_bus.register(topic, callback)",
            "title": "Receiving Events"
        },
        {
            "location": "/events/#event-schedule",
            "text": "The following table lists the Events that are used in Yosai, who the\npublisher of an event is, and who the subscriber(s) are:     Event Topic  Publisher  Subscriber(s)      SESSION.START  SEH  EL    SESSION.STOP  SEH  MRA, EL    SESSION.EXPIRE  SEH  MRA, EL    AUTHENTICATION.SUCCEEDED  DA  MRA, EL    AUTHENTICATION.FAILED  DA  EL    AUTHORIZATION.GRANTED  MRA  EL    AUTHORIZATION.DENIED  MRA  EL    AUTHORIZATION.RESULTS  MRA  EL      DA =  yosai.core.authc.authc.DefaultAuthenticator  EL =  yosai.core.event.event.EventLogger  MRA =  yosai.core.authz.authz.ModularRealmAuthorizer  SEH =  yosai.core.session.session.SessionEventHandler",
            "title": "Event Schedule"
        },
        {
            "location": "/events/#event-logging",
            "text": "Communicating events in a structured format facilitates processing of log\nentries by systems independent of Yosai.  Therefore, events are\nlogged in a structured format by reducing event payloads to their serializable\nform using  marshmallow .  In addition to reducing payloads using marshmallow, Yosai includes an optional\nlogging module that features JSON encoded formatting.  It is highly recommended\nthat you use it or another structured format for logging events.",
            "title": "Event Logging"
        },
        {
            "location": "/serialization/",
            "text": "Serialization\n\n\nYosai serializes objects when caching and when saving 'Remember Me' information.\n\n\nThe serialization process is as follows:\n\n\n\n\n\n\nReduce the state of a Yosai object to its primitive form, as a dict\n\n\nEnrich the payload -- that which is cached -- with metadata\n\n\nEncode the metadata-enriched payload\n\n\nyosai.core includes msgpack and json encoders, of which \nmsgpack\n is\n  the default\n\n\n\n\n\n\n\n\nMarshmallow\n\n\n\n\nYosai uses \nmarshmallow\n to reduce business objects to their primitive form.  As per Marshmallow's docs:\n\n\n\n\nMarshmallow is an ORM/ODM/framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes.\n\n\n\n\nSerializables\n\n\nClasses that inherit from the \nSerializable\n abstract base class are eligible\nfor serialization in Yosai.  A Serializable class has its own marshmallow\n\nSerializationSchema\n class defined as an inner class of the\n\nserialization_schema\n classmethod.  This class is returned by the classmethod\nand used during (de)serialization:\n\n\n    \n@classmethod\n\n    \ndef\n \nserialization_schema\n(cls):\n\n\n        \nclass\n \nSerializationSchema\n(Schema):\n\n            \n...\n\n        \nreturn\n \nSerializationSchema\n\n\n\n\n\n\nExamples\n\n\nTo understand how to reduce objects, you are encouraged to review the serialization source code of the \nSerializable\n classes in Yosai.  The following classes are recommended for their diversity.  The serialization code is located at the bottom of each class, within the \nserialization_schema\n classmethod:\n\n\n\n\nauthz.authz.IndexedAuthorizationInfo\n\n\nsubject.identifier.SimpleIndentifierCollection\n\n\nsession.session.SimpleSession\n\n\nauthz.authz.WildcardPermission\n\n\n\n\nSerialization Manager\n\n\nA \nSerializationManager\n orchestrates the serialization process.  It is indended for your caching library, wrapping \"setters\" with serialization and \"getters\" with deserialization.\n\n\nFor instance, the Yosai extension, \nYosai DPCache\n, obtains a SerializationManager instance during its CacheHandler initialization process.  The \nSerializationManager\n proxies all cache communication.",
            "title": "Serialization"
        },
        {
            "location": "/serialization/#serialization",
            "text": "Yosai serializes objects when caching and when saving 'Remember Me' information.  The serialization process is as follows:    Reduce the state of a Yosai object to its primitive form, as a dict  Enrich the payload -- that which is cached -- with metadata  Encode the metadata-enriched payload  yosai.core includes msgpack and json encoders, of which  msgpack  is\n  the default",
            "title": "Serialization"
        },
        {
            "location": "/serialization/#marshmallow",
            "text": "Yosai uses  marshmallow  to reduce business objects to their primitive form.  As per Marshmallow's docs:   Marshmallow is an ORM/ODM/framework-agnostic library for converting complex datatypes, such as objects, to and from native Python datatypes.",
            "title": "Marshmallow"
        },
        {
            "location": "/serialization/#serializables",
            "text": "Classes that inherit from the  Serializable  abstract base class are eligible\nfor serialization in Yosai.  A Serializable class has its own marshmallow SerializationSchema  class defined as an inner class of the serialization_schema  classmethod.  This class is returned by the classmethod\nand used during (de)serialization:       @classmethod \n     def   serialization_schema (cls): \n\n         class   SerializationSchema (Schema): \n             ... \n         return   SerializationSchema",
            "title": "Serializables"
        },
        {
            "location": "/serialization/#examples",
            "text": "To understand how to reduce objects, you are encouraged to review the serialization source code of the  Serializable  classes in Yosai.  The following classes are recommended for their diversity.  The serialization code is located at the bottom of each class, within the  serialization_schema  classmethod:   authz.authz.IndexedAuthorizationInfo  subject.identifier.SimpleIndentifierCollection  session.session.SimpleSession  authz.authz.WildcardPermission",
            "title": "Examples"
        },
        {
            "location": "/serialization/#serialization-manager",
            "text": "A  SerializationManager  orchestrates the serialization process.  It is indended for your caching library, wrapping \"setters\" with serialization and \"getters\" with deserialization.  For instance, the Yosai extension,  Yosai DPCache , obtains a SerializationManager instance during its CacheHandler initialization process.  The  SerializationManager  proxies all cache communication.",
            "title": "Serialization Manager"
        },
        {
            "location": "/architecture/",
            "text": "Architectural Overview\n\n\nThe following diagram depicts Yosai's architecture. Note that only \none\n\nRealm is provided with \nyosai.core\n but others are shown to illustrate support for multiple realms (and their respective AccountStore).\n\n\n\n\nSubject\n\n\nA \nSubject\n represents state and security operations for a \nsingle\n\napplication user.  These operations include authentication (login/logout),\nauthorization (access control), and session access. A subject is Yosai's\nprimary mechanism for single-user security functionality.\n\n\nSecurity Manager\n\n\nA \nSecurityManager\n executes ALL security operations for ALL Subjects (aka users) across a single application.\n\n\nThe interface itself primarily exists as a convenience - it extends the\nAuthenticator, Authorizer, and SessionManager interfaces, thereby\nconsolidating these behaviors into a single point of reference.  For most\nYosai usages, this simplifies configuration and tends to be a more\nconvenient approach than referencing Authenticator, Authorizer, and\nSessionManager instances individually.  Instead, one only needs to interact\nwith a single SecurityManager instance.\n\n\nIn addition to the above three interfaces, this interface provides a number\nof methods supporting the behavior of Subject(s). A Subject executes\nauthentication, authorization, and session operations for a \nsingle\n user,\nand as such can only be managed by A SecurityManager that is aware of all\nthree functions.  The three parent interfaces on the other hand do not\n'know' about Subject(s) so as to ensure a clean separation of concerns.\n\n\nAuthenticator\n\n\nAn \nAuthenticator\n performs authentication for any given Subject (aka 'application user').  It uses an authentication strategy to coordinate authentication among one or more realms configured for authentication.\n\n\nAuthorizer\n\n\nAn \nAuthorizer\n performs authorization (access control) operations for any given Subject (aka 'application user').  It coordinates authorization requests among one or more realms configured for authorization.\n\n\nRealm\n\n\nA \nRealm\n access application-specific security entities such as accounts,\nroles, and permissions to perform authentication and authorization operations.\n\n\nRealms\n usually have a 1-to-1 relationship with an \nAccountStore\n,\nsuch as a NoSQL or relational database, file system, or other similar resource.\nHowever, since most Realm implementations are nearly identical, except for\nthe account query logic, a default realm implementation, \nAccountStoreRealm\n,\nis provided, allowing you to configure it with the data API-specific\n\nAccountStore\n instance.\n\n\nBecause most account stores usually contain Subject information such as\nusernames and passwords, a Realm can act as a pluggable authentication module in a \nPAM configuration\n\n.  This allows a Realm to perform \nboth\n authentication and authorization duties for a single account store, catering to most application needs.  If for some reason you don't want your Realm implementation to participate in authentication, override the \nsupports(authc_token)\n method to always return False.\n\n\nBecause every application is different, security data such as users and roles can be represented in any number of ways.  Yosai tries to maintain a non-intrusive development philosophy whenever possible -- it does not require you to implement or extend any \nUser\n, \nGroup\n or \nRole\n interfaces or classes.\n\n\nInstead, Yosai allows applications to implement this interface to access environment-specific account stores and data model objects.  The implementation can then be plugged in to the application's Yosai configuration. This modular technique abstracts away any environment/modeling details and allows Yosai to be deployed in practically any application environment.\n\n\nMost users will not implement this \nRealm\n interface directly, but will\ninstead use an \nAccountStoreRealm\n instance configured with an underlying\n\nAccountStore\n. This setup implies that there is an \nAccountStoreRealm\n\ninstance per \nAccountStore\n that the application needs to access.\n\n\nYosai introduces two Realm interfaces in order to separate authentication\nand authorization responsibilities.\n\n\nStore\n\n\nA \nStore\n is a data repository.  Yosai uses an \nAccountStore\n, specifically.  An \nAccountStore\n contains \nAccount\n information, such as credentials, roles, and permissions.\n\n\nCacheHandler\n\n\nA \nCacheHandler\n provides an abstraction on top of an underlying caching mechanism, such as \nyosai_dpcache\n, managing key generation and cache region interactions.\n\n\nEventBus\n\n\nAn \nEventbus\n can publish events to event subscribers as well as provide a\nmechanism for registering and unregistering event subscribers.\n\n\nAn event bus enables a publish/subscribe paradigm within Yosai -- components can publish or consume events they find relevant without needing to be tightly coupled to other components.",
            "title": "Architecture Overview"
        },
        {
            "location": "/architecture/#architectural-overview",
            "text": "The following diagram depicts Yosai's architecture. Note that only  one \nRealm is provided with  yosai.core  but others are shown to illustrate support for multiple realms (and their respective AccountStore).",
            "title": "Architectural Overview"
        },
        {
            "location": "/architecture/#subject",
            "text": "A  Subject  represents state and security operations for a  single \napplication user.  These operations include authentication (login/logout),\nauthorization (access control), and session access. A subject is Yosai's\nprimary mechanism for single-user security functionality.",
            "title": "Subject"
        },
        {
            "location": "/architecture/#security-manager",
            "text": "A  SecurityManager  executes ALL security operations for ALL Subjects (aka users) across a single application.  The interface itself primarily exists as a convenience - it extends the\nAuthenticator, Authorizer, and SessionManager interfaces, thereby\nconsolidating these behaviors into a single point of reference.  For most\nYosai usages, this simplifies configuration and tends to be a more\nconvenient approach than referencing Authenticator, Authorizer, and\nSessionManager instances individually.  Instead, one only needs to interact\nwith a single SecurityManager instance.  In addition to the above three interfaces, this interface provides a number\nof methods supporting the behavior of Subject(s). A Subject executes\nauthentication, authorization, and session operations for a  single  user,\nand as such can only be managed by A SecurityManager that is aware of all\nthree functions.  The three parent interfaces on the other hand do not\n'know' about Subject(s) so as to ensure a clean separation of concerns.",
            "title": "Security Manager"
        },
        {
            "location": "/architecture/#authenticator",
            "text": "An  Authenticator  performs authentication for any given Subject (aka 'application user').  It uses an authentication strategy to coordinate authentication among one or more realms configured for authentication.",
            "title": "Authenticator"
        },
        {
            "location": "/architecture/#authorizer",
            "text": "An  Authorizer  performs authorization (access control) operations for any given Subject (aka 'application user').  It coordinates authorization requests among one or more realms configured for authorization.",
            "title": "Authorizer"
        },
        {
            "location": "/architecture/#realm",
            "text": "A  Realm  access application-specific security entities such as accounts,\nroles, and permissions to perform authentication and authorization operations.  Realms  usually have a 1-to-1 relationship with an  AccountStore ,\nsuch as a NoSQL or relational database, file system, or other similar resource.\nHowever, since most Realm implementations are nearly identical, except for\nthe account query logic, a default realm implementation,  AccountStoreRealm ,\nis provided, allowing you to configure it with the data API-specific AccountStore  instance.  Because most account stores usually contain Subject information such as\nusernames and passwords, a Realm can act as a pluggable authentication module in a  PAM configuration \n.  This allows a Realm to perform  both  authentication and authorization duties for a single account store, catering to most application needs.  If for some reason you don't want your Realm implementation to participate in authentication, override the  supports(authc_token)  method to always return False.  Because every application is different, security data such as users and roles can be represented in any number of ways.  Yosai tries to maintain a non-intrusive development philosophy whenever possible -- it does not require you to implement or extend any  User ,  Group  or  Role  interfaces or classes.  Instead, Yosai allows applications to implement this interface to access environment-specific account stores and data model objects.  The implementation can then be plugged in to the application's Yosai configuration. This modular technique abstracts away any environment/modeling details and allows Yosai to be deployed in practically any application environment.  Most users will not implement this  Realm  interface directly, but will\ninstead use an  AccountStoreRealm  instance configured with an underlying AccountStore . This setup implies that there is an  AccountStoreRealm \ninstance per  AccountStore  that the application needs to access.  Yosai introduces two Realm interfaces in order to separate authentication\nand authorization responsibilities.",
            "title": "Realm"
        },
        {
            "location": "/architecture/#store",
            "text": "A  Store  is a data repository.  Yosai uses an  AccountStore , specifically.  An  AccountStore  contains  Account  information, such as credentials, roles, and permissions.",
            "title": "Store"
        },
        {
            "location": "/architecture/#cachehandler",
            "text": "A  CacheHandler  provides an abstraction on top of an underlying caching mechanism, such as  yosai_dpcache , managing key generation and cache region interactions.",
            "title": "CacheHandler"
        },
        {
            "location": "/architecture/#eventbus",
            "text": "An  Eventbus  can publish events to event subscribers as well as provide a\nmechanism for registering and unregistering event subscribers.  An event bus enables a publish/subscribe paradigm within Yosai -- components can publish or consume events they find relevant without needing to be tightly coupled to other components.",
            "title": "EventBus"
        },
        {
            "location": "/library/",
            "text": "Extensions and Integrations\n\n\n\n\nThe mission of The Yosai Project is to secure any kind of Python application.\nTo fulfill this mission, extensions and integrations are required.\n\n\nExtensions\n\n\nAs illustrated, Yosai consists of a core library.  To provide a complete security solution for applications, the core library uses \nextensions\n -- components that extend operations enabled by the core.  Examples of extensions include:\n- credentials repositories such as relational databases or LDAP directories\n- access control policies residing in data sources such as relational databases\n- authentication methodologies such as social-media based authentication or\n  multi-factor authentication\n- caching mechanisms\n\n\nIntegrations\n\n\nYosai is designed to provide security related functionality in such a way that\nit can be used with ANY kind of application, including desktop apps, web apps,\ninternet-enabled devices, etc.\n\n\nYosai is adapted to an application through what is known as an \nintegration\n\nlibrary.\n\n\nSince a large number of applications are web-based applications, a helper\nlibrary, yosai.web, is included.  The yosai.web library should be used to help\nadapt yosai to the web application of your choice, yet specific customizations\nare left as an exercise for yosai integration development.  Developers are\nencouraged to submit to The Yosai Project integrations for license-compatible\nprojects.\n\n\n\n\nYosai is being released with \"batteries included\" so that it may be used in a\nproject without requiring additional implementation (for quick starts).  To achieve this goal, two integration projects were added to The Yosai Project, providing access to a peristence layer and caching:\n\n\nYosai AlchemyStore\n\n\nAn AccountStore implemented with SQLAlchemy.  The project includes a\nbasic RBAC data model that uses a flat, non-heirarchical design.  \n\n\nYosai DPCache\n\n\nThis is an integration of the dogpile.cache project.  Yosai reduces objects\nto their serializable form using Marshmallow, encodes them, and then caches.\nObjects obtained from cache are de-serialized into reduced form and then\nre-materialized into Yosai objects.  dogpile.cache supports Redis, Memcached,\nand Riak off the shelf, featuring thread-safe asynchronous interaction using a\ndogpile lock mechanism.  A \u201cdogpile\u201d lock is one that allows a single thread to\ngenerate an expensive resource while other threads use the \u201cold\u201d value until\nthe \u201cnew\u201d value is ready.\n\n\nCurrently, only the Redis backend has been updated and tested.  If you would like to add other backends, your pull request is welcome.",
            "title": "Library"
        },
        {
            "location": "/library/#extensions-and-integrations",
            "text": "The mission of The Yosai Project is to secure any kind of Python application.\nTo fulfill this mission, extensions and integrations are required.",
            "title": "Extensions and Integrations"
        },
        {
            "location": "/library/#extensions",
            "text": "As illustrated, Yosai consists of a core library.  To provide a complete security solution for applications, the core library uses  extensions  -- components that extend operations enabled by the core.  Examples of extensions include:\n- credentials repositories such as relational databases or LDAP directories\n- access control policies residing in data sources such as relational databases\n- authentication methodologies such as social-media based authentication or\n  multi-factor authentication\n- caching mechanisms",
            "title": "Extensions"
        },
        {
            "location": "/library/#integrations",
            "text": "Yosai is designed to provide security related functionality in such a way that\nit can be used with ANY kind of application, including desktop apps, web apps,\ninternet-enabled devices, etc.  Yosai is adapted to an application through what is known as an  integration \nlibrary.  Since a large number of applications are web-based applications, a helper\nlibrary, yosai.web, is included.  The yosai.web library should be used to help\nadapt yosai to the web application of your choice, yet specific customizations\nare left as an exercise for yosai integration development.  Developers are\nencouraged to submit to The Yosai Project integrations for license-compatible\nprojects.   Yosai is being released with \"batteries included\" so that it may be used in a\nproject without requiring additional implementation (for quick starts).  To achieve this goal, two integration projects were added to The Yosai Project, providing access to a peristence layer and caching:",
            "title": "Integrations"
        },
        {
            "location": "/library/#yosai-alchemystore",
            "text": "An AccountStore implemented with SQLAlchemy.  The project includes a\nbasic RBAC data model that uses a flat, non-heirarchical design.",
            "title": "Yosai AlchemyStore"
        },
        {
            "location": "/library/#yosai-dpcache",
            "text": "This is an integration of the dogpile.cache project.  Yosai reduces objects\nto their serializable form using Marshmallow, encodes them, and then caches.\nObjects obtained from cache are de-serialized into reduced form and then\nre-materialized into Yosai objects.  dogpile.cache supports Redis, Memcached,\nand Riak off the shelf, featuring thread-safe asynchronous interaction using a\ndogpile lock mechanism.  A \u201cdogpile\u201d lock is one that allows a single thread to\ngenerate an expensive resource while other threads use the \u201cold\u201d value until\nthe \u201cnew\u201d value is ready.  Currently, only the Redis backend has been updated and tested.  If you would like to add other backends, your pull request is welcome.",
            "title": "Yosai DPCache"
        },
        {
            "location": "/credits/",
            "text": "Respectful Acknowledgement\n\n\n\n\nYosai would not exist without Apache Shiro. Yosai is a port-fork of Apache Shiro, version 2 alpha.  Further, source documentation and sections of this web site's documentation are derived from Apache Shiro sources.\n\n\nNaming Yosai\n\n\nIn Japanese, the word Shiro means Castle.  Yosai means fortress.\n\nLike the names, the projects are similar in meaning, but different.",
            "title": "Credits"
        },
        {
            "location": "/credits/#respectful-acknowledgement",
            "text": "Yosai would not exist without Apache Shiro. Yosai is a port-fork of Apache Shiro, version 2 alpha.  Further, source documentation and sections of this web site's documentation are derived from Apache Shiro sources.",
            "title": "Respectful Acknowledgement"
        },
        {
            "location": "/credits/#naming-yosai",
            "text": "In Japanese, the word Shiro means Castle.  Yosai means fortress. \nLike the names, the projects are similar in meaning, but different.",
            "title": "Naming Yosai"
        }
    ]
}