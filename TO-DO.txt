"""
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at
 
    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
"""

update DefaultSecurityManager set_realms and apply_cache_manager methods to 
use cache handlers rather than realms

update the SubjectStore to use a cache handler, so to be consistent with
how realms cache

Interfaces have been defined in the Shiro 2.0 alpha yet have no
corresponding concrete class implementation using them.  I presume this is 
due to their discretionary nature and that their implementation is subject
to change among the datastores used.  Requiring Concrete Implementations:
   - Account
   - AccountStore
   - AccountCacheResolver
   - AccountCacheKeyResolver
   - CacheManager

Porting annotations to python decorators

refactoring shiro thread-based concurrency to an appropriate concurrency 
solution in python
    - porting callables, runnables, etc (used in DelegatingSubject)

add eventbus functionality to the ModularRealmAuthorizor, and inject the 
eventbus from the DefaultSecurityManager into the MRA

write unit tests for remaining /session/session_untested classes, and migrate
the classes to session.py

port-refactor /config/IniSecurityManagerFactory

add versioning to Yosai

add packaging to Yosai

determine git workflow (rebase likely)

add the "fingerprint" attribute wherever the host attribute is currently captured

---------------------------------------------------------------------
add excessive-login-attempts logic:
    - login attempt time interval
    - maximum allowable login attempts within time interval
    - login-exhausted account lock time interval
    - maximum allowable login attemps until login-exhausted account lock

    Notes from Les:
    1) Store 3 additional columns in your User table:
    loginPeriodStartTimestamp, lastLoginAttemptTimestamp and
    loginAttemptCount. Based on what you configure the login period to be
    before accounts are locked (5 minutes?), you can increment the login
    attempt count. If that number ever becomes greater than what your
    system deems is allowed (3 tries?), then you would manually throw the
    ExcessiveAttemptsException. Then your login controller can react to
    that and show an appropriate GUI message.

    2) An even easier approach than #1, but which requires more disk
    storage, is to keep an event log of every login attempt. This is very
    simple - you enter an event into the event log for each login attempt
    with the timestamp the event occurred and the status of whether or not
    the login failed for that user. Then, determining if the account
    should be locked upon login is a very simple exercise - you query your
    event log to count all failed attempts for that user where the event
    timestamp is newer than (now - login period). If you receive any
    count greater than your configured number (say, 3), then you throw the
    exception.

---------------------------------------------------------------------

create a ContextFactory to replace the piecemeal xxxSettings classes that 
interface with yosai settings

porting functionality provided by servlet web-filter facility to pythonic decorators
to be used by web frameworks

consolidate authz.is_permitted and authz.has_role, using a generic get_results
method that takes the private method to use (_is_permitted or _has_role) as an argument
    - replace existing unit tests with new ones

adopt Pyramid's scaffolding implementation

tighten up who sets the resolver objects and where
 - there seems to be overlap between ModularRealmAuthorizer and DefaultSecurityManager
   with respects to injecting into realms

refactor method overloading, cleanly separating collection vs scalar arguments

create a SimpleAuthorizer, which maintains only ONE authorizing realm

within the ModularAuthorizer, keep a mapping in memory between identifier and realm

a sessionexecutor raises expired session events, which are received by the 
Authorizer and then relayed to the realm to clear cache

an expired session clears authorization and session cache

a refreshed authorization cache is one that replaces an invalidated authorization cache
and has a TTL that is in synch with the user's session


