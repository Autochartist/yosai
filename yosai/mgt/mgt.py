"""
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
"""

from cryptography.exceptions import InvalidToken
from cryptography.fernet import Fernet
from abc import ABCMeta, abstractmethod
import copy

from yosai import(
    AuthenticationException,
    DefaultAuthenticator,
    DefaultMGTSettings,
    DefaultPermission,
    DefaultSessionManager,
    DefaultSessionContext,
    DefaultSessionKey,
    DefaultSubjectContext,
    DeleteSubjectException,
    DefaultEventBus,
    IllegalArgumentException,
    InvalidSessionException,
    LogManager,
    ModularRealmAuthorizer,
    PermissionResolver,
    RoleResolver,
    SaveSubjectException,
    SerializationManager,
    SimpleRole,
    UnavailableSecurityManagerException,
    UnrecognizedAttributeException,
    event_bus,
    mgt_settings,
    mgt_abcs,
    authc_abcs,
    authz_abcs,
    event_abcs,
    cache_abcs,
)


class AbstractRememberMeManager(mgt_abcs.RememberMeManager):
    """
    Abstract implementation of the RememberMeManager interface that handles
    serialization and encryption of the remembered user identity.

    The remembered identity storage location and details are left to
    subclasses.

    Default encryption key
    -----------------------
    This implementation uses the Fernet API from PyCA's cryptography for
    symmetric encryption. As per the documentation, Fernet uses AES in CBC mode
    with a 128-bit key for encryption and uses PKCS7 padding:
        https://cryptography.io/en/stable/fernet/

    It also uses a default, generated symmetric key to both encrypt and decrypt
    data.  As AES is a symmetric cipher, the same key is used to both encrypt
    and decrypt data, BUT NOTE:

    Because Yosai is an open-source project, if anyone knew that you were
    using Yosai's default key, they could download/view the source, and with
    enough effort, reconstruct the key and decode encrypted data at will.

    Of course, this key is only really used to encrypt the remembered
    IdentifierCollection, which is typically a user id or username.  So if you
    do not consider that sensitive information, and you think the default key
    still makes things 'sufficiently difficult', then you can ignore this
    issue.

    However, if you do feel this constitutes sensitive information, it is
    recommended that you provide your own key and set it via the cipher_key
    property attribute to a key known only to your application,
    guaranteeing that no third party can decrypt your data.

    You can generate your own key by importing fernet and calling its
    generate_key method:
       >>> from cryptography.fernet import Fernet
       >>> key = Fernet.generate_key()

    your key will be a byte string that looks like this:
        b'cghiiLzTI6CUFCO5Hhh-5RVKzHTQFZM2QSZxxgaC6Wo='

        copy and paste YOUR newly generated byte string, excluding the
        bytestring notation, into its respective place in /conf/yosai_settings.json
        following this format:
            DEFAULT_CIPHER_KEY = "cghiiLzTI6CUFCO5Hhh-5RVKzHTQFZM2QSZxxgaC6Wo="
    """

    def __init__(self):

        # new to yosai:
        self.serialization_manager = SerializationManager()

        self.encryption_cipher_key = None
        self.decryption_cipher_key = None

        # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i!!!!!!!!
        # !!!
        # !!!                    HEY  YOU!
        # !!! Generate your own cipher key using the instructions above and
        # !!! update your yosai settings file to include it.  The code below
        # !!! references this key.  Yosai does not include a default key.
        # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # as default, the encryption key == decryption key:
        default_key = mgt_settings.default_cipher_key

        self.set_cipher_key(encrypt_key=default_key, decrypt_key=default_key)

    def set_cipher_key(self, encrypt_key, decrypt_key):
        """
        :param cipher_key: the private key used to encrypt and decrypt
        :type cipher_key: a string
        """
        self.encryption_cipher_key = bytes(encrypt_key, 'utf-8')
        self.decryption_cipher_key = bytes(decrypt_key, 'utf-8')

    @abstractmethod
    def forget_identity(self, subject):
        """
        Forgets (removes) any remembered identity data for the specified
        Subject instance.

        :param subject: the subject instance for which identity data should be
                        forgotten from the underlying persistence mechanism
        """
        pass

    def is_remember_me(self, authc_token):
        """
        Determines whether remember me services should be performed for the
        specified token.

        :param authc_token: the authentication token submitted during the
                            successful authentication attempt
        :returns: True if remember me services should be performed as a
                  result of the successful authentication attempt
        """
        # Yosai uses a more implicit check:
        try:
            return authc_token.is_remember_me
        except AttributeError:
            return False

    def on_successful_login(self, subject, authc_token, account):
        """
        Reacts to the successful login attempt by first always
        forgetting any previously stored identity.  Then if the authc_token
        is a RememberMe type of token, the associated identity
        will be remembered for later retrieval during a new user session.

        :param subject: the subject whose identifying attributes are being
                        remembered
        :param authc_token:  the token that resulted in a successful
                             authentication attempt
        :param account: account that contains the authentication info resulting
                        from the successful authentication attempt
        """
        # always clear any previous identity:
        self.forget_identity(subject)

        # now save the new identity:
        if (self.is_remember_me(authc_token)):
            self.remember_identity(subject, authc_token, account)
        else:
            msg = ("AuthenticationToken did not indicate that RememberMe is "
                   "requested.  RememberMe functionality will not be executed "
                   "for corresponding account.")
            print(msg)
            # log debug here

    # yosai omits authc_token argument as its for an edge case
    def remember_identity(self, subject, identifier_s=None, account=None):
        """
        Yosai consolidates rememberIdentity, an overloaded method in java,
        to a method that will use an identifier_s-else-account logic.

        Remembers a subject-unique identity for retrieval later.  This
        implementation first resolves the exact identifying attributes to
        remember.  It then remembers these identifying attributes by calling
            remember_identity(Subject, IdentifierCollection)

        :param subject:  the subject for which the identifying attributes are
                         being remembered
        :param identifier_s: the identifying attributes to remember for retrieval
                            later on
        :param account: the account containing authentication info resulting
                         from the successful authentication attempt
        """
        if not identifier_s:  # then account must not be None
            try:
                identifier_s = self.get_identity_to_remember(subject, account)
            except AttributeError:
                msg = "Neither account nor identifier_s arguments passed"
                raise IllegalArgumentException(msg)

        serialized = self.convert_identifier_s_to_bytes(identifier_s)
        self.remember_serialized_identity(subject, serialized)

    def get_identity_to_remember(self, subject, account):
        """
        Returns the account's identifier_s and ignores the subject argument

        :param subject: the subject whose identifier_s are remembered
        :param account: the account resulting from the successful authentication attempt
        :returns: the IdentifierCollection to remember
        """
        return account.identifier_s

    def convert_identifier_s_to_bytes(self, identifier_s):
        """
        Encryption requires a binary type as input, so this method converts
        the identifier_s collection object to one.

        :type identifier_s: a serializable IdentifierCollection object
        :returns: a bytestring
        """

        # serializes to bytes by default:
        return self.serialization_manager.serialize(identifier_s)

    @abstractmethod
    def remember_serialized_identity(subject, serialized):
        """
        Persists the identity bytes to a persistent store for retrieval
        later via the get_remembered_serialized_identity(SubjectContext)
        method.

        :param subject: the Subject for whom the identity is being serialized
        :param serialized: the serialized bytes to be persisted.
        """
        pass

    def get_remembered_identifier_s(self, subject_context):
        identifier_s = None
        try:
            serialized = self.get_remembered_serialized_identity(subject_context)
            if serialized:
                identifier_s = self.convert_bytes_to_identifier_s(identifier_s,
                                                                  subject_context)
        except Exception as ex:
            identifier_s = \
                self.on_remembered_identifier_failure(ex, subject_context)

        return identifier_s

    @abstractmethod
    def get_remembered_serialized_identity(subject_context):
        """
        Based on the given subject context data, retrieves the previously
        persisted serialized identity, or None if there is no available data.
        The context map is usually populated by a SubjectBuilder
        implementation.  See the SubjectFactory class constants for Yosai's
        known map keys.

        :param subject_context: the contextual data, usually provided by a
                                SubjectBuilder implementation, that
                                is being used to construct a Subject instance.

        :returns: the previously persisted serialized identity, or None if
                  no such data can be acquired for the Subject
        """
        pass

    def convert_bytes_to_identifier_s(self, serialized, subject_context):
        """
        If a cipher_service is available, it will be used to first decrypt the
        serialized message.  Then, the bytes are deserialized and returned.

        :param serialized:      the bytes to decrypt and then deserialize
        :param subject_context: the contextual data, usually provided by a
                                SubjectBuilder implementation, that is being
                                used to construct a Subject instance
        :returns: the de-serialized identifier_s
        """

        # unlike Shiro, Yosai assumes that the message is encrypted:
        decrypted = self.decrypt(serialized)

        return self.serialization_manager.deserialize(decrypted)

    def on_remembered_identifier_failure(self, exc, subject_context):
        """
        Called when an exception is thrown while trying to retrieve identifier_s.
        The default implementation logs a debug message and forgets ('unremembers')
        the problem identity by calling forget_identity(subject_context) and
        then immediately re-raises the exception to allow the calling
        component to react accordingly.

        This method implementation never returns an object - it always rethrows,
        but can be overridden by subclasses for custom handling behavior.

        This most commonly would be called when an encryption key is updated
        and old identifier_s are retrieved that have been encrypted with the
        previous key.

        :param exc: the exception that was thrown
        :param subject_context: the contextual data, usually provided by a
                                SubjectBuilder implementation, that is being
                                used to construct a Subject instance
        :raises:  the original Exception passed is propagated in all cases
        """
        msg = ("There was a failure while trying to retrieve remembered "
               "identifier_s.  This could be due to a configuration problem or "
               "corrupted identifier_s.  This could also be due to a recently "
               "changed encryption key.  The remembered identity will be "
               "forgotten and not used for this request.", exc)
        print(msg)
        # log debug here

        self.forget_identity(subject_context)

        # propagate - security manager implementation will handle and warn
        # appropriately:
        raise exc

    def encrypt(self, serialized):
        """
        Encrypts the serialized message using Fernet

        :param serialized: the serialized object to encrypt
        :type serialized: bytes
        :returns: an encrypted bytes returned by Fernet
        """

        fernet = Fernet(self.encryption_cipher_key)
        return fernet.encrypt(serialized)

    def decrypt(self, encrypted):
        """
        decrypts the encrypted message using Fernet

        :param encrypted: the encrypted message
        :returns: the decrypted, serialized identifier_s collection
        """
        fernet = Fernet(self.decryption_cipher_key)
        return fernet.decrypt(encrypted)

    def on_failed_login(self, subject, authc_token, ae):
        """
        Reacts to a failed login by immediately forgetting any previously
        remembered identity.  This is an additional security feature to prevent
        any remenant identity data from being retained in case the
        authentication attempt is not being executed by the expected user.

        :param subject: the subject which executed the failed login attempt
        :param authc_token:   the authentication token resulting in a failed
                              login attempt - ignored by this implementation
        :param ae:  the exception thrown as a result of the failed login
                    attempt - ignored by this implementation
        """
        self.forget_identity(subject)

    def on_logout(self, subject):
        """
        Reacts to a subject logging out of the application and immediately
        forgets any previously stored identity and returns.

        :param subject: the subject logging out
        """
        self.forget_identity(subject)


# also known as ApplicationSecurityManager in Shiro 2.0 alpha:
class DefaultSecurityManager(mgt_abcs.SecurityManager,
                             event_abcs.EventBusAware,
                             cache_abcs.CacheManagerAware):

    def __init__(self,
                 realms=None,
                 event_bus=event_bus,
                 cache_manager=None,
                 authenticator=DefaultAuthenticator(),
                 authorizer=ModularRealmAuthorizer(),
                 session_manager=None,
                 remember_me_manager=None,
                 subject_store=None,
                 subject_factory=None,
                 permission_resolver=PermissionResolver(DefaultPermission),
                 role_resolver=RoleResolver(SimpleRole)):

        self.realms = realms
        self._event_bus = event_bus
        self._cache_manager = cache_manager
        self.authenticator = authenticator
        self.authorizer = authorizer
        self.session_manager = session_manager
        self.remember_me_manager = remember_me_manager
        self.subject_store = subject_store
        self.subject_factory = subject_factory
        self.permission_resolver = permission_resolver
        self.role_resolver = role_resolver

    """
    * ===================================================================== *
    * Getters and Setters                                                   *
    * ===================================================================== *
    """
    @property
    def authenticator(self):
        return self._authenticator

    @authenticator.setter
    def authenticator(self, authenticator):
        if authenticator:
            self._authenticator = authenticator

            if (isinstance(self._authenticator, DefaultAuthenticator)):
                self._authenticator.realms = self.realms

            self.apply_event_bus(self._authenticator)
            self.apply_cache_manager(self._authenticator)

        else:
            msg = "authenticator parameter must have a value"
            raise IllegalArgumentException(msg)

    @property
    def authorizer(self):
        return self._authorizer

    @authorizer.setter
    def authorizer(self, authorizer):
        if authorizer:
            self._authorizer = authorizer
            self.apply_event_bus(self._authorizer)
            self.apply_cache_manager(self._authorizer)
            self.apply_permission_resolver(self._authorizer)
            self.apply_role_resolver(self._authorizer)
        else:
            msg = "authorizer parameter must have a value"
            raise IllegalArgumentException(msg)

    @property
    def cache_manager(self):
        return self._cache_manager

    @cache_manager.setter
    def cache_manager(self, cachemanager):
        if (cachemanager):
            self._cache_manager = cachemanager
            self.apply_cache_manager(
                self.get_dependencies_for_injection(self._cache_manager))

        else:
            msg = ('Incorrect parameter.  If you want to disable caching, '
                   'configure a disabled cachemanager instance')
            raise IllegalArgumentException(msg)

    #  property required by EventBusAware interface:
    @property
    def event_bus(self):
        return self._event_bus

    @event_bus.setter
    def event_bus(self, eventbus):
        if eventbus:
            self._event_bus = eventbus
            self.apply_event_bus(
                self.get_dependencies_for_injection(self._event_bus))

        else:
            msg = 'eventbus parameter must have a value'
            raise IllegalArgumentException(msg)

    def set_realms(self, realm_s):
        """
        :realm_s: an immutable collection of one or more realms
        :type realm_s: tuple
        """
        if realm_s:
            self.apply_event_bus(realm_s)
            self.apply_cache_manager(realm_s)  # TBD:  must update to use cache handlers!

            # new to yosai (shiro v2 alpha is missing it):
            self.apply_permission_resolver(realm_s)
            self.apply_role_resolver(realm_s)

            authc = self.authenticator
            if (isinstance(authc, DefaultAuthenticator)):
                authc.realms = realm_s

            authz = self.authorizer
            if (isinstance(authz, ModularRealmAuthorizer)):
                authz.realms = realm_s

        else:
            msg = 'Cannot pass None as a parameter value for realms'
            raise IllegalArgumentException(msg)

    # new to yosai, helper method:
    def apply_target_s(self, validate_apply, target_s):
        try:
            for target in target_s:
                validate_apply(target)
        except TypeError:  # then its presumably not a collection
            validate_apply(target_s)

    def apply_cache_manager(self, target_s):
        """
        :param target: the object or objects that, if eligible, are to have
                       the cache manager set
        :type target: an individual object instance or iterable
        """
        # yosai refactored, deferring iteration to the methods that call it
        def validate_apply(target):
            if isinstance(target, cache_abcs.CacheManagerAware):
                target.cache_manager = self.cache_manager

        self.apply_target_s(validate_apply, target_s)

    def apply_event_bus(self, target_s):
        """
        :param target: the object or objects that, if eligible, are to have
                       the eventbus set
        :type target: an individual object instance or iterable
        """
        # yosai refactored, deferring iteration to the methods that call it

        def validate_apply(target):
            if isinstance(target, event_abcs.EventBusAware):
                target.event_bus = self.event_bus

        self.apply_target_s(validate_apply, target_s)

    def apply_permission_resolver(self, target_s):

        def validate_apply(target):
            if isinstance(target, authz_abcs.PermissionResolverAware):
                target.permission_resolver = self.permission_resolver

        self.apply_target_s(validate_apply, target_s)

    def apply_role_resolver(self, target_s):

        def validate_apply(target):
            if isinstance(target, authz_abcs.RoleResolverAware):
                target.role_resolver = self.role_resolver

        self.apply_target_s(validate_apply, target_s)

    def get_dependencies_for_injection(self, ignore):
        deps = {self._event_bus, self._cache_manager, self.realms,
                self.authenticator, self.authorizer,
                self.session_manager, self.subject_store,
                self.subject_factory, self.permission_resolver,
                self.role_resolver}
        try:
            deps.remove(ignore)
        except KeyError:
            msg = ("Could not remove " + str(ignore) +
                   " from dependencies_for_injection: ")
            print(msg)
            # log warning here

        return deps

    """
    * ===================================================================== *
    * Authenticator Methods                                                 *
    * ===================================================================== *
    """

    def authenticate_account(self, authc_token):
        return self.authenticator.authenticate_account(authc_token)

    """
    * ===================================================================== *
    * Authorizer Methods                                                    *
    *
    * Note: Yosai refactored authz functionality in order to eliminate
    *       method overloading
    * ===================================================================== *
    """
    def is_permitted(self, identifier_s, permission_s):
        """
        :param identifier_s: a collection of identifier_s
        :type identifier_s: Set

        :param permission_s: a collection of 1..N permissions
        :type permission_s: List of Permission object(s) or String(s)

        :returns: a List of tuple(s), containing the Permission and a Boolean
                  indicating whether the permission is granted
        """
        return self.authorizer.is_permitted(identifier_s, permission_s)

    def is_permitted_collective(self, identifier_s, permission_s, logical_operator):
        """
        :param identifier_s: a collection of identifier_s
        :type identifier_s: Set

        :param permission_s: a collection of 1..N permissions
        :type permission_s: List of Permission object(s) or String(s)

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :returns: a Boolean
        """
        return self.authorizer.is_permitted_collective(identifier_s,
                                                       permission_s,
                                                       logical_operator)

    def check_permission(self, identifier_s, permission_s, logical_operator):
        """
        :param identifier_s: a collection of identifier_s
        :type identifier_s: Set

        :param permission_s: a collection of 1..N permissions
        :type permission_s: List of Permission objects or Strings

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :returns: a List of Booleans corresponding to the permission elements
        """
        return self.authorizer.check_permission(identifier_s,
                                                permission_s,
                                                logical_operator)

    def has_role(self, identifier_s, roleid_s):
        """
        :param identifier_s: a collection of identifier_s
        :type identifier_s: Set

        :param roleid_s: 1..N role identifier_s
        :type roleid_s:  a String or List of Strings

        :returns: a tuple containing the roleid and a boolean indicating
                  whether the role is assigned (this is different than Shiro)
        """
        return self.authorizer.has_role(identifier_s, roleid_s)

    def has_role_collective(self, identifier_s, roleid_s, logical_operator):
        """
        :param identifier_s: a collection of identifier_s
        :type identifier_s: Set

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :param roleid_s: 1..N role identifier_s
        :type roleid_s:  a String or List of Strings

        :returns: a Boolean
        """
        return self.authorizer.has_role_collective(identifier_s,
                                                   roleid_s, logical_operator)

    def check_role(self, identifier_s, roleid_s, logical_operator):
        """
        :param identifier_s: a collection of identifier_s
        :type identifier_s: Set

        :param roleid_s: 1..N role identifier_s
        :type roleid_s:  a String or List of Strings

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :raises UnauthorizedException: if Subject not assigned to all roles
        """
        return self.authorizer.check_role(identifier_s,
                                          roleid_s, logical_operator)

    """
    * ===================================================================== *
    * SessionManager Methods                                                *
    * ===================================================================== *
    """
    def start(self, session_context):
        return self.session_manager.start(session_context)

    def get_session(self, session_key):
        return self.session_manager.get_session(session_key)

    """
    * ===================================================================== *
    * SecurityManager Methods                                               *
    * ===================================================================== *
    """

    def create_subject_context(self):
        return DefaultSubjectContext()

    def create_subject(self,
                       authc_token=None,
                       account=None,
                       existing_subject=None,
                       subject_context=None):

        if not subject_context:
            context = self.create_subject_context()
            context.authenticated = True
            context.authentication_token = authc_token
            context.account = account
            if (existing_subject):
                context.subject = existing_subject

        else:
            context = copy.copy(subject_context)

        # ensure that the context has a security_manager instance, and if
        # not, add one:
        context = self.ensure_security_manager(context)

        # Resolve an associated Session (usually based on a referenced
        # session ID), and place it in the context before sending to the
        # subject_factory.  The subject_factory should not need to know how
        # to acquire sessions as the process is often environment specific -
        # better to shield the SF from these details:
        context = self.resolve_session(context)

        # Similarly, the subject_factory should not require any concept of
        # remember_me -- translate that here first if possible before handing
        # off to the subject_factory:
        context = self.resolve_identifier_s(context)
        subject = self.do_create_subject(context)

        # save this subject for future reference if necessary:
        # (this is needed here in case remember_me identifier_s were resolved
        # and they need to be stored in the session, so we don't constantly
        # re-hydrate the remember_me identifier_collection on every operation).
        self.save(subject)
        return subject

    def remember_me_successful_login(self, authc_token, account, subject):
        rmm = self.remember_me_manager
        if (rmm is not None):
            try:
                rmm.on_successful_login(subject, authc_token, account)
            except Exception as ex:
                msg = ("Delegate RememberMeManager instance of type [" +
                       rmm.__class__.__name__ + "] threw an exception "
                       + "during on_successful_login.  RememberMe services "
                       + "will not be performed for account [" + account +
                       "].")
                print(msg)
                # log warn , including exc_info=ex

        else:
            msg = ("This " + rmm.__class__.__name__ +
                   " instance does not have a [RememberMeManager] instance " +
                   "configured.  RememberMe services will not be performed " +
                   "for account [" + account + "].")
            print(msg)
            # log trace here

    def remember_me_failed_login(self, authc_token, authc_exc, subject):
        rmm = self.remember_me_manager
        if (rmm is not None):
            try:
                rmm.on_failed_login(subject, authc_token, authc_exc)

            except Exception as ex:
                msg = ("Delegate RememberMeManager instance of type "
                       "[" + rmm.__class__.__name__ + "] threw an exception "
                       "during on_failed_login for AuthenticationToken [" +
                       authc_token + "].")
                print(msg)
                # log warning here , including exc_info = ex

    def remember_me_logout(self, subject):
        rmm = self.remember_me_manager
        if (rmm is not None):
            try:
                rmm.on_logout(subject)
            except Exception as ex:
                msg = ("Delegate RememberMeManager instance of type [" +
                       rmm.__class__.__name__ + "] threw an exception during "
                       "on_logout for subject with identifier_s [{identifier_s}]".
                       format(identifier_s=subject.identifier_s if subject else None))
                print(msg)
                # log warn, including exc_info = ex

    def login(self, subject, authc_token):
        try:
            account = self.authenticate_account(authc_token)
        except AuthenticationException as authc_ex:
            try:
                self.on_failed_login(authc_token, authc_ex, subject)
            except Exception as ex:
                msg = ("on_failed_login method raised an exception.  Logging "
                       "and propagating original AuthenticationException.", ex)
                print(msg)
                # log info here, including exc_info=ex
            raise

        logged_in = self.create_subject(authc_token, account, subject)
        self.on_successful_login(authc_token, account, logged_in)
        return logged_in

    def on_successful_login(self, authc_token, account, subject):
        self.remember_me_successful_login(authc_token, account, subject)

    def on_failed_login(self, authc_token, authc_exc, subject):
        self.remember_me_failed_login(authc_token, authc_exc, subject)

    def before_logout(self, subject):
        self.remember_me_logout(subject)

    def copy(self, subject_context):
        return DefaultSubjectContext(subject_context)

    def do_create_subject(self, subject_context):
        return self.subject_factory.create_subject(subject_context)

    def save(self, subject):
        try:
            self.subject_store.save(subject)
        except AttributeError:
            msg = "no subject_store is defined, so cannot save subject"
            print(msg)
            # log here
            raise SaveSubjectException(msg)

    def delete(self, subject):
        try:
            self.subject_store.delete(subject)
        except AttributeError:
            msg = "no subject_store is defined, so cannot delete subject"
            print(msg)
            # log here
            raise DeleteSubjectException(msg)

    def ensure_security_manager(self, subject_context):
        try:
            if (subject_context.resolve_security_manager() is not None):
                msg = ("Subject Context already contains a security_manager "
                       "instance. Returning.")
                print(msg)
                # log trace here
                return subject_context

            msg = ("No security_manager found in context.  Adding self "
                   "reference.")
            print(msg)
            # log trace here

            subject_context.security_manager = self

        except AttributeError:
            msg = 'subject_context is invalid'
            print(msg)
            # log exception here
            raise IllegalArgumentException(msg)
        return subject_context

    def resolve_session(self, subject_context):
        if (subject_context.resolve_session() is not None):
            msg = ("Context already contains a session.  Returning.")
            print(msg)
            # log debug here
            return subject_context

        try:
            # Context couldn't resolve it directly, let's see if we can
            # since we  have direct access to the session manager:
            session = self.resolve_context_session(subject_context)
            if (session is not None):
                subject_context.session = session

        except InvalidSessionException as ex:
            msg = ("Resolved subject_subject_context context session is "
                   "invalid.  Ignoring and creating an anonymous "
                   "(session-less) Subject instance.")
            print(msg)
            # log debug here, including exc_info=ex

        return subject_context

    def resolve_context_session(self, subject_context):
        session_key = self.get_session_key(subject_context)

        if (session_key is not None):
            return self.get_session(session_key)

        return None

    def get_session_key(self, subject_context):
        session_id = subject_context.session_id
        if (session_id is not None):
            return DefaultSessionKey(session_id)
        return None

    # yosai omits is_empty method

    def resolve_identifier_s(self, subject_context):
        identifier_s = subject_context.resolve_identifier_s()
        if (not identifier_s):
            msg = ("No identity (identifier_collection) found in the "
                   "subject_context.  Looking for a remembered identity.")
            print(msg)
            # log trace here

            identifier_s = self.get_remembered_identity(subject_context)

            if identifier_s:
                msg = ("Found remembered IdentifierCollection.  Adding to the "
                       "context to be used for subject construction by the "
                       "SubjectFactory.")
                print(msg)
                # log debug here
                subject_context.identifier_s = identifier_s

            else:
                msg = ("No remembered identity found.  Returning original "
                       "context.")
                print(msg)
                # log trace here

        return subject_context

    def create_session_context(self, subject_context):
        session_context = DefaultSessionContext()

        if (not subject_context.is_empty):
            # TBD:  not sure how acquired attributes are referenced (get vs property)
            session_context.put_all(subject_context)

        session_id = subject_context.session_id
        if (session_id):
            session_context.session_id = session_id

        host = subject_context.resolve_host()
        if (host):
            session_context.host = host

        return session_context

    def logout(self, subject):
        """
        :type subject:  Subject
        """
        if (subject is None):
            msg = "Subject argument cannot be None."
            raise IllegalArgumentException(msg)

        self.before_logout(subject)

        identifier_s = subject.identifier_s
        if (identifier_s):
            msg = ("Logging out subject with primary identifier {0}".format(
                   identifier_s.primary_identifier))
            print(msg)
            # log debug here
            authc = self.authenticator
            if (isinstance(authc, authc_abcs.LogoutAware)):
                authc.on_logout(identifier_s)

        try:
            self.delete(subject)
        except Exception as ex:
            msg = "Unable to cleanly unbind Subject.  Ignoring (logging out)."
            print(msg)
            # log debug here, including exc_info = ex
        finally:
            try:
                self.stop_session(subject)
            except Exception as ex2:
                msg2 = ("Unable to cleanly stop Session for Subject. "
                        "Ignoring (logging out).", ex2)
                print(msg2)
                # log debug here, including exc_info = ex

    def stop_session(self, subject):
        session = subject.get_session(False)
        if (session):
            session.stop()

    def get_remembered_identity(self, subject_context):
        rmm = self.remember_me_manager
        if rmm is not None:
            try:
                return rmm.get_remembered_identifier_s(subject_context)
            except Exception as ex:
                msg = ("Delegate RememberMeManager instance of type [" +
                       rmm.__class__.__name__ + "] raised an exception during "
                       "get_remembered_identifier_s().")
                print(msg)
                # log warn here , including exc_info = ex
        return None
