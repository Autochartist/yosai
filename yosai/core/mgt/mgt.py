"""
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
"""
import logging
import copy

from cryptography.fernet import Fernet
from abc import abstractmethod

from yosai.core import(
    AuthenticationException,
    AuthzInfoResolver,
    Credential,
    CredentialResolver,
    DefaultAuthenticator,
    DefaultPermission,
    DefaultNativeSessionManager,
    DefaultSessionContext,
    DefaultSessionKey,
    DefaultSubjectContext,
    DefaultSubjectFactory,
    DefaultSubjectStore,
    DeleteSubjectException,
    InvalidArgumentException,
    IndexedAuthorizationInfo,
    InvalidSessionException,
    ModularRealmAuthorizer,
    PermissionResolver,
    RoleResolver,
    SaveSubjectException,
    SimpleSession,
    SerializationManager,
    SimpleRole,
    event_bus,
    mgt_settings,
    mgt_abcs,
    authc_abcs,
    authz_abcs,
    event_abcs,
    cache_abcs,
)

logger = logging.getLogger(__name__)


class AbstractRememberMeManager(mgt_abcs.RememberMeManager):
    """
    Abstract implementation of the RememberMeManager interface that handles
    serialization and encryption of the remembered user identity.

    The remembered identity storage location and details are left to
    subclasses.

    Default encryption key
    -----------------------
    This implementation uses the Fernet API from PyCA's cryptography for
    symmetric encryption. As per the documentation, Fernet uses AES in CBC mode
    with a 128-bit key for encryption and uses PKCS7 padding:
        https://cryptography.io/en/stable/fernet/

    It also uses a default, generated symmetric key to both encrypt and decrypt
    data.  As AES is a symmetric cipher, the same key is used to both encrypt
    and decrypt data, BUT NOTE:

    Because Yosai is an open-source project, if anyone knew that you were
    using Yosai's default key, they could download/view the source, and with
    enough effort, reconstruct the key and decode encrypted data at will.

    Of course, this key is only really used to encrypt the remembered
    IdentifierCollection, which is typically a user id or username.  So if you
    do not consider that sensitive information, and you think the default key
    still makes things 'sufficiently difficult', then you can ignore this
    issue.

    However, if you do feel this constitutes sensitive information, it is
    recommended that you provide your own key and set it via the cipher_key
    property attribute to a key known only to your application,
    guaranteeing that no third party can decrypt your data.

    You can generate your own key by importing fernet and calling its
    generate_key method:
       >>> from cryptography.fernet import Fernet
       >>> key = Fernet.generate_key()

    your key will be a byte string that looks like this:
        b'cghiiLzTI6CUFCO5Hhh-5RVKzHTQFZM2QSZxxgaC6Wo='

        copy and paste YOUR newly generated byte string, excluding the
        bytestring notation, into its respective place in /conf/yosai.core.settings.json
        following this format:
            DEFAULT_CIPHER_KEY = "cghiiLzTI6CUFCO5Hhh-5RVKzHTQFZM2QSZxxgaC6Wo="
    """

    def __init__(self):

        # new to yosai.core.
        self.serialization_manager = SerializationManager()

        self.encryption_cipher_key = None
        self.decryption_cipher_key = None

        # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!i!!!!!!!!
        # !!!
        # !!!                    HEY  YOU!
        # !!! Generate your own cipher key using the instructions above and
        # !!! update your yosai.core.settings file to include it.  The code below
        # !!! references this key.  Yosai does not include a default key.
        # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        # as default, the encryption key == decryption key:
        default_key = mgt_settings.default_cipher_key

        self.set_cipher_key(encrypt_key=default_key, decrypt_key=default_key)

    def set_cipher_key(self, encrypt_key, decrypt_key):
        """
        :param cipher_key: the private key used to encrypt and decrypt
        :type cipher_key: a string
        """
        self.encryption_cipher_key = bytes(encrypt_key, 'utf-8')
        self.decryption_cipher_key = bytes(decrypt_key, 'utf-8')

    @abstractmethod
    def forget_identity(self, subject):
        """
        Forgets (removes) any remembered identity data for the specified
        Subject instance.

        :param subject: the subject instance for which identity data should be
                        forgotten from the underlying persistence mechanism
        """
        pass

    def is_remember_me(self, authc_token):
        """
        Determines whether remember me services should be performed for the
        specified token.

        :param authc_token: the authentication token submitted during the
                            successful authentication attempt
        :returns: True if remember me services should be performed as a
                  result of the successful authentication attempt
        """
        # Yosai uses a more implicit check:
        try:
            return authc_token.is_remember_me
        except AttributeError:
            return False

    def on_successful_login(self, subject, authc_token, account):
        """
        Reacts to the successful login attempt by first always
        forgetting any previously stored identity.  Then if the authc_token
        is a RememberMe type of token, the associated identity
        will be remembered for later retrieval during a new user session.

        :param subject: the subject whose identifying attributes are being
                        remembered
        :param authc_token:  the token that resulted in a successful
                             authentication attempt
        :param account: account that contains the authentication info resulting
                        from the successful authentication attempt
        """
        # always clear any previous identity:
        self.forget_identity(subject)

        # now save the new identity:
        if (self.is_remember_me(authc_token)):
            self.remember_identity(subject, authc_token, account)
        else:
            if logger.getEffectiveLevel() <= logging.DEBUG:
                msg = ("AuthenticationToken did not indicate that RememberMe is "
                       "requested.  RememberMe functionality will not be executed "
                       "for corresponding account.")
                logger.debug(msg)

    # yosai.core.omits authc_token argument as its for an edge case
    def remember_identity(self, subject, identifiers=None, account=None):
        """
        Yosai consolidates rememberIdentity, an overloaded method in java,
        to a method that will use an identifier-else-account logic.

        Remembers a subject-unique identity for retrieval later.  This
        implementation first resolves the exact identifying attributes to
        remember.  It then remembers these identifying attributes by calling
            remember_identity(Subject, IdentifierCollection)

        :param subject:  the subject for which the identifying attributes are
                         being remembered
        :param identifiers: the identifying attributes to remember for retrieval
                            later on
        :param account: the account containing authentication info resulting
                         from the successful authentication attempt
        """
        if not identifiers:  # then account must not be None
            try:
                identifiers = self.get_identity_to_remember(subject, account)
            except AttributeError:
                msg = "Neither account nor identifier arguments passed"
                raise InvalidArgumentException(msg)

        serialized = self.convert_identifiers_to_bytes(identifiers)
        self.remember_serialized_identity(subject, serialized)

    def get_identity_to_remember(self, subject, account):
        """
        Returns the account's identifier and ignores the subject argument

        :param subject: the subject whose identifiers are remembered
        :param account: the account resulting from the successful authentication attempt
        :returns: the IdentifierCollection to remember
        """
        return account.account_id

    def convert_identifiers_to_bytes(self, identifiers):
        """
        Encryption requires a binary type as input, so this method converts
        the identifier collection object to one.

        :type identifiers: a serializable IdentifierCollection object
        :returns: a bytestring
        """

        # serializes to bytes by default:
        return self.serialization_manager.serialize(identifiers)

    @abstractmethod
    def remember_serialized_identity(subject, serialized):
        """
        Persists the identity bytes to a persistent store for retrieval
        later via the get_remembered_serialized_identity(SubjectContext)
        method.

        :param subject: the Subject for whom the identity is being serialized
        :param serialized: the serialized bytes to be persisted.
        """
        pass

    def get_remembered_identifiers(self, subject_context):
        identifiers = None
        try:
            serialized = self.get_remembered_serialized_identity(subject_context)
            if serialized:
                identifiers = self.convert_bytes_to_identifier(identifiers,
                                                               subject_context)
        except Exception as ex:
            identifiers = \
                self.on_remembered_identifiers_failure(ex, subject_context)

        return identifiers

    @abstractmethod
    def get_remembered_serialized_identity(subject_context):
        """
        Based on the given subject context data, retrieves the previously
        persisted serialized identity, or None if there is no available data.
        The context map is usually populated by a SubjectBuilder
        implementation.  See the SubjectFactory class constants for Yosai's
        known map keys.

        :param subject_context: the contextual data, usually provided by a
                                SubjectBuilder implementation, that
                                is being used to construct a Subject instance.

        :returns: the previously persisted serialized identity, or None if
                  no such data can be acquired for the Subject
        """
        pass

    def convert_bytes_to_identifiers(self, serialized, subject_context):
        """
        If a cipher_service is available, it will be used to first decrypt the
        serialized message.  Then, the bytes are deserialized and returned.

        :param serialized:      the bytes to decrypt and then deserialize
        :param subject_context: the contextual data, usually provided by a
                                SubjectBuilder implementation, that is being
                                used to construct a Subject instance
        :returns: the de-serialized identifier
        """

        # unlike Shiro, Yosai assumes that the message is encrypted:
        decrypted = self.decrypt(serialized)

        return self.serialization_manager.deserialize(decrypted)

    def on_remembered_identifiers_failure(self, exc, subject_context):
        """
        Called when an exception is thrown while trying to retrieve identifier.
        The default implementation logs a debug message and forgets ('unremembers')
        the problem identity by calling forget_identity(subject_context) and
        then immediately re-raises the exception to allow the calling
        component to react accordingly.

        This method implementation never returns an object - it always rethrows,
        but can be overridden by subclasses for custom handling behavior.

        This most commonly would be called when an encryption key is updated
        and old identifier are retrieved that have been encrypted with the
        previous key.

        :param exc: the exception that was thrown
        :param subject_context: the contextual data, usually provided by a
                                SubjectBuilder implementation, that is being
                                used to construct a Subject instance
        :raises:  the original Exception passed is propagated in all cases
        """
        if logger.getEffectiveLevel() <= logging.DEBUG:
            msg = ("There was a failure while trying to retrieve remembered "
                   "identifier.  This could be due to a configuration problem or "
                   "corrupted identifier.  This could also be due to a recently "
                   "changed encryption key.  The remembered identity will be "
                   "forgotten and not used for this request. ", exc)
            logger.debug(msg)

        self.forget_identity(subject_context)

        # propagate - security manager implementation will handle and warn
        # appropriately:
        raise exc

    def encrypt(self, serialized):
        """
        Encrypts the serialized message using Fernet

        :param serialized: the serialized object to encrypt
        :type serialized: bytes
        :returns: an encrypted bytes returned by Fernet
        """

        fernet = Fernet(self.encryption_cipher_key)
        return fernet.encrypt(serialized)

    def decrypt(self, encrypted):
        """
        decrypts the encrypted message using Fernet

        :param encrypted: the encrypted message
        :returns: the decrypted, serialized identifier collection
        """
        fernet = Fernet(self.decryption_cipher_key)
        return fernet.decrypt(encrypted)

    def on_failed_login(self, subject, authc_token, ae):
        """
        Reacts to a failed login by immediately forgetting any previously
        remembered identity.  This is an additional security feature to prevent
        any remenant identity data from being retained in case the
        authentication attempt is not being executed by the expected user.

        :param subject: the subject which executed the failed login attempt
        :param authc_token:   the authentication token resulting in a failed
                              login attempt - ignored by this implementation
        :param ae:  the exception thrown as a result of the failed login
                    attempt - ignored by this implementation
        """
        self.forget_identity(subject)

    def on_logout(self, subject):
        """
        Reacts to a subject logging out of the application and immediately
        forgets any previously stored identity and returns.

        :param subject: the subject logging out
        """
        self.forget_identity(subject)


# also known as ApplicationSecurityManager in Shiro 2.0 alpha:

class NativeSecurityManager(mgt_abcs.SecurityManager,
                            event_abcs.EventBusAware,
                            cache_abcs.CacheHandlerAware):

    def __init__(self,
                 realms=None,
                 event_bus=event_bus,
                 cache_handler=None,
                 authenticator=DefaultAuthenticator(),
                 authorizer=ModularRealmAuthorizer(),
                 session_manager=DefaultNativeSessionManager(),
                 session_attributes_schema=None,
                 remember_me_manager=None,
                 subject_store=DefaultSubjectStore(),  # unlike shiro, yosai defaults
                 subject_factory=DefaultSubjectFactory(),  # unlike shiro, yosai defaults
                 authz_info_resolver=AuthzInfoResolver(IndexedAuthorizationInfo),
                 credential_resolver=CredentialResolver(Credential),
                 permission_resolver=PermissionResolver(DefaultPermission),
                 role_resolver=RoleResolver(SimpleRole)):
        """
        :type realms: tuple
        :type session_attributes_schema: marshmallow.Schema
        """
        self._event_bus = event_bus
        self._cache_handler = cache_handler
        self.authz_info_resolver = authz_info_resolver
        self.credential_resolver = credential_resolver
        self.permission_resolver = permission_resolver
        self.role_resolver = role_resolver
        self.session_manager = session_manager
        self.realms = realms
        self.authenticator = authenticator
        self.authorizer = authorizer
        self.remember_me_manager = remember_me_manager
        self.subject_store = subject_store
        self.subject_factory = subject_factory

        if session_attributes_schema:
            SimpleSession.set_attributes_schema(session_attributes_schema)

    """
    * ===================================================================== *
    * Getters and Setters                                                   *
    * ===================================================================== *
    """
    @property
    def authenticator(self):
        return self._authenticator

    @authenticator.setter
    def authenticator(self, authenticator):
        if authenticator:
            self._authenticator = authenticator
            self.apply_event_bus(self._authenticator)
            self._authenticator.realms = self.realms

        else:
            msg = "authenticator argument must have a value"
            raise InvalidArgumentException(msg)

    @property
    def authorizer(self):
        return self._authorizer

    @authorizer.setter
    def authorizer(self, authorizer):
        if authorizer:
            self._authorizer = authorizer
            self.apply_event_bus(self._authorizer)
            self._authorizer.realms = self.realms
        else:
            msg = "authorizer argument must have a value"
            raise InvalidArgumentException(msg)

    @property
    def cache_handler(self):
        return self._cache_handler

    @cache_handler.setter
    def cache_handler(self, cachehandler):
        if (cachehandler):
            self._cache_handler = cachehandler

            self.apply_cache_handler(self.realms)
            self.authenticator.realms = self.realms
            self.authorizer.realms = self.realms

            self.apply_cache_handler(self.session_manager)

        else:
            msg = ('Incorrect argument.  If you want to disable caching, '
                   'configure a disabled cachemanager instance')
            raise InvalidArgumentException(msg)

    #  property required by EventBusAware interface:
    @property
    def event_bus(self):
        return self._event_bus

    @event_bus.setter
    def event_bus(self, eventbus):
        if eventbus:
            self._event_bus = eventbus
            self.apply_event_bus(self._authenticator)
            self.apply_event_bus(self._authorizer)
            self.apply_event_bus(self._session_manager)

        else:
            msg = 'eventbus argument must have a value'
            raise InvalidArgumentException(msg)

    @property
    def realms(self):
        return self._realms

    @realms.setter
    def realms(self, realm_s):
        """
        :realm_s: an immutable collection of one or more realms
        :type realm_s: tuple
        """
        if realm_s:
            self._realms = realm_s
            self.apply_cache_handler(self._realms)

            # new to yosai.core (shiro v2 alpha is missing it):
            self.apply_credential_resolver(self._realms)
            self.apply_authz_info_resolver(self._realms)
            self.apply_permission_resolver(self._realms)
            self.apply_role_resolver(self._realms)

            try:
                self.authenticator.realms = self._realms
            except AttributeError:
                msg = "no authenticator attribute set yet"
                # log debug here
            try:
                self.authorizer.realms = self._realms
            except AttributeError:
                msg = "no authorizer attribute set yet"
                # log debug here
        else:
            msg = 'realms argument must have a value'
            raise InvalidArgumentException(msg)

    @property
    def session_manager(self):
        return self._session_manager

    @session_manager.setter
    def session_manager(self, sessionmanager):
        self._session_manager = sessionmanager

        self.apply_cache_handler(self._session_manager)
        self.apply_event_bus(self._session_manager)

    # new to yosai.core. helper method:
    def apply_target_s(self, validate_apply, target_s):
        try:
            for target in target_s:
                validate_apply(target)
        except TypeError:  # then its presumably not a collection
            validate_apply(target_s)

    def apply_cache_handler(self, target_s):
        """
        :param target: the object or objects that, if eligible, are to have
                       the cache manager set
        :type target: an individual object instance or iterable
        """
        # yosai.core.refactored, deferring iteration to the methods that call it
        def validate_apply(target):
            if isinstance(target, cache_abcs.CacheHandlerAware):
                target.cache_handler = self.cache_handler

        self.apply_target_s(validate_apply, target_s)

    def apply_event_bus(self, target_s):
        """
        :param target: the object or objects that, if eligible, are to have
                       the eventbus set
        :type target: an individual object instance or iterable
        """
        # yosai.core.refactored, deferring iteration to the methods that call it

        def validate_apply(target):
            if isinstance(target, event_abcs.EventBusAware):
                target.event_bus = self.event_bus

        self.apply_target_s(validate_apply, target_s)

    def apply_authz_info_resolver(self, target_s):

        def validate_apply(target):
            if isinstance(target, authz_abcs.AuthzInfoResolverAware):
                target.authz_info_resolver = self.authz_info_resolver

        self.apply_target_s(validate_apply, target_s)

    def apply_credential_resolver(self, target_s):

        def validate_apply(target):
            if isinstance(target, authc_abcs.CredentialResolverAware):
                target.credential_resolver = self.credential_resolver

        self.apply_target_s(validate_apply, target_s)

    def apply_permission_resolver(self, target_s):

        def validate_apply(target):
            if isinstance(target, authz_abcs.PermissionResolverAware):
                target.permission_resolver = self.permission_resolver

        self.apply_target_s(validate_apply, target_s)

    def apply_role_resolver(self, target_s):

        def validate_apply(target):
            if isinstance(target, authz_abcs.RoleResolverAware):
                target.role_resolver = self.role_resolver

        self.apply_target_s(validate_apply, target_s)

    """
    * ===================================================================== *
    * Authenticator Methods                                                 *
    * ===================================================================== *
    """

    def authenticate_account(self, authc_token):
        return self.authenticator.authenticate_account(authc_token)

    """
    * ===================================================================== *
    * Authorizer Methods                                                    *
    *
    * Note: Yosai refactored authz functionality in order to eliminate
    *       method overloading
    * ===================================================================== *
    """
    def is_permitted(self, identifiers, permission_s):
        """
        :type identifiers: SimpleIdentifierCollection

        :param permission_s: a collection of 1..N permissions
        :type permission_s: List of Permission object(s) or String(s)

        :returns: a List of tuple(s), containing the Permission and a Boolean
                  indicating whether the permission is granted
        """
        return self.authorizer.is_permitted(identifiers, permission_s)

    def is_permitted_collective(self, identifiers, permission_s, logical_operator):
        """
        :type identifiers: SimpleIdentifierCollection

        :param permission_s: a collection of 1..N permissions
        :type permission_s: List of Permission object(s) or String(s)

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :returns: a Boolean
        """
        return self.authorizer.is_permitted_collective(identifiers,
                                                       permission_s,
                                                       logical_operator)

    def check_permission(self, identifiers, permission_s, logical_operator):
        """
        :type identifiers: SimpleIdentifierCollection

        :param permission_s: a collection of 1..N permissions
        :type permission_s: List of Permission objects or Strings

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :returns: a List of Booleans corresponding to the permission elements
        """
        return self.authorizer.check_permission(identifiers,
                                                permission_s,
                                                logical_operator)

    def has_role(self, identifiers, roleid_s):
        """
        :type identifiers: SimpleIdentifierCollection

        :param roleid_s: 1..N role identifier
        :type roleid_s:  Set of Strings

        :returns: a tuple containing the roleid and a boolean indicating
                  whether the role is assigned (this is different than Shiro)
        """
        return self.authorizer.has_role(identifiers, roleid_s)

    def has_role_collective(self, identifiers, roleid_s, logical_operator):
        """
        :type identifiers: SimpleIdentifierCollection

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :param roleid_s: 1..N role identifier
        :type roleid_s:  a Set of Strings

        :returns: a Boolean
        """
        return self.authorizer.has_role_collective(identifiers,
                                                   roleid_s, logical_operator)

    def check_role(self, identifiers, roleid_s, logical_operator):
        """
        :type identifiers: SimpleIdentifierCollection

        :param roleid_s: 1..N role identifier
        :type roleid_s:  a Set of Strings

        :param logical_operator:  indicates whether all or at least one
                                  permission check is true (any)
        :type: and OR all (from python standard library)

        :raises UnauthorizedException: if Subject not assigned to all roles
        """
        return self.authorizer.check_role(identifiers,
                                          roleid_s, logical_operator)

    """
    * ===================================================================== *
    * SessionManager Methods                                                *
    * ===================================================================== *
    """
    def start(self, session_context):
        return self.session_manager.start(session_context)

    def get_session(self, session_key):
        return self.session_manager.get_session(session_key)

    """
    * ===================================================================== *
    * SecurityManager Methods                                               *
    * ===================================================================== *
    """

    def create_subject_context(self):
        return DefaultSubjectContext()

    def create_subject(self,
                       authc_token=None,
                       account=None,
                       existing_subject=None,
                       subject_context=None):

        if subject_context is None:
            context = self.create_subject_context()

            context.authenticated = True
            context.authentication_token = authc_token
            context.account = account
            # context.identifiers = account.account_id  # new to yosai
            if (existing_subject):
                context.subject = existing_subject

        else:
            context = copy.copy(subject_context)

        # ensure that the context has a security_manager instance, and if
        # not, add one:
        context = self.ensure_security_manager(context)

        # Resolve an associated Session (usually based on a referenced
        # session ID), and place it in the context before sending to the
        # subject_factory.  The subject_factory should not need to know how
        # to acquire sessions as the process is often environment specific -
        # better to shield the SF from these details:
        context = self.resolve_session(context)

        # Similarly, the subject_factory should not require any concept of
        # remember_me -- translate that here first if possible before handing
        # off to the subject_factory:

        context = self.resolve_identifiers(context)

        subject = self.do_create_subject(context)  # DelegatingSubject

        # save this subject for future reference if necessary:
        # (this is needed here in case remember_me identifiers were resolved
        # and they need to be stored in the session, so we don't constantly
        # re-hydrate the remember_me identifier_collection on every operation).
        self.save(subject)
        return subject

    def remember_me_successful_login(self, authc_token, account, subject):
        rmm = self.remember_me_manager
        if (rmm is not None):
            try:
                rmm.on_successful_login(subject, authc_token, account)
            except Exception:
                if logger.getEffectiveLevel() <= logging.WARNING:
                    msg = ("Delegate RememberMeManager instance of type [" +
                           rmm.__class__.__name__ + "] threw an exception "
                           + "during on_successful_login.  RememberMe services "
                           + "will not be performed for account [" + str(account) +
                           "].")
                    logger.warning(msg, exc_info=True)

        else:

            if logger.getEffectiveLevel() <= logging.WARNING:
                msg = ("This " + rmm.__class__.__name__ +
                       " instance does not have a [RememberMeManager] instance " +
                       "configured.  RememberMe services will not be performed " +
                       "for account [" + str(account.account_id) + "].")
                logger.warning(msg)

    def remember_me_failed_login(self, authc_token, authc_exc, subject):
        rmm = self.remember_me_manager
        if (rmm is not None):
            try:
                rmm.on_failed_login(subject, authc_token, authc_exc)

            except Exception:
                if logger.getEffectiveLevel() <= logging.WARNING:
                    msg = ("Delegate RememberMeManager instance of type "
                           "[" + rmm.__class__.__name__ + "] threw an exception "
                           "during on_failed_login for AuthenticationToken [" +
                           str(authc_token) + "].")
                    logger.warning(msg, exc_info=True)

    def remember_me_logout(self, subject):
        rmm = self.remember_me_manager
        if (rmm is not None):
            try:
                rmm.on_logout(subject)
            except Exception as ex:
                if logger.getEffectiveLevel() <= logging.WARNING:
                    msg = ("Delegate RememberMeManager instance of type [" +
                           rmm.__class__.__name__ + "] threw an exception during "
                           "on_logout for subject with identifiers [{identifiers}]".
                           format(identifiers=subject.identifiers if subject else None))
                    logger.warning(msg, exc_info=True)

    def login(self, subject, authc_token):

        try:
            account = self.authenticate_account(authc_token)
        except AuthenticationException as authc_ex:
            try:
                self.on_failed_login(authc_token, authc_ex, subject)
            except Exception:
                if logger.getEffectiveLevel() == logging.INFO:
                    msg = ("on_failed_login method raised an exception.  Logging "
                           "and propagating original AuthenticationException.")
                    logger.info(msg, exc_info=True)
            raise

        logged_in = self.create_subject(authc_token=authc_token,
                                        account=account,
                                        existing_subject=subject)
        self.on_successful_login(authc_token, account, logged_in)
        return logged_in

    def on_successful_login(self, authc_token, account, subject):
        self.remember_me_successful_login(authc_token, account, subject)

    def on_failed_login(self, authc_token, authc_exc, subject):
        self.remember_me_failed_login(authc_token, authc_exc, subject)

    def before_logout(self, subject):
        self.remember_me_logout(subject)

    def copy(self, subject_context):
        return DefaultSubjectContext(subject_context)

    def do_create_subject(self, subject_context):
        return self.subject_factory.create_subject(subject_context)

    def save(self, subject):
        try:
            self.subject_store.save(subject)
        except AttributeError:
            msg = "no subject_store is defined, so cannot save subject"
            raise SaveSubjectException(msg)

    def delete(self, subject):
        try:
            self.subject_store.delete(subject)
        except AttributeError:
            msg = "no subject_store is defined, so cannot delete subject"
            raise DeleteSubjectException(msg)

    def ensure_security_manager(self, subject_context):
        try:
            if (subject_context.resolve_security_manager() is not None):
                msg = ("Subject Context already contains a security_manager "
                       "instance. Returning.")
                logger.debug(msg)
                return subject_context

            msg = ("No security_manager found in context.  Adding self "
                   "reference.")
            logger.debug(msg)

            subject_context.security_manager = self

        except AttributeError:
            msg = 'subject_context is invalid'
            raise InvalidArgumentException(msg)

        return subject_context

    def resolve_session(self, subject_context):
        if (subject_context.resolve_session() is not None):
            msg = ("Context already contains a session.  Returning.")
            logger.debug(msg)
            return subject_context

        try:
            # Context couldn't resolve it directly, let's see if we can
            # since we  have direct access to the session manager:
            session = self.resolve_context_session(subject_context)
            if (session is not None):
                subject_context.session = session

        except InvalidSessionException:
            msg = ("Resolved subject_subject_context context session is "
                   "invalid.  Ignoring and creating an anonymous "
                   "(session-less) Subject instance.")
            logger.debug(msg, exc_info=True)

        return subject_context

    def resolve_context_session(self, subject_context):
        session_key = self.get_session_key(subject_context)

        if (session_key is not None):
            return self.get_session(session_key)

        return None

    def get_session_key(self, subject_context):
        session_id = subject_context.session_id
        if (session_id is not None):
            return DefaultSessionKey(session_id)
        return None

    # yosai.core.omits is_empty method

    def resolve_identifiers(self, subject_context):
        """
        ensures that a subject_context has identifiers and if it doesn't will
        attempt to locate them using heuristics
        """
        identifiers = subject_context.resolve_identifiers()

        if (not identifiers):
            msg = ("No identity (identifier_collection) found in the "
                   "subject_context.  Looking for a remembered identity.")
            logger.debug(msg)

            identifiers = self.get_remembered_identity(subject_context)

            if identifiers:
                msg = ("Found remembered IdentifierCollection.  Adding to the "
                       "context to be used for subject construction by the "
                       "SubjectFactory.")
                logger.debug(msg)

                subject_context.identifiers = identifiers

            else:
                msg = ("No remembered identity found.  Returning original "
                       "context.")
                logger.debug(msg)

        return subject_context

    def create_session_context(self, subject_context):
        session_context = DefaultSessionContext()

        if (not subject_context.is_empty):
            # TBD:  not sure how acquired attributes are referenced (get vs property)
            session_context.put_all(subject_context)

        session_id = subject_context.session_id
        if (session_id):
            session_context.session_id = session_id

        host = subject_context.resolve_host()
        if (host):
            session_context.host = host

        return session_context

    def logout(self, subject):
        """
        :type subject:  Subject
        """
        if (subject is None):
            msg = "Subject argument cannot be None."
            raise InvalidArgumentException(msg)

        self.before_logout(subject)

        identifiers = copy.copy(subject.identifiers)   # copy is new to yosai
        if (identifiers):

            if logger.getEffectiveLevel() <= logging.DEBUG:
                msg = ("Logging out subject with primary identifier {0}".format(
                       identifiers.primary_identifier))
                logger.debug(msg)

            # yosai excludes call to authenticator's on_logout as shiro's observer
            # pattern has been replaced by the event bus interaction and
            # logout results in session expire event transmission, which is tracked
            # by the authenticator

        try:
            self.delete(subject)
        except Exception:
            if logger.getEffectiveLevel() <= logging.DEBUG:
                msg = "Unable to cleanly unbind Subject.  Ignoring (logging out)."
                logger.debug(msg, exc_info=True)

        finally:
            try:
                # passing identifiers is new to yosai:
                self.stop_session(subject, identifiers)
            except Exception:
                if logger.getEffectiveLevel() <= logging.DEBUG:
                    msg2 = ("Unable to cleanly stop Session for Subject. "
                            "Ignoring (logging out).")
                    logger.debug(msg2, exc_info=True)

    def stop_session(self, subject, identifiers):
        session = subject.get_session(False)
        if (session):
            session.stop(identifiers)

    def get_remembered_identity(self, subject_context):
        rmm = self.remember_me_manager
        if rmm is not None:
            try:
                return rmm.get_remembered_identifiers(subject_context)
            except Exception as ex:
                if logger.getEffectiveLevel() <= logging.WARNING:
                    msg = ("Delegate RememberMeManager instance of type [" +
                           rmm.__class__.__name__ + "] raised an exception during "
                           "get_remembered_identifiers().")
                    logger.warning(msg, exc_info=True)
        return None
